# Non-REST API: GraphQL, WebSocket, gRPC

## Содержание

* [GraphQL](#graphql)
  * [Зачем нужен GraphQL](#зачем-нужен-graphql)
  * [Преимущества и недостатки GraphQL](#преимущества-и-недостатки-graphql)
  * [Как работает GraphQL](#как-работает-graphql)
    * [Поля (fields)](#поля-fields)
    * [Аргументы (arguments)](#аргументы-arguments)
    * [Переменные (variables)](#переменные-variables)
    * [Фрагменты (fragments)](#фрагменты-fragments)
    * [Псевдонимы (aliases)](#псевдонимы-aliases)
    * [Директивы (directives)](#директивы-directives)
    * [Схема](#схема)
    * [CRUD в GraphQL](#crud-в-graphql)
* [WebSocket](#websocket)
  * [Установка соединения](#установка-соединения)
  * [WebSocket коды ответов](#websocket-коды-ответов)
  * [Тестирование WebSocket](#тестирование-websocket)
* [gRPC](#grpc)
  * [Преимущества gRPC](#преимущества-grpc)
  * [Статус-коды gRPC](#статус-коды-grpc)
  * [Тестирование gRPC](#тестирование-grpc)

## GraphQL

**GraphQL** — это специализированный *язык запросов* для работы с данными, разработанный компанией «Фейсбук» в 2012 году. Он решил проблему производительности мобильных приложений, которые часто получали от сервера избыточные или неполные данные.

До GraphQL разработчики в основном использовали REST API для взаимодействия с сервером. В REST-архитектуре у каждого ресурса есть уникальный URL-адрес, а клиенты общаются с сервером через HTTP-методы: GET, POST, PUT, DELETE и другие.

Допустим, мы хотим получить информацию о постах и подписчиках пользователя. С REST API нам придётся отправить несколько запросов, что приведёт к получению избыточных данных и увеличению нагрузки на сеть.

Пример запроса:

```http
GET /api/users/123
GET /api/users/123/posts
GET /api/users/123/followers
```

Ниже пример ответа с данными, которые мы не запрашивали. Сервер прислал дату рождения, адрес пользователя и полное содержание постов:

```json
// GET /api/users/123
{
  "id": "123",
  "name": "Иван Петров",
  "email": "ivan@example.com",
  "birthDate": "1990-01-01", // ? Избыточные данные
  "address": "ул. Пушкина, д. 10, г. Москва, Россия" // ? Избыточные данные
}

// GET /api/users/123/posts
[
  { "id": "1", "title": "Мой первый пост", "content": "Здесь содержание первого поста..." }, // ? Избыточные данные (content)
  { "id": "2", "title": "Второй пост", "content": "А это содержание второго поста..." } // ? Избыточные данные (content)
]

// GET /api/users/123/followers
[
  { "id": "456", "name": "Мария Сидорова" },
  { "id": "789", "name": "Алексей Иванов" }
]
```

Таким образом У REST API есть два больших минуса:

* **overfetching** - это ситуация, при которой endpoint возвращает в ответе огромное количество информации, которая вам может быть не нужна. Допустим, вам нужно было какое-то одно значение свойства, а сервис вернул вам в ответе всё, что надо и не надо.

* **underfetching** - обратная ситуация, когда endpoint возвращает недостаточное количество информации, и вам приходится делать несколько запросов, чтобы собрать полную картину с данными. И тем самым вы увеличите нагрузку на сервис.

А вот запрос, составленный с помощью GraphQL:

```graphql
query {
  user(id: "123") {
    name
    email
    posts {
      title
    }
    followers {
      name
    }
  }
}
```

Ответ от сервера:

```json
{
  "data": {
    "user": {
      "name": "Иван Петров",
      "email": "ivan@example.com",
      "posts": [
        { "title": "Мой первый пост" },
        { "title": "Второй пост" }
      ],
      "followers": [
        { "name": "Мария Сидорова" },
        { "name": "Алексей Иванов" }
      ]
    }
  }
}
```

### Зачем нужен GraphQL

GraphQL повышает производительность приложений, сокращает количество запросов, уменьшает объем передаваемых данных.

Помимо оптимизации запросов, GraphQL решает и другие важные задачи:

* **Упрощает интеграцию** различных систем и микросервисов, создавая единый API для доступа к разным источникам данных. Например, можно объединить данные из системы управления товарами, платёжной платформы и службы доставки.
* **Ускоряет процесс разработки**, позволяя адаптировать запросы под клиента без изменения серверной части. Например, мобильное приложение может запрашивать базовую информацию о пользователе, а веб-версия — расширенные данные. Это позволяет использовать один API для разных клиентов без изменений на сервере.
* **Упрощает работу с API**. GraphQL использует единую точку доступа для всех запросов, что позволяет мгновенно интегрировать новую информацию в систему. Например, если к товарам в интернет-магазине добавить новую характеристику, то она сразу станет доступной для всех клиентских приложений — для этого не придётся обновлять API или создавать новые точки доступа.
* **Обеспечивает простое обновление API**. Разработчики могут добавлять новые поля в схему GraphQL, не нарушая работу существующих клиентов. Это позволяет постепенно расширять функциональность API без создания новых версий или нарушения обратной совместимости. Например, если добавить поле «рейтинг» для товара, существующие приложения продолжат работать без изменений, а новые смогут использовать эту дополнительную информацию.

### Преимущества и недостатки GraphQL

#### Преимущества

* **Гибкость запросов**. В отличие от REST и SOAP, GraphQL позволяет клиентам запрашивать только необходимые данные, что уменьшает объём передаваемой информации и количество запросов. Например, с помощью GraphQL можно одним запросом получить профиль пользователя, его посты и список друзей. В случае с REST для этого пришлось бы выполнить несколько отдельных запросов.
* **Типизация данных**. В отличие от REST, GraphQL обладает встроенной строгой системой типов, что упрощает валидацию данных и снижает вероятность ошибок при разработке. Например, если в схеме GraphQL поле age определено как целое число, сервер автоматически отклонит запрос с некорректным значением — строкой тридцать вместо числа 30.
* **Версионирование API**. В отличие от REST и SOAP, GraphQL позволяет добавлять новые поля и типы без нарушения работы существующих запросов. Например, вы можете добавить поле phoneNumber к типу User в схеме GraphQL. После изменения существующие клиенты продолжат работать как прежде, а новые смогут использовать добавленное поле без создания новой версии API.
* **Производительность в сложных сценариях**. По сравнению с gRPC, GraphQL эффективнее обрабатывает комплексные запросы, когда необходимо получить связанную информацию из разных источников. Например, в e-commerce-приложении GraphQL может одним запросом извлечь детали товара, информацию о его наличии, отзывы и скидки. При использовании gRPC для получения той же информации потребовалось бы несколько вызовов.

#### Недостатки

Как и любая технология, GraphQL имеет свои недостатки, и один из ключевых — **сложность кэширования**. В REST кэширование настраивается с помощью стандартных HTTP-заголовков, а GraphQL не поддерживает эту функцию напрямую. Для решения этой проблемы необходимо использовать дополнительные библиотеки или разрабатывать собственную логику кэширования. Из-за этого GraphQL часто комбинируют с другими технологиями. Например, если у вас уже есть REST API, можно постепенно внедрять GraphQL, сохраняя преимущества обоих подходов.

Также минусом GraphQL является невозможность запросить **всю информацию** об объекте, нужно обязательно **перечислить** все запрашиваемые свойства в запросе.

### Как работает GraphQL

GraphQL функционирует по принципу «запрос — ответ» между клиентом и сервером:

* На сервере создаётся схема, описывающая все доступные типы данных, поля и операции, которые можно выполнить через API.
* Клиент формирует запрос, точно указывая необходимые данные.
* Клиент отправляет запрос на сервер через HTTP-метод POST.
* Сервер анализирует запрос, проверяет его соответствие схеме и выполняет нужные операции для получения данных.
* Сервер отправляет клиенту ответ, содержащий только запрашиваемую информацию.
* Клиент получает данные и использует их для обновления интерфейса или других операций.

Для построения запросов GraphQL используются шесть основных компонентов:

* поля (fields)
* аргументы (arguments)
* фрагменты (fragments)
* псевдонимы (aliases)
* переменные (variables)
* директивы (directives)

#### Поля (fields)

Поля в GraphQL — это запрашиваемые данные. Они определяют, какую именно информацию клиент хочет получить от сервера.

Порядок заполнения полей в GraphQL-запросе:

* Укажите нужные поля внутри фигурных скобок после имени запроса.
* Вложенные поля заключайте в фигурные скобки.
* Разделяйте поля переносом строки или пробелом.
* Не ставьте запятые между полями.

Пример:

```graphql
{
  user {
    name
    email
    posts {
      title
      content
    }
  }
}
```

Запросим у сервера имя и email пользователя:

```graphql
{
  user {
    name
    email
  }
}
```

Ответ сервера:

```json
{
  "data": {
    "user": {
      "name": "Иван Петров",
      "email": "ivanpetrov@example.com"
    }
  }
}
```

#### Аргументы (arguments)

Аргументы помогают уточнить запрос и получить конкретные данные. С их помощью вы можете фильтровать, сортировать или ограничивать результаты запроса.

Порядок добавления аргумента в GraphQL-запрос:

* Укажите аргумент в круглых скобках после имени поля.
* Используйте формат имя: значение для передачи аргумента.
* Разделяйте несколько аргументов запятыми.
* Заключайте значения строк в кавычки, а числа указывайте без кавычек.

Пример запроса с несколькими аргументами:

```graphql
{
  users(first: 5, status: "active") {
    name
    email
  }
}
# Ограничиваем результат пятью активными пользователями.
```

Ответ сервера:

```json
{
  "data": {
    "users": [
      {
        "name": "Иван Петров",
        "email": "ivanpetrov@example.com"
      },
      {
        "name": "Мария Сидорова",
        "email": "mariasidorova@example.com"
      },
      {
        "name": "Алексей Иванов",
        "email": "alexeyivanov@example.com"
      },
      {
        "name": "Елена Смирнова",
        "email": "elenasmirnova@example.com"
      },
      {
        "name": "Павел Козлов",
        "email": "pavelkozlov@example.com"
      }
    ]
  }
}
```

#### Переменные (variables)

Переменные в GraphQL повышают гибкость запросов — они позволяют использовать динамические параметры вместо фиксированных значений. Это удобно, когда нужно выполнить один запрос с разными значениями.

Порядок использования переменной:

* Объявите её в начале запроса, используя знак `$` перед именем переменной.
* Укажите тип переменной после двоеточия. Например: `String`, `Int`, `Boolean`.
* Добавьте восклицательный знак `!` после типа, если переменная обязательна.
* В самом запросе используйте переменную, указывая её имя со знаком `$`.

Для примера объявим переменную типа `ID`, обязательную для выполнения запроса:

```graphql
query getUser($id: ID!) {
  user(id: $id) {
    name
    email
  }
}
```

После объявления переменной мы должны отправить запрос на сервер, передав значение переменной `$id` в отдельном объекте JSON:

```json
{
  "id": "123"
}
// "123" — это ID пользователя, информацию о котором мы хотим получить.
```

Ответ сервера:

```json
{
  "data": {
    "user": {
      "name": "Иван Петров",
      "email": "ivanpetrov@example.com"
    }
  }
}
```

#### Фрагменты (fragments)

Фрагменты оптимизируют код, группируя часто используемые поля в единый блок. Это упрощает структуру запросов и облегчает их поддержку.

Порядок создания фрагмента:

* Используйте ключевое слово `fragment`, за которым должно последовать имя фрагмента.
* Укажите тип, на котором определён фрагмент. Для этого используйте ключевое слово `on`.
* В фигурных скобках перечислите поля, которые должны быть включены во фрагмент.

Пример создания фрагмента:

```graphql
fragment UserBasicInfo on User {
  id
  name
  email
}
```

Чтобы использовать фрагмент в запросе, добавьте три точки … перед его именем:

```graphql
query {
  user(id: "123") {
    ...UserBasicInfo
    age
  }
}
# Используем поля из фрагмента UserBasicInfo и поле age.
```

Ответ от сервера:

```json
{
  "data": {
    "user": {
      "id": "123",
      "name": "Иван Петров",
      "email": "ivanpetrov@example.com",
      "age": 30
    }
  }
}
// Мы получили поля id, name и email из фрагмента UserBasicInfo, а также дополнительное поле age.
```

#### Псевдонимы (aliases)

Псевдонимы позволяют в одном запросе получить данные для нескольких пользователей, присваивая уникальные имена каждому результату. Это упрощает структуру запросов, улучшает читаемость ответов и помогает избежать конфликтов имён при запросе одинаковых полей для разных объектов.

Порядок создания псевдонима:

* Укажите желаемый псевдоним перед полем или запросом, после чего поставьте двоеточие.
* После двоеточия напишите оригинальное имя поля или запроса.
* При необходимости используйте фигурные скобки для группировки полей.

Пример создания псевдонимов:

```graphql
{
  userInfo: user(id: "123") {
    fullName: name
    contactEmail: email
  }
}
# userInfo -- псевдоним для запроса user.
# fullName -- для поля name.
# contactEmail -- для поля email.
```

Ответ сервера на запрос с псевдонимами:

```json
{
  "data": {
    "userInfo": {
      "fullName": "Иван Петров",
      "contactEmail": "ivanpetrov@example.com"
    }
  }
}
```

#### Директивы (directives)

Директивы — это инструменты, управляющие выполнением запроса. Они позволяют гибко включать или исключать поля в зависимости от условий.

В GraphQL есть несколько основных типов директив:

* `@include` — включает поле в результат, если условие истинно.
* `@skip` — пропускает поле, если условие истинно.
* `@deprecated` — помечает поле как устаревшее.
* `@specifiedBy` — указывает URL спецификации для пользовательского скалярного типа (нестандартного для GraphQL типа данных, созданного пользователем).

Помимо этого, GraphQL позволяет создавать пользовательские директивы для специфических нужд конкретного API.

Порядок создания пользовательской директивы:

* Определите директиву в схеме GraphQL, используя ключевое слово `directive`.
* Укажите имя директивы начиная с символа `@`.
* Если нужно, определите аргументы директивы.
* Укажите область применения директивы: поля (`FIELD_DEFINITION`), фрагменты (`FRAGMENT_DEFINITION`), операции (`QUERY`, `MUTATION`, `SUBSCRIPTION`) или другие элементы схемы (например, `SCHEMA`, `SCALAR`, `OBJECT`, `INTERFACE`, `UNION`, `ENUM`, `INPUT_OBJECT`).

Создадим директиву `@auth`, применимую к определениям полей и объектов. Эта директива принимает необязательный аргумент `requires` типа `Role`, который определяет возможные роли пользователей в системе. Если аргумент не указан, его значение по умолчанию устанавливается как `USER`. Такая директива позволит нам настраивать уровни доступа к различным полям или объектам в схеме GraphQL:

```graphql
directive @auth(requires: Role = USER) on FIELD_DEFINITION | OBJECT

enum Role {
  ADMIN
  USER
  GUEST
}
```

Применим нашу директиву, добавив `@auth` к полю `email`. После этого только пользователи с ролью `ADMIN` смогут видеть email-адреса других пользователей:

```graphql
type User {
  id: ID!
  name: String!
  email: String! @auth(requires: ADMIN)
}
```

#### Схема

GraphQL предлагает единую точку входа, один endpoint, через который вы можете запрашивать любые нужные вам данные, при условии, что они связаны в *схеме*.

**Схема** — это SDL, *schema definition language*, язык, который может описывать данные и возвращать их сервису, определенным образом проставляя связи между этими данными.

Для примера представьте сервис книжного магазина. Он предоставляет информацию о том, какие в базе есть книги, названия этих книг, какие есть авторы и информацию по ним. Можно посмотреть имя автора и, например, узнать, какие книги он написал.

Чтобы описать его в SDL, достаточно просто несколько строчек:

```graphql
type Query {
  books: [Book]
  authors: [Author]
}
type Book {
  title: String
  author: Author
}
type Author {
  name: String
  books: [Book]
}
```

Ключевое слово `query` говорит, что сервис может вернуть информацию по книгам, и нам возвращается массив с типом `Book`. Или может вернуть информацию по авторам, и нам будет возвращаться массив с типом `Author`. При этом в типе `Book` у нас есть название книги и ссылка на автора. А у типа `Author` есть его имя и список его книг, которые он написал.

Все, таким образом мы только что определили, какие данные мы можем запрашивать через GraphQL Endpoint, и как они связаны между собой.

Давайте посмотрим, как будет выглядеть запрос на такой книжный сервис:

```graphql
query {
  books {
    title
  }
  authors {
    name
  }
}
```

Есть три способа узнать, кокой формат запросов поддерживает GraphQL API:

1. Посмотрите саму **схему** (SDL), в ней сразу видно, что можно запросить у сервиса, какой тип и прочее.

2. Для любителей документоориентированного формата. У GraphQL есть плагины, которые позволяют ему с помощью схемы нарисовать на самом деле очень подробную **документацию**, близкую к swagger, в которой и будет вся исчерпывающая информацию.

3. Механизм **автофетча** (auto fetch), который реализован, например, в Postman.

#### CRUD в GraphQL

Так как GraphQL это не протокол, а язык, все запросы — это POST (т.к. нам важно, чтобы было тело в запросе).

Операции CRUD в GraphQL реализованы с помощью двух типов запросов: *query* и *mutation*

|||
|-|-|
|Create|Mutation|
|Read|Query|
|Update|Mutation|
|Delete|Mutation|

Для всех запросов на чтение в GraphQL нужно указывать слово `query`, служебный параметр. А если вы хотите что-то поменять (создание, обновление, удаление), вы должны указывать ключевое слово `mutation`. Это позволяет комбинировать в одном запросе сразу операции создания и чтения.

## WebSocket

**WebSocket** - протокол связи поверх TCP-соединения, предназначенный для обмена сообщениями между клиентом и сервером, использующий постоянное соединение.

WebSocket, помогает системам, которые хотят работать в режиме реального времени. Если есть какие-то данные, которые нужно отправить клиенту, сервер знает, что есть вот сокет соединения, их можно туда отправить и они успешно туда улетят. Клиент же спокойно работает и знает, что если прилетят данные через конкретный сокет, надо будет с ними выполнить операции. В общем, все спокойно работают и, если надо, обмениваются сообщениями, никто никого не ждет.

### Установка соединения

Процесс работы по Websocket выглядит так. Сперва посылается обычный HTTP-запрос на установку постоянного соединения, у запроса должно быть два очень важных технических заголовка:

* Первый – это connection upgrade. Тут мы говорим серверу, что готовы перенести наши отношения на новый уровень, более постоянный и вообще хороший.
* Второй — мы указываем, что мы хотим сделать апгрейд на WebSocket.

```http
GET /chat HTTP/1.1
Host: server.example.com
Upgrade: websocket
Connection: Upgrade
```

Если сервер может, он отвечает — хорошо, это будет код ответа 101, и служебные заголовки смены протокола.

```http
HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: HSmrc0sMl YUkAGmm50PpG2HaGWk=
Sec-WebSocket-Protocol: chat'
```

Укажет, на какой протокол поменялся, какой сокет будет использоваться и прочую информацию.

После этого между клиентом и сервером устанавливается тип соединения connection, они начинают общаться - обмениваться сообщениями.

```http
HTTP Connect is upgrading to WS
TYPE: Connection
```

Если вдруг кто-то там отвалился или закрыл соединение, тип коннекта меняется на дисконнект.

```http
WS connection close
TYPE: Disconnect
```

У WebSocket-протокола есть специальный механизм пинг-понгов — он всегда может уточнить, “слышно” ли его и стоит ли продолжать работу. Если вдруг кто-то не ответил, происходит несколько попыток (с увеличивающимся таймаутом), и после этого соединение считается закрытым.

### WebSocket коды ответов

У WebSocket есть свои коды ответов, которые все так или иначе завязаны именно на закрытие соединения.

|Status Code|Meaning|
|--|--|
|1000|Normal Closure|
|1001|Going Away|
|1002|Protocol error|
|1003|Unsupported Data|
|1004|Reserved|
|1005|No Status Rcvd|
|1006|Abnormal Closure|
|1007|Invalid frame payload data|
|1008|Policy Violation|
|1009|Message Too Big|
|1010|Mandatory Ext.|
|1011|Internal Error|
|1012|Service Restart|
|1013|Try Again Later|
|1014|The server was acting as a gateway or proxy and received an invalid response from the upstream server. This is similar to 502 HTTP Status Code.|
|1015|TLS handshake|
|1016-2999|Unassigned|
|3000|Unauthorized|
|3001-3002|Unassigned|
|3003|Forbidden|
|3004-3999|Unassigned|
|4000-4999|Reserved for Private Use|

### Тестирование WebSocket

В **DevTools** запросы по протоколу WebSocket можно найти на вкладке *Network* - в фильтре *WS*. В свойствах запроса есть в том числе вкладка Messages, в которой можно увидеть сообщения, которыми обменивались клиент с сервером.

В **Postman** есть специальный вид запроса *WebSocket*. Сообщения можно сохранять.

В **Python** для работы с WebSocket используется библиотека *websockets*. С помощью этой библиотеки можно как создать WebSocket сервер, так и отправлять сообщения по протоколу WebSocket от имени клиента.

Также для работы с WebSocket используется утилита командной строки **wscat**.  
`wscat` написана на Node.js, устанавливается как npm-пакет.

`wscat -l 8765` - создать WebSocket на порту 8765 - по сути создает WebSocket сервер, позволяющий получать и отправлять сообщения по протоколу WebSocket.

`wscat -c ws://127.0.0.1:8765/status` - подключиться к локальному WebSocket серверу на порту 8765 по пути '/status'

## gRPC

**RPC** — удалённый вызов процедур (иногда вызов удалённых процедур; от англ. *remote procedure call*) — класс технологий, позволяющих программам вызывать функции или процедуры других программ, делая это так, как если бы они находились в одном адресном пространстве.

**gRPC** - гугловая реализация RPC.

Разберем это все на примере.

Допустим, что вы — программист и сидите в монолитной репе. У вас одно приложение. Сам проект открыт в IDE и вы в нем работаете. В репе реализован определенный класс (например, на Kotlin), у которого есть метод, возвращающий вам данные по пользователю.

```kotlin
fun getUserInfo(id: String) {
   return //some data
}
```

Теперь в другом месте проекта, в другом классе, вы хотите вызвать этот метод, чтобы поработать с данными о пользователе. Что вы тогда делаете? Импортируете класс и просто делаете обычный вызов метода.

```kotlin
var userData = getUserInfo("userID")
// Continue work with data
```

Дальше приходит новый вызов - микросервисная архитектура, которая предлагает всё разделить и вынести всё, что мы делаем с пользователями, в отдельный сервис.

Теперь наши условные сервисы разделило сетевое взаимодействие, вот как на картинке.

![Микросервисы](https://github.com/ilsinyakov/QA_Theory/blob/main/Pictures/microservice_grpc.png?raw=true)

Есть сервис A, который хочет данные от пользователя. Есть сервис B, у которого есть публичный API, через который эти данные можно получить.

Что делать сервису A?

Ему нужно сделать get-запрос на endpoint, который предоставит сервис B, затем получить обратно HTTP-ответ (там будет JSON), извлечь данные и работать с ними.

Что предлагает gRPC?

А предлагает он вот что — пусть сервис B заведет некий протофайл с расширением `.proto`, в котором опишет те методы и функции, которые можно будет вызывать у него всем остальным. Получается такой аналог API, в котором сервис подтверждает, что может работать с вызовами этих функций с определенными параметрами и возвращать определенные данные. При этом внутри себя он на самом деле реализует все эти функции. И на своем уровне поднимает RPC-службу.

![gRPC](https://github.com/ilsinyakov/QA_Theory/blob/main/Pictures/gRPC.png?raw=true)

Эта служба обрабатывает все запросы, которые будут приходить.

Окей, сервисом В разобрались. Что теперь делать на уровне сервиса А, чтобы получить данные о пользователе?

Мы определенным образом забираем себе модели, описанные в protofile сервиса В. Например, подключаем в gradle через dependency этот пакет, в котором есть все описанные модели. И дальше реализуем над ними обёртку со своей логикой и вызовом методов сервиса В.

![A](https://github.com/ilsinyakov/QA_Theory/blob/main/Pictures/protoA.png?raw=true)

Теперь мы начинаем писать код, опираясь именно на вызовы нашей обёртки, которая лежит у нас здесь в проекте, это уже удобней. При этом, когда мы будем вызывать свои методы, они внутри себя на самом деле будут обращаться к методам сервиса B. Они пойдут к нему в RPC-службу и скажут, что хотят с ним работать. Сервис B ответит, что готов с удовольствием нам помочь.

![A-B](https://github.com/ilsinyakov/QA_Theory/blob/main/Pictures/A-B.png?raw=true)

При этом стоит заметить, что в gRPC все запросы используют **Protocol  Buffers** — это специальный бинарный протокол сериализации данных, разработанный в компании Google. То есть сервис А предоставит сервису В свой запрос в бинарном виде. Сервис В поймёт, какой метод у него вызывают, выполнит его и вернет результат назад. Причем ответ будет также проходить через RPC службу и будет в двоичном виде. Сервис А уже получит такой ответ и продолжит работать дальше, как ни в чем не бывало.

Если чуть тщательнее порыться под капотом, получится такая схема.

![gRPC](https://github.com/ilsinyakov/QA_Theory/blob/main/Pictures/gRPC_2.png?raw=true)

1. На клиентской машине мы вызываем метод. Например, нам нужна информация о пользователях, и вызываем его так, как будто находимся на самом деле в сервисе B.
2. При этом мы делаем обращение именно в реализованную ранее обёртку.
3. Затем уже подрубаются специальные библиотеки, которые наш запрос транслируют определенным образом в двоичный запрос. Проводят сериализацию, передают его уже дальше в RPC-службу, и далее через protocol buffers всё попадает на сервер B.
4. Он в свою очередь обратно десериализует эту двоичную последовательность в виде имени процедуры, параметров и значения. Выполняет ее, получает данные, а затем обратно проделывает всю эту трансформацию.
5. Данные запаковывает в бинарную последовательность и отправляет ее обратно по сети.
6. Мы на стороне клиента ее получаем, распаковываем данные, возвращаем обратно нашей программе и продолжаем работать дальше.

### Преимущества gRPC

#### Скорость

Это по сути главная киллер-фича. Сам Google заявлял, что прирост по скорости будет в 3—10 раз, энтузиасты же, которые все это протестировали, вывели свою цифру — в 7 раз. В 7 раз быстрее происходит сериализация данных при работе с этим бинарным форматом, чем при работе с JSON.

Поэтому, если ваши сервисы, что называется, gRPC-ориентированы, то есть заточены на очень быстрые взаимодействия друг с другом, время отклика максимально быстрое, при этом очень маленькие короткие сообщения — вы получаете колоссальный прирост по производительности и эффективности потребления ресурсов. Это очень важный кейс.

#### Документирование

Помните ситуацию при работе с REST HTTP, когда ребята сделали endpoint, а документацию забыли? А тестировать-то как-то надо. Поэтому в этой случае документацией станет сам разработчик.

В gRPC подобное не прокатит — здесь вы сначала реализовываете именно контракт в протофайле. То есть вы как бы реализуете сначала документацию, а потом — логику.

#### Обратная совместимость

Здесь очень сильная обратная совместимость за счет нежесткой привязки к имени поля. Двоичный протокол не знает, что такое строки, он знает, что такое числа. Определенный способ записи и организации данных в протофайле исключает ситуацию, когда разработчик поменял имя переменной, и у клиента что-то отлетело.

### Статус-коды gRPC

| Code | Number | Description |
|------------------|--------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| OK | 0 | Not an error; returned on success. |
| CANCELLED | 1 | The operation was cancelled, typically by the caller. |
| UNKNOWN | 2 | Unknown error. For example, this error may be returned when a `Status` value received from another address space belongs to an error space that is not known in this address space. Also errors raised by APIs that do not return enough error information may be converted to this error. |
| INVALID_ARGUMENT | 3 | The client specified an invalid argument. Note that this differs from `FAILED_PRECONDITION`. `INVALID_ARGUMENT` indicates arguments that are problematic regardless of the state of the system (e.g., a malformed file name). |
| DEADLINE_EXCEEDED | 4 | The deadline expired before the operation could complete. For operations that change the state of the system, this error may be returned even if the operation has completed successfully. For example, a successful response from a server could have been delayed long |
| NOT_FOUND | 5 | Some requested entity (e.g., file or directory) was not found. Note to server developers: if a request is denied for an entire class of users, such as gradual feature rollout or undocumented allowlist, `NOT_FOUND` may be used. If a request is denied for some users within a class of users, such as user-based access control, `PERMISSION_DENIED` must be used. |
| ALREADY_EXISTS | 6 | The entity that a client attempted to create (e.g., file or directory) already exists. |
| PERMISSION_DENIED | 7 | The caller does not have permission to execute the specified operation. `PERMISSION_DENIED` must not be used for rejections caused by exhausting some resource (use `RESOURCE_EXHAUSTED` instead for those errors). `PERMISSION_DENIED` must not be used if the caller can not be identified (use `UNAUTHENTICATED` instead for those errors). This error code does not imply the request is valid or the requested entity exists or satisfies other pre-conditions. |
| RESOURCE_EXHAUSTED | 8 | Some resource has been exhausted, perhaps a per-user quota, or perhaps the entire file system is out of space. |
| FAILED_PRECONDITION | 9 | The operation was rejected because the system is not in a state required for the operation's execution. For example, the directory to be deleted is non-empty, an rmdir operation is applied to a non-directory, etc. Service implementors can use the following guidelines to decide between `FAILED_PRECONDITION`, `ABORTED`, and `UNAVAILABLE`: (a) Use `UNAVAILABLE` if the client can retry just the failing call. (b) Use `ABORTED` if the client should retry at a higher level (e.g., when a client-specified test-and-set fails, indicating the client should restart a read-modify-write sequence). (c) Use `FAILED_PRECONDITION` if the client should not retry until the system state has been explicitly fixed. E.g., if an "rmdir" fails because the directory is non-empty, `FAILED_PRECONDITION` should be returned since the client should not retry unless the files are deleted from the directory. |
| ABORTED | 10 | The operation was aborted, typically due to a concurrency issue such as a sequencer check failure or transaction abort. See the guidelines above for deciding between `FAILED_PRECONDITION`, `ABORTED`, and `UNAVAILABLE`. |
| OUT_OF_RANGE | 11 | The operation was attempted past the valid range. E.g., seeking or reading past end-of-file. Unlike `INVALID_ARGUMENT`, this error indicates a problem that may be fixed if the system state changes. For example, a 32-bit file system will generate `INVALID_ARGUMENT` if asked to read at an offset that is not in the range [0,2^32-1], but it will generate `OUT_OF_RANGE` if asked to read from an offset past the current file size. There is a fair bit of overlap between `FAILED_PRECONDITION` and `OUT_OF_RANGE`. We recommend using `OUT_OF_RANGE` (the more specific error) when it applies so that callers who are iterating through a space can easily look for an `OUT_OF_RANGE` error to detect when they are done. |
| UNIMPLEMENTED | 12 | The operation is not implemented or is not supported/enabled in this service. |
| INTERNAL | 13 | Internal errors. This means that some invariants expected by the underlying system have been broken. This error code is reserved for serious errors. |
| UNAVAILABLE | 14 | The service is currently unavailable. This is most likely a transient condition, which can be corrected by retrying with a backoff. Note that it is not always safe to retry non-idempotent operations. |
| DATA_LOSS | 15 | Unrecoverable data loss or corruption. |
| UNAUTHENTICATED | 16 | The request does not have valid authentication credentials for the operation. |

### Тестирование gRPC

Так как это удаленный вызов процедур, то проверка логики работы самих процедур отлично покрывается юнит-тестами и нет необходимости тестировать их работу через внешние вызовы. К сожалению, в практике встречаются разные проекты, и могут быть те, где проверки юнит-тестами заменяют на внешние вызовы процедур для проверки их логики работы. В таком случае к списку ниже придется добавить проверку логики работы самих вызываемых процедур.

Окей, если логика работы покрыта юнит-тестами, то на что еще мне как тестировщику стоит обратить внимание?

1. Прежде всего, не забываем, что gRPC – это удаленный вызов процедур. Поэтому мы с вами должны проверить, что наша процедура с определенными параметрами может быть вызвана удаленно. Потому что, возможно, она уже и не работает через удаленный вызов.
2. Далее надо проверить, доступна ли процедура извне. Закрытие авторизацией никто не отменял.
3. Круто, если будет проверен формат данных, который возвращается. В примерах выше возвращался JSON. Его, например, можно провалидировать по схеме.
4. Ну и коды ответов. Это уже на ваше усмотрение, согласно бизнес-потребности.

Подведем итог, что надо для тестирования gRPC-сервиса:

1. Импортим .proto файл
2. Проверяем доступность удаленного вызова процедур
3. Проверяем доступность методов закрытых авторизацией
4. Проверяем возвращаемые данные и ошибки (при необходимости, т.к. может быть покрыто юнит-тестами)
5. Проверяем е2е-сценарии
6. Проверяем коды ответов

#### gRPCurl

**gRPCurl** - консольная утилита, с помощью которой можно работать с gRPC API.

[Офсайт](https://grpcurl.com/)

[Github](https://github.com/fullstorydev/grpcurl/releases)

Для установки нужно скачать и установить пакет с Github. Например, для Ubuntu:

```bash
curl -L -O "https://github.com/fullstorydev/grpcurl/releases/download/v1.9.3/grpcurl_1.9.3_linux_amd64.deb"
```

```bash
sudo apt install ./grpcurl_1.9.3_linux_amd64.deb
```

___
Пример запроса:

```bash
grpcurl -plaintext -d '{"name": "World"}' localhost:50051 example.ExampleService/SayHello
```

`-plaintext` - чтобы можно было работать без шифрования  
`-d '{"name": "World"}'` - тело запроса  
`localhost:50051` - IP и порт сервера  
`example.ExampleService/SayHello`:  
&nbsp;&nbsp;`example` - пространство имен (`package` в .proto файле)  
&nbsp;&nbsp;`ExampleService` - сервис (`service` в .proto файле)  
&nbsp;&nbsp;`SayHello` - метод (`rpc` в .proto файле)
___

`grpcurl -plaintext localhost:50051 list` - получить список доступных сервисов (на сервере должен быть настроен *server reflection* - получение информации о сервисах без .proto файла).

`grpcurl -plaintext localhost:50051 list example.ExampleService` - получить список доступных методов сервиса (с *server reflection*).

`grpcurl -plaintext -import-path ./proto -proto example.proto -d '{"name": "World"}' localhost:50051 example.ExampleService/SayHello` - запрос с использованием .proto файла (например, если *server reflection* не настроен)

`grpcurl -plaintext -import-path ./proto -proto example.proto localhost:50051 describe example.ExampleService.SayHello` - получить описание метода `SayHello` (используется .proto файл)
