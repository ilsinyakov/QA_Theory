# Non-REST API: GraphQL, WebSocket, gRPC

## Содержание

## GraphQL

**GraphQL** — это специализированный *язык запросов* для работы с данными, разработанный компанией «Фейсбук» в 2012 году. Он решил проблему производительности мобильных приложений, которые часто получали от сервера избыточные или неполные данные.

До GraphQL разработчики в основном использовали REST API для взаимодействия с сервером. В REST-архитектуре у каждого ресурса есть уникальный URL-адрес, а клиенты общаются с сервером через HTTP-методы: GET, POST, PUT, DELETE и другие.

Допустим, мы хотим получить информацию о постах и подписчиках пользователя. С REST API нам придётся отправить несколько запросов, что приведёт к получению избыточных данных и увеличению нагрузки на сеть.

Пример запроса:

```http
GET /api/users/123
GET /api/users/123/posts
GET /api/users/123/followers
```

Ниже пример ответа с данными, которые мы не запрашивали. Сервер прислал дату рождения, адрес пользователя и полное содержание постов:

```json
// GET /api/users/123
{
  "id": "123",
  "name": "Иван Петров",
  "email": "ivan@example.com",
  "birthDate": "1990-01-01", // ? Избыточные данные
  "address": "ул. Пушкина, д. 10, г. Москва, Россия" // ? Избыточные данные
}

// GET /api/users/123/posts
[
  { "id": "1", "title": "Мой первый пост", "content": "Здесь содержание первого поста..." }, // ? Избыточные данные (content)
  { "id": "2", "title": "Второй пост", "content": "А это содержание второго поста..." } // ? Избыточные данные (content)
]

// GET /api/users/123/followers
[
  { "id": "456", "name": "Мария Сидорова" },
  { "id": "789", "name": "Алексей Иванов" }
]
```

Таким образом У REST API есть два больших минуса:

* **overfetching** - это ситуация, при которой endpoint возвращает в ответе огромное количество информации, которая вам может быть не нужна. Допустим, вам нужно было какое-то одно значение свойства, а сервис вернул вам в ответе всё, что надо и не надо.

* **underfetching** - обратная ситуация, когда endpoint возвращает недостаточное количество информации, и вам приходится делать несколько запросов, чтобы собрать полную картину с данными. И тем самым вы увеличите нагрузку на сервис.

А вот запрос, составленный с помощью GraphQL:

```graphql
query {
  user(id: "123") {
    name
    email
    posts {
      title
    }
    followers {
      name
    }
  }
}
```

Ответ от сервера:

```json
{
  "data": {
    "user": {
      "name": "Иван Петров",
      "email": "ivan@example.com",
      "posts": [
        { "title": "Мой первый пост" },
        { "title": "Второй пост" }
      ],
      "followers": [
        { "name": "Мария Сидорова" },
        { "name": "Алексей Иванов" }
      ]
    }
  }
}
```

### Зачем нужен GraphQL

GraphQL повышает производительность приложений, сокращает количество запросов, уменьшает объем передаваемых данных.

Помимо оптимизации запросов, GraphQL решает и другие важные задачи:

* **Упрощает интеграцию** различных систем и микросервисов, создавая единый API для доступа к разным источникам данных. Например, можно объединить данные из системы управления товарами, платёжной платформы и службы доставки.
* **Ускоряет процесс разработки**, позволяя адаптировать запросы под клиента без изменения серверной части. Например, мобильное приложение может запрашивать базовую информацию о пользователе, а веб-версия — расширенные данные. Это позволяет использовать один API для разных клиентов без изменений на сервере.
* **Упрощает работу с API**. GraphQL использует единую точку доступа для всех запросов, что позволяет мгновенно интегрировать новую информацию в систему. Например, если к товарам в интернет-магазине добавить новую характеристику, то она сразу станет доступной для всех клиентских приложений — для этого не придётся обновлять API или создавать новые точки доступа.
* **Обеспечивает простое обновление API**. Разработчики могут добавлять новые поля в схему GraphQL, не нарушая работу существующих клиентов. Это позволяет постепенно расширять функциональность API без создания новых версий или нарушения обратной совместимости. Например, если добавить поле «рейтинг» для товара, существующие приложения продолжат работать без изменений, а новые смогут использовать эту дополнительную информацию.

### Преимущества и недостатки GraphQL

#### Преимущества

* **Гибкость запросов**. В отличие от REST и SOAP, GraphQL позволяет клиентам запрашивать только необходимые данные, что уменьшает объём передаваемой информации и количество запросов. Например, с помощью GraphQL можно одним запросом получить профиль пользователя, его посты и список друзей. В случае с REST для этого пришлось бы выполнить несколько отдельных запросов.
* **Типизация данных**. В отличие от REST, GraphQL обладает встроенной строгой системой типов, что упрощает валидацию данных и снижает вероятность ошибок при разработке. Например, если в схеме GraphQL поле age определено как целое число, сервер автоматически отклонит запрос с некорректным значением — строкой тридцать вместо числа 30.
* **Версионирование API**. В отличие от REST и SOAP, GraphQL позволяет добавлять новые поля и типы без нарушения работы существующих запросов. Например, вы можете добавить поле phoneNumber к типу User в схеме GraphQL. После изменения существующие клиенты продолжат работать как прежде, а новые смогут использовать добавленное поле без создания новой версии API.
* **Производительность в сложных сценариях**. По сравнению с gRPC, GraphQL эффективнее обрабатывает комплексные запросы, когда необходимо получить связанную информацию из разных источников. Например, в e-commerce-приложении GraphQL может одним запросом извлечь детали товара, информацию о его наличии, отзывы и скидки. При использовании gRPC для получения той же информации потребовалось бы несколько вызовов.

#### Недостатки

Как и любая технология, GraphQL имеет свои недостатки, и один из ключевых — **сложность кэширования**. В REST кэширование настраивается с помощью стандартных HTTP-заголовков, а GraphQL не поддерживает эту функцию напрямую. Для решения этой проблемы необходимо использовать дополнительные библиотеки или разрабатывать собственную логику кэширования. Из-за этого GraphQL часто комбинируют с другими технологиями. Например, если у вас уже есть REST API, можно постепенно внедрять GraphQL, сохраняя преимущества обоих подходов.

Также минусом GraphQL является невозможность запросить **всю информацию** об объекте, нужно обязательно **перечислить** все запрашиваемые свойства в запросе.

### Как работает GraphQL

GraphQL функционирует по принципу «запрос — ответ» между клиентом и сервером:

* На сервере создаётся схема, описывающая все доступные типы данных, поля и операции, которые можно выполнить через API.
* Клиент формирует запрос, точно указывая необходимые данные.
* Клиент отправляет запрос на сервер через HTTP-метод POST.
* Сервер анализирует запрос, проверяет его соответствие схеме и выполняет нужные операции для получения данных.
* Сервер отправляет клиенту ответ, содержащий только запрашиваемую информацию.
* Клиент получает данные и использует их для обновления интерфейса или других операций.

Для построения запросов GraphQL используются шесть основных компонентов:

* поля (fields)
* аргументы (arguments)
* фрагменты (fragments)
* псевдонимы (aliases)
* переменные (variables)
* директивы (directives)

#### Поля (fields)

Поля в GraphQL — это запрашиваемые данные. Они определяют, какую именно информацию клиент хочет получить от сервера.

Порядок заполнения полей в GraphQL-запросе:

* Укажите нужные поля внутри фигурных скобок после имени запроса.
* Вложенные поля заключайте в фигурные скобки.
* Разделяйте поля переносом строки или пробелом.
* Не ставьте запятые между полями.

Пример:

```graphql
{
  user {
    name
    email
    posts {
      title
      content
    }
  }
}
```

Запросим у сервера имя и email пользователя:

```graphql
{
  user {
    name
    email
  }
}
```

Ответ сервера:

```json
{
  "data": {
    "user": {
      "name": "Иван Петров",
      "email": "ivanpetrov@example.com"
    }
  }
}
```

#### Аргументы (arguments)

Аргументы помогают уточнить запрос и получить конкретные данные. С их помощью вы можете фильтровать, сортировать или ограничивать результаты запроса.

Порядок добавления аргумента в GraphQL-запрос:

* Укажите аргумент в круглых скобках после имени поля.
* Используйте формат имя: значение для передачи аргумента.
* Разделяйте несколько аргументов запятыми.
* Заключайте значения строк в кавычки, а числа указывайте без кавычек.

Пример запроса с несколькими аргументами:

```graphql
{
  users(first: 5, status: "active") {
    name
    email
  }
}
# Ограничиваем результат пятью активными пользователями.
```

Ответ сервера:

```json
{
  "data": {
    "users": [
      {
        "name": "Иван Петров",
        "email": "ivanpetrov@example.com"
      },
      {
        "name": "Мария Сидорова",
        "email": "mariasidorova@example.com"
      },
      {
        "name": "Алексей Иванов",
        "email": "alexeyivanov@example.com"
      },
      {
        "name": "Елена Смирнова",
        "email": "elenasmirnova@example.com"
      },
      {
        "name": "Павел Козлов",
        "email": "pavelkozlov@example.com"
      }
    ]
  }
}
```

#### Переменные (variables)

Переменные в GraphQL повышают гибкость запросов — они позволяют использовать динамические параметры вместо фиксированных значений. Это удобно, когда нужно выполнить один запрос с разными значениями.

Порядок использования переменной:

* Объявите её в начале запроса, используя знак `$` перед именем переменной.
* Укажите тип переменной после двоеточия. Например: `String`, `Int`, `Boolean`.
* Добавьте восклицательный знак `!` после типа, если переменная обязательна.
* В самом запросе используйте переменную, указывая её имя со знаком `$`.

Для примера объявим переменную типа `ID`, обязательную для выполнения запроса:

```graphql
query getUser($id: ID!) {
  user(id: $id) {
    name
    email
  }
}
```

После объявления переменной мы должны отправить запрос на сервер, передав значение переменной `$id` в отдельном объекте JSON:

```json
{
  "id": "123"
}
// "123" — это ID пользователя, информацию о котором мы хотим получить.
```

Ответ сервера:

```json
{
  "data": {
    "user": {
      "name": "Иван Петров",
      "email": "ivanpetrov@example.com"
    }
  }
}
```

#### Фрагменты (fragments)

Фрагменты оптимизируют код, группируя часто используемые поля в единый блок. Это упрощает структуру запросов и облегчает их поддержку.

Порядок создания фрагмента:

* Используйте ключевое слово `fragment`, за которым должно последовать имя фрагмента.
* Укажите тип, на котором определён фрагмент. Для этого используйте ключевое слово `on`.
* В фигурных скобках перечислите поля, которые должны быть включены во фрагмент.

Пример создания фрагмента:

```graphql
fragment UserBasicInfo on User {
  id
  name
  email
}
```

Чтобы использовать фрагмент в запросе, добавьте три точки … перед его именем:

```graphql
query {
  user(id: "123") {
    ...UserBasicInfo
    age
  }
}
# Используем поля из фрагмента UserBasicInfo и поле age.
```

Ответ от сервера:

```json
{
  "data": {
    "user": {
      "id": "123",
      "name": "Иван Петров",
      "email": "ivanpetrov@example.com",
      "age": 30
    }
  }
}
// Мы получили поля id, name и email из фрагмента UserBasicInfo, а также дополнительное поле age.
```

#### Псевдонимы (aliases)

Псевдонимы позволяют в одном запросе получить данные для нескольких пользователей, присваивая уникальные имена каждому результату. Это упрощает структуру запросов, улучшает читаемость ответов и помогает избежать конфликтов имён при запросе одинаковых полей для разных объектов.

Порядок создания псевдонима:

* Укажите желаемый псевдоним перед полем или запросом, после чего поставьте двоеточие.
* После двоеточия напишите оригинальное имя поля или запроса.
* При необходимости используйте фигурные скобки для группировки полей.

Пример создания псевдонимов:

```graphql
{
  userInfo: user(id: "123") {
    fullName: name
    contactEmail: email
  }
}
# userInfo -- псевдоним для запроса user.
# fullName -- для поля name.
# contactEmail -- для поля email.
```

Ответ сервера на запрос с псевдонимами:

```json
{
  "data": {
    "userInfo": {
      "fullName": "Иван Петров",
      "contactEmail": "ivanpetrov@example.com"
    }
  }
}
```

#### Директивы (directives)

Директивы — это инструменты, управляющие выполнением запроса. Они позволяют гибко включать или исключать поля в зависимости от условий.

В GraphQL есть несколько основных типов директив:

* `@include` — включает поле в результат, если условие истинно.
* `@skip` — пропускает поле, если условие истинно.
* `@deprecated` — помечает поле как устаревшее.
* `@specifiedBy` — указывает URL спецификации для пользовательского скалярного типа (нестандартного для GraphQL типа данных, созданного пользователем).

Помимо этого, GraphQL позволяет создавать пользовательские директивы для специфических нужд конкретного API.

Порядок создания пользовательской директивы:

* Определите директиву в схеме GraphQL, используя ключевое слово `directive`.
* Укажите имя директивы начиная с символа `@`.
* Если нужно, определите аргументы директивы.
* Укажите область применения директивы: поля (`FIELD_DEFINITION`), фрагменты (`FRAGMENT_DEFINITION`), операции (`QUERY`, `MUTATION`, `SUBSCRIPTION`) или другие элементы схемы (например, `SCHEMA`, `SCALAR`, `OBJECT`, `INTERFACE`, `UNION`, `ENUM`, `INPUT_OBJECT`).

Создадим директиву `@auth`, применимую к определениям полей и объектов. Эта директива принимает необязательный аргумент `requires` типа `Role`, который определяет возможные роли пользователей в системе. Если аргумент не указан, его значение по умолчанию устанавливается как `USER`. Такая директива позволит нам настраивать уровни доступа к различным полям или объектам в схеме GraphQL:

```graphql
directive @auth(requires: Role = USER) on FIELD_DEFINITION | OBJECT

enum Role {
  ADMIN
  USER
  GUEST
}
```

Применим нашу директиву, добавив `@auth` к полю `email`. После этого только пользователи с ролью `ADMIN` смогут видеть email-адреса других пользователей:

```graphql
type User {
  id: ID!
  name: String!
  email: String! @auth(requires: ADMIN)
}
```

#### Схема

GraphQL предлагает единую точку входа, один endpoint, через который вы можете запрашивать любые нужные вам данные, при условии, что они связаны в *схеме*.

**Схема** — это SDL, *schema definition language*, язык, который может описывать данные и возвращать их сервису, определенным образом проставляя связи между этими данными.

Для примера представьте сервис книжного магазина. Он предоставляет информацию о том, какие в базе есть книги, названия этих книг, какие есть авторы и информацию по ним. Можно посмотреть имя автора и, например, узнать, какие книги он написал.

Чтобы описать его в SDL, достаточно просто несколько строчек:

```graphql
type Query {
  books: [Book]
  authors: [Author]
}
type Book {
  title: String
  author: Author
}
type Author {
  name: String
  books: [Book]
}
```

Ключевое слово `query` говорит, что сервис может вернуть информацию по книгам, и нам возвращается массив с типом `Book`. Или может вернуть информацию по авторам, и нам будет возвращаться массив с типом `Author`. При этом в типе `Book` у нас есть название книги и ссылка на автора. А у типа `Author` есть его имя и список его книг, которые он написал.

Все, таким образом мы только что определили, какие данные мы можем запрашивать через GraphQL Endpoint, и как они связаны между собой.

Давайте посмотрим, как будет выглядеть запрос на такой книжный сервис:

```graphql
query {
  books {
    title
  }
  authors {
    name
  }
}
```

Есть три способа узнать, кокой формат запросов поддерживает GraphQL API:

1. Посмотрите саму **схему** (SDL), в ней сразу видно, что можно запросить у сервиса, какой тип и прочее.

2. Для любителей документоориентированного формата. У GraphQL есть плагины, которые позволяют ему с помощью схемы нарисовать на самом деле очень подробную **документацию**, близкую к swagger, в которой и будет вся исчерпывающая информацию.

3. Механизм **автофетча** (auto fetch), который реализован, например, в Postman.

#### CRUD в GraphQL

Так как GraphQL это не протокол, а язык, все запросы — это POST (т.к. нам важно, чтобы было тело в запросе).

Операции CRUD в GraphQL реализованы с помощью двух типов запросов: *query* и *mutation*

|||
|-|-|
|Create|Mutation|
|Read|Query|
|Update|Mutation|
|Delete|Mutation|

Для всех запросов на чтение в GraphQL нужно указывать слово `query`, служебный параметр. А если вы хотите что-то поменять (создание, обновление, удаление), вы должны указывать ключевое слово `mutation`. Это позволяет комбинировать в одном запросе сразу операции создания и чтения.

## WebSocket

**WebSocket** - протокол связи поверх TCP-соединения, предназначенный для обмена сообщениями между клиентом и сервером, использующий постоянное соединение.

WebSocket, помогает системам, которые хотят работать в режиме реального времени. Если есть какие-то данные, которые нужно отправить клиенту, сервер знает, что есть вот сокет соединения, их можно туда отправить и они успешно туда улетят. Клиент же спокойно работает и знает, что если прилетят данные через конкретный сокет, надо будет с ними выполнить операции. В общем, все спокойно работают и, если надо, обмениваются сообщениями, никто никого не ждет.

### Установка соединения

Процесс работы по Websocket выглядит так. Сперва посылается обычный HTTP-запрос на установку постоянного соединения, у запроса должно быть два очень важных технических заголовка:

* Первый – это connection upgrade. Тут мы говорим серверу, что готовы перенести наши отношения на новый уровень, более постоянный и вообще хороший.
* Второй — мы указываем, что мы хотим сделать апгрейд на WebSocket.

```http
GET /chat HTTP/1.1
Host: server.example.com
Upgrade: websocket
Connection: Upgrade
```

Если сервер может, он отвечает — хорошо, это будет код ответа 101, и служебные заголовки смены протокола.

```http
HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: HSmrc0sMl YUkAGmm50PpG2HaGWk=
Sec-WebSocket-Protocol: chat'
```

Укажет, на какой протокол поменялся, какой сокет будет использоваться и прочую информацию.

После этого между клиентом и сервером устанавливается тип соединения connection, они начинают общаться - обмениваться сообщениями.

```http
HTTP Connect is upgrading to WS
TYPE: Connection
```

Если вдруг кто-то там отвалился или закрыл соединение, тип коннекта меняется на дисконнект.

```http
WS connection close
TYPE: Disconnect
```

У WebSocket-протокола есть специальный механизм пинг-понгов — он всегда может уточнить, “слышно” ли его и стоит ли продолжать работу. Если вдруг кто-то не ответил, происходит несколько попыток (с увеличивающимся таймаутом), и после этого соединение считается закрытым.

### WebSocket коды ответов

У WebSocket есть свои коды ответов, которые все так или иначе завязаны именно на закрытие соединения.

|Status Code|Meaning|
|--|--|
|1000|Normal Closure|
|1001|Going Away|
|1002|Protocol error|
|1003|Unsupported Data|
|1004|Reserved|
|1005|No Status Rcvd|
|1006|Abnormal Closure|
|1007|Invalid frame payload data|
|1008|Policy Violation|
|1009|Message Too Big|
|1010|Mandatory Ext.|
|1011|Internal Error|
|1012|Service Restart|
|1013|Try Again Later|
|1014|The server was acting as a gateway or proxy and received an invalid response from the upstream server. This is similar to 502 HTTP Status Code.|
|1015|TLS handshake|
|1016-2999|Unassigned|
|3000|Unauthorized|
|3001-3002|Unassigned|
|3003|Forbidden|
|3004-3999|Unassigned|
|4000-4999|Reserved for Private Use|

### Тестирование WebSocket

В **DevTools** запросы по протоколу WebSocket можно найти на вкладке *Network* - в фильтре *WS*. В свойствах запроса есть в том числе вкладка Messages, в которой можно увидеть сообщения, которыми обменивались клиент с сервером.

В **Postman** есть специальный вид запроса *WebSocket*. Сообщения можно сохранять.

В **Python** для работы с WebSocket используется библиотека *websockets*. С помощью этой библиотеки можно как создать WebSocket сервер, так и отправлять сообщения по протоколу WebSocket от имени клиента.

Также для работы с WebSocket используется утилита командной строки **wscat**.  
`wscat` написана на Node.js, устанавливается как npm-пакет.

`wscat -l 8765` - создать WebSocket на порту 8765 - по сути создает WebSocket сервер, позволяющий получать и отправлять сообщения по протоколу WebSocket.

`wscat -c ws://127.0.0.1:8765/status` - подключиться к локальному WebSocket серверу на порту 8765 по пути '/status'


## gRPC

**RPC** — удалённый вызов процедур (иногда вызов удалённых процедур; от англ. *remote procedure call*) — класс технологий, позволяющих программам вызывать функции или процедуры других программ, делая это так, как если бы они находились в одном адресном пространстве.

**gRPC** - гугловая реализация RPC.

Разберем это все на примере.

Допустим, что вы — программист и сидите в монолитной репе. У вас одно приложение. Сам проект открыт в IDE и вы в нем работаете. В репе реализован определенный класс (например, на Kotlin), у которого есть метод, возвращающий вам данные по пользователю.

```kotlin
fun getUserInfo(id: String) {
   return //some data
}
```

Теперь в другом месте проекта, в другом классе, вы хотите вызвать этот метод, чтобы поработать с данными о пользователе. Что вы тогда делаете? Импортируете класс и просто делаете обычный вызов метода.

```kotlin
var userData = getUserInfo("userID")
// Continue work with data
```

Дальше приходит новый вызов - микросервисная архитектура, которая предлагает всё разделить и вынести всё, что мы делаем с пользователями, в отдельный сервис.

Теперь наши условные сервисы разделило сетевое взаимодействие, вот как на картинке.


