# Non-REST API: GraphQL, WebSocket, gRPC

## Содержание

## WebSocket

**WebSocket** - протокол связи поверх TCP-соединения, предназначенный для обмена сообщениями между клиентом и сервером, использующий постоянное соединение.

WebSocket, помогает системам, которые хотят работать в режиме реального времени. Если есть какие-то данные, которые нужно отправить клиенту, сервер знает, что есть вот сокет соединения, их можно туда отправить и они успешно туда улетят. Клиент же спокойно работает и знает, что если прилетят данные через конкретный сокет, надо будет с ними выполнить операции. В общем, все спокойно работают и, если надо, обмениваются сообщениями, никто никого не ждет.

### Установка соединения

Процесс работы по Websocket выглядит так. Сперва посылается обычный HTTP-запрос на установку постоянного соединения, у запроса должно быть два очень важных технических заголовка:

* Первый – это connection upgrade. Тут мы говорим серверу, что готовы перенести наши отношения на новый уровень, более постоянный и вообще хороший.
* Второй — мы указываем, что мы хотим сделать апгрейд на WebSocket.

```http
GET /chat HTTP/1.1

Host: server.example.com
Upgrade: websocket
Connection: Upgrade
```

Если сервер может, он отвечает — хорошо, это будет код ответа 101, и служебные заголовки смены протокола.

```http
HTTP/1.1 101 Switching Protocols

Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: HSmrc0sMl YUkAGmm50PpG2HaGWk=
Sec-WebSocket-Protocol: chat'
```

Укажет, на какой протокол поменялся, какой сокет будет использоваться и прочую информацию.

После этого между клиентом и сервером устанавливается тип соединения connection, они начинают общаться.

```http
HTTP Connect is upgrading to WS
TYPE: Connection
```

Если вдруг кто-то там отвалился или закрыл соединение, тип коннекта меняется на дисконнект.

```http
WS connection close
TYPE: Disconnect
```

У WebSocket-протокола есть специальный механизм пинг-понгов — он всегда может уточнить, “слышно” ли его и стоит ли продолжать работу. Если вдруг кто-то не ответил, происходит несколько попыток (с увеличивающимся таймаутом), и после этого соединение считается закрытым.

### WebSocket коды ответов

У WebSocket есть свои коды ответов, которые все так или иначе завязаны именно на закрытие соединения.

|Status Code|Meaning|
|--|--|
|1000|Normal Closure|
|1001|Going Away|
|1002|Protocol error|
|1003|Unsupported Data|
|1004|Reserved|
|1005|No Status Rcvd|
|1006|Abnormal Closure|
|1007|Invalid frame payload data|
|1008|Policy Violation|
|1009|Message Too Big|
|1010|Mandatory Ext.|
|1011|Internal Error|
|1012|Service Restart|
|1013|Try Again Later|
|1014|The server was acting as a gateway or proxy and received an invalid response from the upstream server. This is similar to 502 HTTP Status Code.|
|1015|TLS handshake|
|1016-2999|Unassigned|
|3000|Unauthorized|
|3001-3002|Unassigned|
|3003|Forbidden|
|3004-3999|Unassigned|
|4000-4999|Reserved for Private Use|

### Тестирование WebSocket

В **DevTools** запросы по протоколу WebSocket можно найти на вкладке *Network* - в фильтре *WS*. В свойствах запроса есть в том числе вкладка Messages, в которой можно увидеть сообщения, которыми обменивались клиент с сервером.

В **Postman** есть специальный вид запроса *WebSocket*. Сообщения можно сохранять.

В **Python** для работы с WebSocket используется библиотека *websockets*. С помощью этой библиотеки можно как создать WebSocket сервер, так и отправлять сообщения по протоколу WebSocket от имени клиента.

Также для работы с WebSocket используется утилита командной строки **wscat**.  
`wscat` написана на Node.js, устанавливается как npm-пакет.

`wscat -l 8765` - создать WebSocket на порту 8765 - по сути создает WebSocket сервер, позволяющий получать и отправлять сообщения по протоколу WebSocket.

`wscat -c ws://127.0.0.1:8765/status` - подключиться к локальному WebSocket серверу на порту 8765 по пути '/status'
