# Сети

## Содержание

* [Основные понятия сетей](#основные-понятия-сетей)  
	* [Модель клиент-сервер](#модель-клиент-сервер)
	

## Основные понятия сетей

### Модель клиент-сервер

Большая часть данных в Интернете передается между двумя узлами. Первый узел — это программа, которая хочет получить данные, называемая "клиент". В нашем примере клиентом является веб-браузер. Когда вы открываете веб-сайт, браузер пытается подключиться к этому сайту и запросить данные.

Второй узел — это сервер, программа, обрабатывающая ваш запрос (здесь и далее в этой главе под сервером мы понимаем программу, а не специальный компьютер, отличающийся от вашего ноутбука или настолького ПК).

Отправка запроса из терминала:
```
nc example.com 80
GET / HTTP/1.1
Host: example.com
```

### Адреса и маршрутизация

Вы написали в адресной строке веб-браузера «example.com» и нажали Enter. Адрес example.com понятен людям, однако компьютерам ничего о нём не известно. Это просто удобное для людей доменное имя, которое для использования компьютером необходимо преобразовать в так называемый IP-адрес. Процесс преобразования одного адреса в другой называется **resolving** («разрешение»).

Этот процесс - "разрешение имени", или, если короче, resolving - работает следующим образом: ваша операционная система берет адрес DNS-сервера из своих сетевых настроек. Когда вы пытаетесь подключиться к ресурсу с определённым доменным именем, ОС отправляет серверу DNS специальный запрос: «отправь мне IP-адрес, соответствующий имени example.com». Получив запрос, сервер DNS ищет в очень большой таблице адрес для имени example.com и отправляет результат.

Теперь компьютер знает адрес ресурса с именем example.com.

Узнать IP-адрес:  
`host example.com` - Linux  
`nslookup example.com` - Windows

Статус DNS-сервера:  
`resolvectl status` - Linux  
`ipconfig /all` - Windows  

**IP-адрес** — это набор из четырёх чисел, разделённых точками. Каждое число (они называются октетами) должно быть между 0 и 255. Например: 127.0.0.1, 8.8.8.8 или 192.168.0.1. Вы можете воспринимать его как почтовый индекс, необходимый для отправки посылки определённому человеку. IP-адрес есть у всех устройств, подключённых к современным сетям.

Чтобы установить соединение с удаленным узлом, нужно знать еще одно число, называемое **номером порта**. Если IP-адрес — это почтовый индекс здания, то порт — это дверь с определённым номером в этом здании. В большинстве случаев каждый номер порта используется только для конкретной службы или протокола. Нам необходимо установить соединение HTTPS, поэтому будем использовать номер порта 443 (он используется для этого протокола по умолчанию, поэтому его не нужно будет указывать).

Итак, у нас есть адреса и номера портов, чтобы можно было отправить запрос.

Но есть одна маленькая проблема: мы не знаем, как добраться до сервера назначения, поскольку он может находиться где угодно, даже в другой стране или на другом континенте. На самом деле нам не нужно знать полный маршрут, так же как нам не нужно его знать, когда отправляем открытку другу. Нам необходимо лишь найти ближайший почтовый ящик.

Скорее всего, ваш компьютер уже подключен к локальной сети, и у вас уже есть  IP-адрес; кстати, IP расшифровывается как "Internet Protocol", т.е. "протокол межсетевого общения". Кроме того, если у вас дома есть роутер, то поздравляем — у вас уже есть собственная маленькая локальная сеть!

По сути, Интернет - не что иное, как огромное количество сетей, соединенных друг с другом. Как каждый компьютер, подключённый к Интернету, обладает IP-адресом, так и каждый IP-адрес является частью некой сети. У сетей тоже есть адреса, состоящие из двух частей, разделённых косой чертой: **адрес сети** (network address) и **маска подсети** (netmask).

Адрес сети выглядит абсолютно так же, как IP-адрес узла. А маска сети (или "подсети", могут применяться оба термина) — это просто число между 0 и 32, с помощью которого компьютер узнаёт размер сети и диапазон IP-адресов, доступных в ней.

Чем больше значение маски подсети, тем меньше размер подсети и тем меньше IP-адресов в ней.
Например, маска /24 соответствует 256-и IP-адресам, а /28 — только 16-и.

Также маску подсети можно записать в длинной форме. В этом случае она выглядит похожей на IP-адрес.
Например, /16 и 255.255.0.0 — это одна и та же маска подсети в короткой и длинной форме соответственно.

Операционная система применяет адреса сетей и их маски внутри очень важной таблицы, называемой **таблица маршрутизации** (routing table).
С помощью этой таблицы компьютер узнаёт, как подключиться к тому или иному адресу.

`ip route list` - таблица маршрутизации Linux  
`route -4 PRINT` - таблица маршрутизации Windows

Внутри каждой сети, подключенной к интернету (или просто к другим сетям, даже без выхода в Интернет), должен быть шлюз.  
**Шлюз** — это специальным образом сконфигурированный компьютер или сетевое устройство, подключённое к двум или более сетям и способное пересылать данные из одной сети в другую. Наиболее распространённым примером аппаратного сетевого шлюза является домашний роутер. IP-адрес шлюза указывается в настройках сети каждого подключенного к этой сети компьютера.

Таким образом, когда пользователь хочет установить соединение с любым другим узлом из внешних сетей, операционная система будет применять маршрут по умолчанию, чтобы отправить клиентский запрос через свой шлюз. Далее ближайший шлюз пересылает запрос другому шлюзу, тот в свою очередь — следующему и т. д. Каждый шлюз маршрута называют  **хоп**, или транзитный узел. Таким образом ваш запрос и достигает сервера example.com.

Получив запрос, сервер формирует ответ и отправляет его аналогичным способом.

Узнать IP-адрес, маску подсети:  
`ifconfig`  
`ip addr list` - Linux

`ipconfig` - Windows

Построение маршрута:  
`traceroute example.com` - Linux  
`tracert example.com` - Windows

### Физический уровень

В момент, когда данные уже готовы к передаче, клиентская ОС запрашивает сетевой адаптер для отправки этих данных по кабелю или беспроводному каналу. Сетевому адаптеру ничего не известно об IP-адресах, масках посети, шлюзе, используемом по умолчанию, и других программных сущностях, таких как ОС или предпочитаемый веб-браузер. Зато ему известен свой уникальный аппаратный адрес, называемый **MAC-адресом** (Media Access Control address — адрес управления доступом к среде передачи данных). MAC-адрес состоит из шести пар шестнадцатеричных символов, разделённых двоеточиями, например 46:09:9f:f5:87:aa.

К этому моменту уже известно, что узел example.com находится за пределами вашей сети, поэтому вам нужен шлюз (в данном случае это 10.8.0.1). Первым делом операционная система запросит сетевой адаптер отправить специальное широковещательное сообщение: «узел с IP 10.8.0.1, ответь, мне нужен твой MAC-адрес, чтобы пообщаться с тобой» (при этом 10.8.0.1 — адрес из нашей локальной сети). В случае успеха операционная система получит следующую информацию: «узел с IP-адресом 10.8.0.1 обладает MAC-адресом 46:09:9f:f5:87:aa», и запишет её в специальную таблицу. В этой таблице отображаются устройства, с которым ваш узел "общался" в пределах локальной сети.
Так работает протокол **ARP** (Address Resolution Protocol — протокол определения адресов).

На следующем шаге клиентская ОС запрашивает сетевой адаптер передать сообщение вида "Узел с MAC-адресом  46:09:9f:f5:87:aa, для тебя есть сообщение: [текст сообщения]". Операционная система роутера (внутри этой маленькой коробочки также есть ОС) поместит ваше сообщение в пакет программного уровня, прочтёт IP-адрес узла назначения, выберет нужный интерфейс для дальнейшей пересылки и отправит сообщение через физический уровень этого интерфейса.

**Сетевой адаптер** (также может применяться термин **сетевой интерфейс**) - физическое или виртуальное оборудование, предназначенное для приема-передачи сигналов по сети. Узлы и сетевые интерфейсы связаны как "один ко многим" (аналогично сущностям баз данных), например:

* Компактный ноутбук может иметь всего 1 встроенный физический сетевой интерфейс, это WiFi-адаптер
* Ноутбук большего размера как правило имеет 2 и более физических сетевых интерфейса, например один WiFi-адаптер и одну сетевую Ethernet-карту
* Cовременные смартфоны имеют как минимум 2 сетевых интерфейса (оба - беспроводные): один для передачи данных по мобильным сетям (4G или 5G), второй - WiFi-адаптер
* Маршрутизаторы как правило имеют 2 или более сетевых интерфейса для соединения с разными сетями и передачи данных между ними
* При установке VPN-соединения в системе появляется еще минимум 1 виртуальный сетевой интерфейс для обмена данными внутри VPN-соединения

Даже если у компьютера нет ни одного исправного физического сетевого интерфейса, все равно в системе присутствует минимум 1 виртуальный интерфейс, часто называемый loopback-интерфейсом или "интерфейсом обратной петли". Он нужен для взаимодействия клиентского и серверного ПО, запущенного на одном и том же узле.

Не бывает случаев, когда один и тот же сетевой интерфейс принадлежит нескольким разным узлам. Даже если на узле запущено несколько виртуальных машин, которые имеют доступ к одному и тому же физическому сетевому интерфейсу, каждая из виртуальных машин имеет свой собственный виртуальный сетевой интерфейс.

Как отмечалось выше, должна быть связь между сетевыми интерфейсами и IP-адресами. Эта связь также имеет тип "один ко многим"; примеры ниже указаны в порядке убывания вероятности встретить такие настройки:

1. Самый частый случай: 1 сетевой интерфейс имеет 1 IP-адрес. Чаще всего именно так и происходит, когда вы подключаете узел к локальной сети.
2. Один сетевой интерфейс не имеет ни одного настроенного IP-адреса. Пример: вы включаете ноутбук там, где нет никаких точек доступа WiFi.
3. Один сетевой интерфейс имеет несколько IP-адресов. Такие настройки могут быть встретиться на сетевых устройствах или серверах в специфических ситуациях.

Один и тот же IP-адрес НЕ может быть назначен нескольким сетевым интерфейсам в рамках одной сети.

Cодержимое ARP-таблицы вашего компьютера:
`arp -a -n` - Linux  
`arp /a` - Windows

## TCP/IP

**TCP/IP** — сетевая модель передачи данных, представленных в цифровом виде. Модель описывает способ передачи данных от источника информации к получателю.

Модель TCP/IP разделена на четыре уровня (иногда на пять; самый нижний уровень, физический):
1. **Прикладной уровень (Application Layer)**. Как следует из названия, это группа протоколов, служащих для взаимодействия между приложениями. Они используются каждый раз, когда пользователь запрашивает в сети какую-либо информацию с помощью приложения. Большая часть протоколов, работающих в рамках модели клиент-сервер, относится к прикладному уровню.
*HTTP*-протокол, упомянутый в предыдущем модуле, является наглядным примером прикладного протокола. Запрос клиента GET и ответ сервера с кодом 200 (успешное выполнение запроса), отправленные по протоколу HTTP 1.1 являются передачей данных приложения через сеть.
Протоколы прикладного уровня предназначены для запроса и передачи данных, то есть на этом уровне задаётся вопрос “***ЧТО*** должно быть отправлено и получено”.
2. **Транспортный уровень (Transport Layer)**. Для управления передачей данных необходимо добавить некоторую служебную информацию: номера портов, поле подтверждения доставки или специальные данные для управления скоростью передачи.
Вспомните практические упражнения и домашнее задание из предыдущего модуля, где для доступа к веб-серверу с сайтом example.com использовались программы nc и telnet. Такие числа, как 80 и 443, являются номерами портов. Эту служебную информацию необходимо добавить к данным приложения до их отправки другой стороне.
Самые распространённые протоколы транспортного уровня это *TCP* (Transmission Control Protocol — протокол управления передачей) и *UDP* (User Datagrams Protocol — протокол пользовательских датаграмм).
Протоколы транспортного уровня описывают ***КАК ИМЕННО*** запросы и ответы должны отправляться и приниматься: какой порт использовать, нужно ли проверять целостность данных и очерёдность пакетов, нужно ли повторно отправлять потерянные пакеты и т. д.
3. **Сетевой уровень (Network Layer)**. Предназначен для адресации и поиска узла назначения, а также для маршрутизации. В модели TCP/IP сетевой уровень представлен протоколом *IP* (Internet Protocol — межсетевой протокол). Как видно из названия, это вторая часть, необходимая для реализации модели. Этот уровень отвечает на вопрос, ***как клиентам и серверам найти друг друга***, даже если они расположены в различных несмежных сетях. Например, чтобы обеспечить доступ к серверу example.com из домашнего компьютера, задействуется протокол IP с элементами, необходимыми для маршрутизации.
4. **Уровень сетевого интерфейса** (Datalink Layer / Interface Layer, он же "канальный уровень", либо "уровень сетевого доступа"). Говоря о предыдущих уровнях, мы обсуждали программные сущности, но они не могут обойтись без физической передачи данных от одного компьютера к другому. Этот уровень служит интерфейсом между программным обеспечением (ПО) и физическими устройствами, например адаптерами для ***Ethernet, Wi-Fi, Bluetooth*** или модемами DSL.  Этот уровень также применяется для соединения устройств, находящихся в одной локальной сети, где используются аппаратные адреса без обращения к IP-адресам.
5. Иногда упоминается ещё один уровень — **физический уровень** (Physical Layer). Он располагается после уровня сетевого интерфейса и используется для  передачи данных по физической среде, например медному проводу, оптическому волокну или воздуху. На этом уровне нет программных протоколов, только физические сигналы.

Каждый уровень можно рассматривать независимо, например:
* Сетевые приложения, работающие на верхнем уровне, ничего не знают об интерфейсе или физическом уровне. Разработчики приложений не заботятся о том, передаются ли данные через Ethernet по медному проводу, через Wi-Fi или спутник.
* Программному обеспечению сетевого уровня (протокол IP) нет разницы, какие именно данные отправляет приложение на удалённый компьютер; главная задача этого уровня — проложить путь между клиентом и сервером.

Уровни модели TCP/IP связаны друг с другом посредством инкапсуляции, то есть помещения простых объектов в более сложные.  
Стек TCP/IP состоит из вложенных уровней, как матрёшка.  
Каждый уровень выполняет определённые задачи и включает в свой пакет все данные предыдущих уровней (как служебные заголовки, так и «полезную нагрузку»).

**Данные прикладного уровня** — это текст или двоичный код. В сущности, можно передавать любую информацию. Другая причина, почему прикладной уровень называется именно так, заключается в том, что только на этом уровне вы можете составлять данные самостоятельно, на всех остальных уровнях вам придётся просить об этом операционную систему (ОС).  

**Пакет TCP** — это определённая структура данных, состоящая из заголовка, в котором содержится служебная информация, необходимая для передачи данных, и полезной нагрузки — поле Data, т. е. данные.

Следующий уровень: **структура пакета IP**, в поле Data которого содержится пакет TCP вместе с прикладными данными.  
ОС поместит в поле Protocol (протокол) специальное число, говорящее получателю, что в поле Data лежит пакет TCP. Далее ОС помещает в поле Source address (адрес источника, отправителя) IP-адрес вашего компьютера, а в поле Destination address (адрес назначения, получателя) помещает IP-адрес удалённого узла. Весь пакет TCP будет помещён в поле Data. Ещё одно важное поле — TTL (Time to live — время существования). Оно содержит максимальное количество шлюзов, через которое может пройти пакет. Значение по умолчанию: 64 для Linux и macOS, 128 для современных версий Windows.

На **нижнем уровне** все предыдущие данные, помещённые в пакет IP, будут упакованы в поле Data кадра Ethernet (если используется именно Ethernet). Поле Destination address будет заполнено MAC-адресом узла назначения (или MAC-адресом шлюза, если таковой применяется), полученным с помощью протокола ARP. Аппаратный адрес вашего сетевого адаптера будет расположен в поле Source address. В поле CRC будет помещена контрольная сумма, необходимая для проверки того, что у отправителя и у получателя одинаковые копии данных.

## Основы IP-сетей

**IP** — это протокол сетевого уровня, реализующий две основные функции: адресацию и маршрутизацию.

### IP адресация

У каждого узла сети, построенной на основе протокола IPv4, есть специальный 32-битный IP-адрес, который используется для сетевого взаимодействия.  
**Маска подсети** - специальный параметр, описывающий размер сети, к которой подключён компьютер. Маску подсети можно указать в двух формах: число между 0 и 32 или формат IP-адреса. Например, маски подсети "24" и "255.255.255.0" эквивалентны. Применение пар «адрес-маска подсети», разделённых косой чертой (например, 192.168.0.0/24 или 192.168.0.0/255.255.255.0), также известно как **CIDR-адресация** (Classless Inter-Domain Routing — Бесклассовая междоменная маршрутизация).

С помощью побитовой операции между IP-адресом и маской компьютер вычисляет диапазон адресов подсети. Например, узел с IP-адресом 192.168.0.1 и маской подсети 24 является частью подсети 192.168.0.0/24, включающей 256 адресов от 192.168.0.0 до 192.168.0.255. Расчёты проводятся с помощью простой двоичной арифметики: 2 ^ (32 - 24) = 2 ^ 8 = 256.

`ipcalc` - двоичные операции с IP-адресами (Linux)

* Существует 33 варианта масок подсети (от 0 до 32), которые можно описать двумя равнозначными способами, "длинным" и "коротким".
* Значение маски обратно пропорционально размеру сети. Например, есть только один узел в сети с маской "32", 4 узла в сети с маской "30", 256 узлов в сети с маской "24".

### Маршрутизация

В основе IP-сетей лежит следующая идея: разделить адресное пространство на подсети, поместить узлы внутрь подсетей, а затем, при необходимости, обеспечить установку соединения между подсетями. Механизм взаимодействия между сетями называется маршрутизацией.  
Путь к узлу назначения операционная система выбирает, основываясь на таблицах маршрутизации.

Каждая строка **таблицы маршрутизации** содержит три основных объекта:

* **Адрес назначения** (первый элемент в строке), доступ к которому можно получить с помощью этой записи. Предусмотрено два варианта: адреса CIDR и default (по умолчанию). Последний вариант используется для связи со всеми узлами, которые не подходят под существующие правила маршрутизации. IP-адрес одного узла — это экземпляр адреса подсети (192.168.0.1 будет эквивалентен 192.168.0.1/32).

* **Устройство**. Если вы пытаетесь получить доступ к узлу назначения, располагающегося в одной из подсетей, подключённых к вашим интерфейсам, то шлюз вам не потребуется. В случае использования адреса шлюза нужный интерфейс будет определён автоматически с помощью маршрута к подсети шлюза.

* **Шлюз** — это узел, который будет использоваться для доступа к сетям, к которым вы не подключены напрямую. 

`ip route get 1.2.3.4` - получить соответствующее правило для узла назначения из таблицы маршрутизации (Linux)  
`traceroute 1.2.3.4` - покажет список транзитных узлов между вами и удалённым узлом.  
Эта команда отправляет узлу назначения специальные пакеты IP со значением поля TTL, начинающимся с 1 (увеличивая значение с каждым шагом на 1 до момента получения ответа от узла назначения). Благодаря такому значению промежуточные шлюзы отправляют обратно другой специальный пакет (об исчерпании поля TTL), таким образом обнаруживая себя (если это не отключено в настройках шлюза).  
`tracert` - Windows

### Откуда берутся IP-адреса

Пространство IP-адресов разделено на две части: частные и глобальные.  
**Частные области** были зарезервированы в документации межсетевого протокола (Internet Protocol — IP) как подсети для создания локальных сетей. Вот список зарезервированных для этого подсетей: 10.0.0.0/8, 172.16.0.0/12, 192.0.0.0/24 и 192.168.0.0/16. Эти сети не участвуют в глобальной маршрутизации, поэтому вы не сможете напрямую отправить пакет через Интернет в другую локальную сеть. Примечание: также есть специальная частная подсеть 127.0.0.0/8 (localhost).  
**Глобальные (также называемые публичными)** — это просто адреса, не принадлежащие зарезервированным областям. Если вам нужен публичный адрес, вы можете запросить его у вашего интернет-провайдера. В свою очередь провайдер, как и все компании, которым нужно большое количество IP-адресов, может получить их у специальных компаний, называемых брокерами IP-адресов, или у региональных интернет-регистраторов.

`whois` - получение сведений о владельце публичных подсетей (Linux)

Для назначения IP-адресов в локальных сетях обычно применяются два подхода:  
Большинство современных маршрутизаторов используют протокол **DHCP (Dynamic Host Configuration Protocol — протокол динамического конфигурирования узлов)** для автоматического назначения IP-адресов, адресов подсетей, маршрутов и адресов серверов DNS.  
Вы можете использовать **статическую конфигурацию**, полученную от вашего интернет-провайдера или системного администратора. Аналогичным образом, если вы не хотите по какой-либо причине использовать протокол DHCP, то в своей собственной сети, дома, например, вы можете назначать адреса вручную, используя одну из частных подсетей.

### NAT: преобразование сетевых адресов

Что же делает маршрутизатор для соединения вашего компьютера с Интернетом. Предположим, у нас есть адрес 10.0.0.2 в локальной сети 10.0.0.0/24. У нашего маршрутизатора есть два интерфейса с адресами 10.0.0.1 и 1.2.3.4. Мы хотим отправить запрос публичному серверу DNS с адресом 8.8.8.8.

Первым делом ваш компьютер на сетевом уровне упаковывает запрос в пакет IP с адресом назначения 8.8.8.8, ищет в таблице маршрутизации маршрут для адреса 8.8.8.8 и даёт понять, что пакет должен отправляться на маршрутизатор посредством его MAC-адреса. Маршрутизатор получает пакет. Анализируя пакет IP, понимает, что он не конечный получатель. В этот момент в игру и вступает механизм NAT (Network Address Translation — преобразование сетевых адресов). Следите внимательно:

Маршрутизатор ищет в своей таблице маршрутизации маршрут к узлу назначения. В нашем случае он выберет интерфейс с публичным адресом 1.2.3.4.
Маршрутизатор сохраняет у себя информацию, что он теперь является промежуточным узлом между 10.0.0.2 и 8.8.8.8.
Маршрутизатор изменяет адрес источника в вашем пакете IP: с 10.0.0.2 на публичный адрес 1.2.3.4.
Маршрутизатор уменьшает значение поля TTL в вашем пакете IP на единицу. Это поле не позволяет пакету бесконечно блуждать по сети в случае образования маршрутной петли (контура). Каждый последующий маршрутизатор выполнит те же действия. Пакет с обнулившимся полем TTL будет отброшен.

Удалённый сервер DNS с адресом 8.8.8.8 обработает запрос и отправит ответ в новом пакете IP маршрутизатору с адресом 1.2.3.4, так как он думает, что узел с адресом 1.2.3.4 и есть автор запроса.
Маршрутизатор получает пакет с ответом от узла с адресом 8.8.8.8, проверяет свой список соединений и определяет, что этот пакет предназначен узлу с адресом 10.0.0.2.
Маршрутизатор изменяет в пакете адрес назначения с 1.2.3.4 на 10.0.0.2 и отправляет пакет клиенту.

### Localhost

127.0.0.0/8.  
В реальности встречается множество случаев, когда вашему компьютеру нужно установить соединение с какой-либо сетевой службой, работающей локально, то есть нужно буквально подключиться к самому себе.

Например, если вы хотите развернуть на своём локальном компьютере серверное ПО и протестировать его посредством соответствующего клиента, установленного на этом же компьютере, то вы можете сделать это даже без подключения к какой-либо сети, поскольку у вашего компьютера всегда есть как минимум один IP-адрес — 127.0.0.1.

Другой случай. В современных дистрибутивах Linux чаще всего DNS-сервер устанавливается локально (это простое ПО для кэширования запросов и ускорения работы). Поэтому ваша операционная система устанавливает соединение с адресом 127.0.0.1 и портом 53 каждый раз, когда нужно преобразовать какое-либо имя в IP-адрес. И только если требуемая запись не найдена в кэше локального сервера DNS, то приложение сервера DNS передаст запрос вышестоящему серверу.

Вот как это работает:

1. Есть виртуальный сетевой интерфейс, реализующий механизм «обратной петли», обычно с именем lo (на ОС Linux) с назначенным адресом 127.0.0.1 и маской подсети 255.0.0.0. Хитрость интерфейса с обратной петлей в том, что он всегда ответит, на какой бы адрес этой подсети вы не отправили сообщение. Поэтому, хотя вы видите только один назначенный интерфейсу адрес 127.0.0.1, если вы попытаетесь подключиться к любому адресу из подсети 127.0.0.0/8, то результат всегда будет одинаков.
2. Есть специальное имя localhost (локальный узел), служащее псевдонимом для узла с адресом 127.0.0.1. Его можно использовать вместо IP-адреса, если вам так удобнее.
3. Когда вы пытаетесь подключиться к 127.0.0.1, операционная система видит, что этот адрес относится к маршруту, связывающему подсеть 127.0.0.0/8 с интерфейсом lo. Затем ваши данные будут отправлены виртуальному интерфейсу с обратной петлёй, а операционная система получит входящее сообщение, обработает его и самостоятельно ответит.

`netstat -vpntul` - какие порты слушаются на localhost (Linux)

### DNS: Система доменных имён (Domain Name System)

Основной способ использования системы DNS — это преобразование доменных имён в IP-адреса. 

Сначала операционная система будет искать это имя в локальном списке, состоящем из пар «имя узла — IP-адрес». В большинстве UNIX-подобных систем он находится в файле /etc/hosts. Например, запись, гласящая, что имя localhost эквивалентно адресу 127.0.0.1, находится именно здесь. В случае неудачи ОС возьмёт адрес DNS сервера  из файла /etc/resolv.conf и инициирует отправку запроса ему (в/etc/resolv.conf часто указано, что основной DNS-сервер расположен локально на 127.0.0.1).

Узнать IP-адрес:  
`host example.com` - Linux  
`nslookup example.com` - Windows

Статус DNS-сервера:  
`resolvectl status` - Linux  
`ipconfig /all` - Windows

Каждое доменное имя может быть разделено точками на **зоны** (www, example и com). Если зона действительно существует, то должен быть по крайней мере один сервер DNS, располагающий полной информацией об этой зоне. Такие серверы называются полномочными (authoritative) серверами DNS

Зоны и их полномочные сервера упорядочены в иерархической структуре, начинающейся с конца доменного имени. Существует группа корневых серверов, в которых хранится информация о зонах первого уровня и об их полномочных серверах. В свою очередь серверы первого уровня располагают информацией о зонах второго уровня. Это может продолжаться бесконечно, но обычно серверы зон второго уровня и следующих работают в рекурсивном режиме (т.е. отвечают на все запросы про нижестоящие доменные имена).

Другой тип серверов DNS, которые всегда работают в рекурсивном режиме, это **резолверы** (преобразователи, сопоставители). Такие преобразователи обычно не хранят информацию о доменах, они просто обрабатывают запросы клиентов и перенаправляют их серверам иерархического дерева.  
В некоторых случаях «резолверы» дополнительно настраивают на хранение информации о локальных зонах. Например, если в локальной сети вашей компании множество узлов, то удобней всего было бы назначить им доменные имена, такие как "что_то.local" или "что_то.название_компании.com", которые будут доступны только в интранете (внутренней локальной сети организации).

Самые распространённые записи системы DNS:
1. **Запись "A"** используется для преобразования имени домена в IP-адрес. У домена может быть несколько записей "A", содержащих несколько IP-адресов, назначенных этому домену. В таком случае ОС выберет адрес из списка случайным образом. Этот механизм называют каруселью, циклическим перебором, алгоритмом кругового обслуживания (round robin). Что касается обратной процедуры - количество доменных имён, связываемых с одним IP-адресом, не ограничено.
2. **Запись PTR** (pointer — указатель) выполняет обратную функцию, преобразуя IP-адреса в доменные имена. В большинстве случаев значения записей "A" и PTR не синхронизированы между собой.
3. **CNAME** (canonical name — каноническое имя) — это псевдоним. Например, если у вашего веб-сайта несколько доменных имён, то вы можете привязать одно к другому, указав это имя как псевдоним к имени, содержащемуся в записи "A". Пример: А-запись my-site.com ссылается на IP-адрес a.b.c.d, а доменное имя www.my-site.com с помощью CNAME ссылается на my-site.com.
4. **MX** (mail exchanger — почтовый обменник) — это запись, указывающая, какой почтовый сервер  обрабатывает электронную почту этого домена.
5. Записи **NS** (Authoritative Name Server — полномочный сервер имён) и SOA (Start-of-authority — начальная запись зоны) содержат сведения о полномочных серверах зоны. С помощью этих записей «резолверы» получают информацию о следующем сервере DNS, которому следует оправить запрос.
6. Записи **SRV** (Server selection — выбор сервера) и **TXT** (Text String — текстовая строка) можно использовать для хранения любой текстовой информации.

## Транспортный уровень модели TCP/IP

Передача данных в сети - это не просто копирование файлов. Все данные приложения инкапсулируются в пакеты транспортных протоколов. Транспортный уровень служит для обеспечения некоторых функций по передаче данных, которые нельзя реализовать ни на прикладном, ни на сетевом уровне. Суть транспортного уровня - в определении способов передачи данных, то есть в определении, *как именно данные будут передаваться*.

Транспортный уровень модели TCP/IP представлен в большинстве случаев протоколами **TCP** (Transmission Control Protocol — протокол управления передачей) и **UDP** (User Datagram Protocol — протокол пользовательских датаграмм).

### Основные принципы и понятия

#### Сетевые пакеты

Данные запросов и ответов серверов и клиентов не текут по сети плавно и непрерывно, как река. Поток данных больше похож на фотоны — поток множества незаметных частиц.  
Поэтому нельзя передать большой файл за раз одной порцией. Он разделяется на **пакеты** (порции данных наподобие фотонов), а затем эти пакеты отправляются и принимаются, далее пакеты снова собираются в файл и передаются приложениям (это верно как для приложений клиентов, так и для приложений серверов).
Максимальный размер пакета зависит от настроек канального уровня, в современных сетях он обычно равен 1500 байтов. Теоретически каждый пакет может маршрутизироваться отдельно. Это зависит от настроек маршрутизаторов, находящихся между клиентом с сервером.

#### Сетевые порты

Порты используются как протоколом TCP, так и протоколом UDP.

Как же операционные системы будут различать все входящие и исходящие потоки данных, передаваемые одновременно? То есть как именно клиенту указать, что он отправляет запрос приложению веб-сервера, а не приложению почтового сервера, учитывая, что оба находятся на одном удалённом узле?
Это выполняется с помощью так называемых **сетевых портов**.

При запуске сетевое серверное приложение (например, веб-сервер) открывает порт и начинает прослушивать его. 
Представьте, что у аппаратного сервера есть IP-адрес 1.2.3.4 и приложение веб-сервера прослушивает порт 80.
Одновременно на этом же аппаратном сервере может работать приложение сервера электронной почты, использующее порт 25 для принятия входящих запросов.
Это означает, что если клиент хочет получить веб-страницу, то он должен отправить запрос на порт 80, но если он хочет отправить электронное письмо, то он должен направить его на порт 25.

Когда клиент обменивается данными с сервером, порт также открыт и на стороне клиента; этот порт используется приложением клиента, для взаимодействия с удалённым сервером.
Каждое соединение будет представлено уникальным кортежем значений: {transport_protocol, client_IP, client_port, server_IP, server_port} (транспортный_протокол, IP_клиента, порт_клиента, IP_сервера, порт_сервера). Это позволяет операционной системе (ОС) клиента различать соединения разных программ, обменивающихся данными с разными удалёнными серверами.
Итак, узел клиента работает с несколькими серверами одновременно.

Более того, один и тот же узел клиента может работать с одним и тем же приложением сервера (например, 1.2.3.4:80), используя одновременно несколько приложений (например, вы можете запрашивать страницы одного и того же веб-сайта с помощью браузеров Firefox, Safari, Chrome, Opera), — для каждого соединения будет использоваться свой порт клиента, поэтому потоки данных не перепутаются.

Для каждого протокола, TCP и UDP, доступно по 65 536 портов. То есть невозможно одновременно прослушивать больше 65 536 портов на одном аппаратном сервере.

### TCP — протокол управления передачей

Процесс передачи любых данных непредсказуем даже в современных сетях с широкополосными каналами. Этому есть несколько причин:
* Любой пакет может быть повреждён из-за ошибок в сетевых устройствах (транзитных узлах), расположенных где-то между клиентом и сервером.
* Пакет может потеряться из-за отказов сети.
* Пакеты могут оказаться продублированными из-за ошибок в транзитных узлах и (или) конечных точках (на стороне как клиентов, так и серверов).
* Пакеты могут маршрутизироваться по отдельности, поэтому они могут достичь узла назначения в произвольном порядке.
* У каждой конечной точки (клиента и сервера) может быть различная пропускная способность и производительность. Поэтому одна сторона может перегрузить другую, сетевая подсистема которой более медленная.

Все эти факторы особенно опасны для критических сетевых приложений.

Для решения этих проблем был создан протокол TCP. Он выполняет следующие очень важные функции:
* Управление очерёдностью данных. На стороне получателя пакеты собираются воедино в том же порядке, в котором они были отправлены.
* Повторная отправка потерянных пакетов. Если получение пакета не подтверждено любой из сторон, этот пакет запрашивается снова.
* Управление потоком. Если одна конечная точка отправляет данные быстрее, чем вторая способна обрабатывать, то более медленная сторона может запросить снижение скорости отправки.

Все эти функции реализуются с помощью **заголовков** TCP. Размер заголовка TCP колеблется между 20 и 40 байтами, это не так мало, учитывая максимальный размер пакета (1500 байт в большинстве случаев), но такие дополнительные накладные расходы позволяют достичь хорошего уровня надёжности.  
Некоторые функции протокола TCP реализованы с помощью так называемых **флагов**, представляющих собой специальные данные в заголовке TCP.

Важная часть протокола TCP — это **соединение**.  
По протоколу TCP данные можно отправлять только после установки соединения между клиентом и сервером. Процедура установки соединения называется **рукопожатием TCP (TCP handshake)**:
* Клиент отправляет серверу специальный пакет с установленным флагом SYN (synchronization — синхронизация). 
* Сервер получает этот пакет и отправляет ответ с установленными флагами SYN и ACK (acknowledgement — подтверждение).
* Клиент отправляет пакет с установленным флагом ACK.
* После этого соединение считается установленным и обе стороны могут отправлять запросы и ответы.

Если одна из сторон хочет **завершить соединение** (это может быть как клиент, так и сервер), то выполняется очень похожая процедура, называемая закрытием связи или завершением соединения (**TCP teardown** от англ. teardown — демонтаж, разрушение, разборка, освобождение канала). 
* Инициирующая сторона отправляет пакет с флагом FIN (finish — завершать; окончание).
* Вторая сторона отвечает пакетом с флагом ACK и затем ещё одним пакетом с флагом FIN — они могут быть объединены в один пакет FIN+ACK.
* Инициирующая сторона отправляет подтверждение с флагом ACK.

Протокол TCP обычно используется как основа для обмена данными между сетевыми приложениями, которым необходим строгий порядок отправки и получения данных и гарантия доставки. Примеры таких приложений:
* Электронная почта
* Торговля через Интернет и банковские приложения
* Базы данных
* Веб-сервисы

**Поля** пакета ТСР:
* Source Port (порт источника). Программы, которые вы используете для передачи данных, не могут устанавливать соединения самостоятельно. Вместо этого они просят операционную систему: «Мне нужно установить соединение TCP с узлом 1.2.3.4, порт 123». В ответ ОС резервирует локальный порт со случайным номером, связанным с IP-адресом, который будет использоваться для установки соединения. Затем ОС затем создаёт специальную конструкцию, называемую сокетом — специальный программный интерфейс, который ассоциирует адрес памяти вашего компьютера с ссылкой на этот порт. Далее, когда приложение хочет отправить некоторые данные этому удалённому узлу и порту, оно просто использует сокет, не заботясь о процессе передачи данных.
* Destination Port (порт получателя).
* Sequence number (порядковый номер), используемое для нумерации пакетов. У каждого пакета есть свой номер.
* Acknowledgment number (номер подтверждения). Узел должен отправлять подтверждение для каждого полученного пакета.
* Window (окно) - с помощью этого поля получатель может ограничивать объём входящих данных от отправителя.
* Flags (флаги) используется для добавления в пакет специальных меток.

**Рукопожатие TCP**  
Алгоритм следующий:

1. В самом начале у нас есть клиент без каких-либо соединений и связанных с ними состояний, и сервер в состоянии LISTEN (прослушивание), которое означает, что сервер ждёт запроса на установку соединение. Если клиент попытается соединиться с портом, который никто не прослушивает, то он получит пакет с флагом RST (reset — сброс).
2. Клиент генерирует случайный номер (X) и отправляет его серверу в специальном пакете с меткой SYN, помещённой в поле флагов. SYN означает «синхронизация». Теперь соединение находится в состоянии SYN-SENT (SYN отправлен).
3. Сервер получает от клиента пакет SYN и формирует пакет с подтверждением, копируя в поле номера подтверждения значение X + 1. Также сервер устанавливает в своём пакете флаг SYN и записывает свой случайный номер (Y), а затем отправляет пакет клиенту. Теперь соединение находится в состоянии SYN-RECEIVED (SYN получен).
4. Клиент получает от сервера пакет SYN+ACK и отправляет обратно пакет с флагом ACK и номером Y + 1. Дело сделано. Теперь у нас есть соединение в состоянии ESTABLISHED (установлено).

Теперь обе стороны знают, что между ними установлена связь, и могут отправлять полезные данные (поскольку до установки соединения полезные данные отправить не получится). Обмен данными происходит тем же образом (но без пакетов SYN): при отправке пакетов узлы просто увеличивают на единицу свои порядковые номера и отправляют подтверждения для полученных пакетов.

**Закрытие соединения**
Однако всё когда-то подходит к концу, включая соединение TCP. Первый способ закрыть соединение TCP — это просто перестать отвечать. Удалённый узел выждет определённый период (время ожидания, настроенное в операционной системе) и удалит информацию об этом соединении из памяти. Это произойдёт, например, в случае перезагрузки одного из узлов. Хороший способ «попрощаться» в рамках протокола TCP похож на процесс установки соединения:

1. Вначале узел отправляет пакет с флагом FIN.
2. Второй узел отправляет первому подтверждение.
3. Второй узел отправляет свой пакет с флагом FIN.
4. Первый узел отправляет последний пакет с флагом ACK.

### UDP — протокол пользовательских датаграмм

Этот протокол работает с высокой скоростью и требует меньше вычислительных ресурсов. При инкапсуляции протокол UDP добавляет в пакет IP минимум информации. Но это единственная хорошая новость, поскольку протокол UDP не предусматривает упорядочивание пакетов, подтверждение получения данных и управление скоростью потока. UDP не использует соединение: нет ни «рукопожатия», ни вежливого «прощания», только передача данных от одной точки к другой.

Заголовок включает только восемь байт с четырьмя двухбайтовыми полями.

 Полезно применять протокол UDP в случае потоковой передачи мультимедиа, голосовой связи (VoIP), преобразования доменных имён в системе DNS и онлайн-игр. Во всех этих случаях просто нет времени на повторную отправку повреждённых данных. К моменту повторной отправки эти данные уже утратят актуальность.
 
### Сокеты и сетевые порты

Для протоколов транспортного уровня каждое соединение можно описать с помощью уникального кортежа {transport_protocol, client_IP, client_port, server_IP, server_port} (транспортный_протокол, IP_клиента, порт_клиента, IP_сервера, порт_сервера).  
Именно так **сокеты** представлены и идентифицируются в операционной системе.

`netstat -pnt` - вывод информации о сокетах (Linux)

`-n` отображение портов и адресов узлов в виде чисел и IP-адресов соответственно. Рекомендуется ее применять. Если эту опцию упустить, то вместо чисел будут показываться имена служб (из файла /etc/services) и имена узлов, что очень неудобно, поэтому если вам нужны номера портов, то используйте опцию -n.
`-t` отображение портов TCP.
`-u` отображение портов UDP; может сочетаться с -t.
`-l` отображение только прослушиваемых портов. Если эту опцию упустить, то будут отображаться только активные соединения (а не прослушиваемые порты).
`-a` отображение как прослушиваемых портов, так и активных соединений.
`-p` отобразить процессы, открывшие эти порты и соединения; показывается ограниченный объём информации, если вы не являетесь пользователем root.

`ss` - - вывод информации о сокетах (Linux). Опции те же, что и у netstat

У одного процесса может быть много сокетов.  
Каждый сокет может быть связан с одним и только одним локальным IP-адресом и одним локальным портом (и с одним внешним IP-адресом и внешним портом, если говорить об активных соединениях). 
Если приложение хочет создать прослушиваемый порт (например, 22) с использованием определённого протокола (например, TCP), этот порт должен быть свободен. В противном случае, ОС отправит сообщение об ошибке и прервёт эту попытку.

Если порт сервера не прослушивается ни одним процессом, то он называется закрытым портом (то есть он свободен). Такие порты не показаны в выводе программы netstat.

Если клиентское приложение попытается соединиться с закрытым портом, то ответ сервера будет зависеть от протокола:
* TCP: сервер отправит пакет с установленным флагом RST, означающим, что это соединение было сброшено из-за сбоя.
* UDP: для этого протокола флаги наподобие RST не предусмотрены. Вместо пакета с таким флагом сервер отправить сообщение ICMP, говорящее клиенту, что этот порт никто не прослушивает.

Когда клиентское приложение соединяется с сервером, серверное приложение (прослушивающее соответствующий порт) открывает активный сокет для обработки запроса. В то же время прослушиваемый сокет не затрагивается и остаётся готовым для новых соединений с другими клиентами.
 
 ### Анализаторы сетевого трафика
 
 Чтобы заглянуть внутрь сетевых пакетов, проще всего использовать анализаторы сетевого трафика (известные также как «снифферы», от англ. sniff — нюхать). Это специальные программы, собирающие необработанные данные на сетевых интерфейсах узла, на котором они запущены, и представляющие эти данные в формате, удобном для человека. Самые популярные анализаторы — tcpdump и Wireshark.
 
 #### tcpdump
 
 `tcpdump <options> <expression>`
 
 **Опции для сбора пакетов**:  
 `-c <N>` (например, -c 20): собрать первые N пакетов и выйти. По умолчанию, "tcpdump" работает до остановки нажатием Ctrl+C (на самом деле эта комбинация клавиш отправляет сигнал SIGINT).  
`-i <interface_name>` (название интерфейса): с помощью этой опции можно указать сетевой интерфейс, например lo или eth0; по умолчанию берётся первый интерфейс, не являющийся "lo". Для сбора пакетов со всех интерфейсов нужно указать следующее: `-i any`.  
`-s <N>`: установка захватываемой длины пакета. -s 0 — для сбора полных пакетов; -s60 — для сбора только первых 60 байт каждого пакета.  
`-w <file>` (файл): сохранять поток собранных данных в файле формата PCAP (специальный формат файлов для хранения необработанных сетевых данных) вместо вывода на терминал.  
`-r <file>` (файл): считывать пакеты из файла PCAP, а не из сетевых интерфейсов. Опция полезна для глубокого исследования сетевого потока, например, когда вы изучаете сетевые неисправности.  

**Опции для отображения**:  
`-n`: не преобразовывать IP-адреса в имена узлов.  
`-nn`: показывать адреса узлов в виде IP-адресов, а порты в виде номеров. Эту опцию рекомендуется использовать в большинстве случаев.  
`-X`: вывод необработанного содержимого пакетов, представленного как шестнадцатеричной формой, так и форматом, удобным для человека (символы ASCII). Очень полезна для более тщательного анализа содержимого пакетов при изучении неисправностей.  
`-A`: вывод необработанного содержимого пакетов в компактном формате без шестнадцатеричной части. Если не указаны -X, и -A, то в формате, удобном для человека, отображаются только заголовки.  
`-ttt`: вместо полной временной метки выводить прирост времени с момента предыдущего элемента.  
`-v / -vv / -vvv`: три степени подробности.  

**Выражения (фильтры)**  
Все эти элементы можно сочетать с помощью ключевых слов or (или), and (и), not (не), а также с помощью скобок. Если применяются скобки, то выражение необходимо заключать в кавычки, например: "(tcp or icmp)", а не (tcp or icmp). Можно применять как двойные, так и одинарные кавычки.

|Синтаксис|Значения|Примеры выражений (фильтров)|Пояснение|
|---------|--------|----------------------------|---------|
|host X|Только трафик, исходящий от узла X или предназначающийся ему. Это двунаправленное условие, поэтому собираются как запросы клиентов, так и ответы серверов|`host example.com`<br> `host 8.8.8.8`|Весь поток пакетов между данным узлом (на котором установлена программа tcpdump) и удалённым узлом example.com.<br>То же для узла 8.8.8.8|
|net X/Y|Подобно host, но собирается поток данных для всех узлов этой сети. X — адрес сети, Y — маска подсети|`net 8.8.0.0/16`|Весь поток пакетов, проходящий между данным узлом и любым узлом сети 8.8.0.0/16|
|tcp / udp / icmp|Название протокола, поток которого будет собираться|`tcp and port 8080` `udp and not port 53` `icmp`|Пакеты TCP, исходящие из порта 8080 или предназначающиеся ему.<br> Пакеты UDP, исходящие из любого порта или предназначающиеся любому порту кроме 53.<br>Все пакеты протокола ICMP|
|port X|Номер порта протокола TCP или UDP. Не применимо к ICMP, так как в рамках этого протокола порты не используются|	`"tcp and (port 22 or port 3389)"` `port 53`|Пакеты TCP, исходящие из порта 22 или 3389 или предназначающиеся им.<br>Пакеты TCP и UDP, исходящие из порта 53 или предназначающиеся ему|
|src|Применимо к ключевым словам host, net, port, portrange. Означает поток данных, исходящий от этого источника: узла, сети, порта или диапазона портов (portrange)|`tcp and src host 192.168.40.150 and src port 22`|Пакеты TCP, исходящие от узла 192.168.40.150 и с портом источника 22. Это входящий поток данных протокола SSH от узла 192.168.40.150, этот узел выполняет роль сервера SSH.|
|dst|Подобно src, но означает поток данных, идущий к указанному узлу, сети, порту, диапазону портов|`udp and dst host 8.8.8.8 and dst port 53`|Запросы клиента «резолверу» DNS с IP-адресом 8.8.8.8 (ответы сервера не будут собираться).|
|portrange X-Y|Сбор только пакетов протокола TCP или UDP с любым номером порта (исходящего и входящего) в диапазоне от X до Y|`tcp and src portrange 1-1023`|Все пакеты TCP, исходящие от портов с номерами от 1 до 1023|

#### Wireshark

Wireshark — это анализатор сетевых данных, созданный на основе той же библиотеки, что и tcpdump. Главным отличием Wireshark является графический интерфейс пользователя, поэтому с помощью этой программы намного проще визуализировать поток пакетов.  
Кроме непосредственного анализа трафика можно открывать файлы .pcap, созданные tcpdump.

Изображение похоже на вывод программы tcpdump. Каждая строка представляет один пакет, если речь о протоколах TCP и UDP. Также программа может автоматически определять сообщения протоколов прикладного уровня.

**Фильтр пакетов**:
* Фильтрацию по адресу можно настроить с помощью конструкций ip.host, ip.src_host или ip.dst_host. Обратите внимание, что Wireshark не преобразует имена узлов в IP-адреса, это нужно делать вручную.
* ip.addr используется для фильтрации по адресу подсети.
* Для фильтрации по порту используйте tcp.port или udp.port для двухсторонней фильтрации и tcp.srcport, udp.srcport, tcp.dstport, udp.dstport для односторонней фильтрации.
* Wireshark поддерживает фильтрацию по названию протокола, например tcp, udp, http, dns, ssh и т. д.
* Как и в tcpdump, в фильтрах можно сочетать различные конструкции. Например:
	* `ip.host == 93.184.216.34 and http`
	* `ip.addr == 192.168.0.0/24 and tcp.port == 80 and not http`
	* `ip.host == 8.8.8.8 and (udp.port == 53 or tcp.port == 53)`

Нажатие на кнопку с изображением плавника акулы запустит сбор данных из сетевых интерфейсов компьютера.

## Поиск сетевых неисправностей

### Проблемы, возможные на сетевом уровне

#### ICMP — Internet Control Message Protocol

ICMP — протоколом, специально разработанный для поиска сетевых неисправностей

Хотя ICMP является протоколом транспортного уровня (поскольку он непосредственно инкапсулируется в пакеты IP), с его помощью приложения не передают какие-либо данные. Единственное, для чего он служит, это пересылка сообщений о состоянии узлов и сетевых проблемах от одного узла к другому.

У пакета ICMP структура из четырёх полей: тип сообщения (Type), код подтипа (Code), контрольная сумма (Checksum) и основное содержимое (Content).

Есть несколько часто используемых типов сообщений протокола ICMP, которые указываются с помощью полей Type и Code заголовка:
* **Echo Request (Эхо-запрос) и Echo Reply (Эхо-ответ)**. Эти типы используются утилитой ping, а также программой traceroute в режиме ICMP.
* **Destination Unreachable (Адресат недостижим)**. Используя этот тип сообщения, шлюзы уведомляют, что они не могут достичь узла назначения текущего IP-пакета. Также в некоторых случаях удалённый узел может отправить сообщение **Destination port unreachable** (Порт назначения недостижим) в ответ на попытку подключения по протоколу UDP к закрытому порту (так как у самого UDP нет способа реакции на такое событие).
* **Time Exceeded (Время истекло)**. Если на шлюз пришел пакетом с нулевым полем TTL в заголовке IP (Time to live — время существования, то есть количество промежуточных узлов, до исчерпания которого пакет существует в сети, а затем отбрасывается маршрутизатором), то он пошлёт отправителю сообщение «Время истекло». Именно на основе этого принципа работает утилита traceroute.

Поле Content — по большей части ничего не значащая последовательность байт, используемая в большинстве случаев просто в качестве заполнителя, поле Checksum — контрольная сумма, вычисляемая для поля Content.

#### ping

Программа ping — это самое распространённое средство применения протокола ICMP. Она выполняет две очень простые, но очень важные функции: 
* Проверка достижимости удалённого узла.
* Измерение времени, потраченного на передачу и подтверждение пакета (параметр RTT, round-trip time — время кругового пути), то есть суммарного времени для передачи пакета от клиента серверу и обратно.

Программа работает следующим образом: удалённому узлу отправляется эхо-запрос протокола ICMP; если удалённый узел настроен надлежащим образом, то он отправит пакет с эхо-ответом протокола ICMP. Параметр RTT равен интервалу между отправкой запроса и получением ответа.

`ping [options] <remote_host>`

`-c <N>` остановиться после N пакетов  
`-s <N>` отправлять пакеты размером N байт  
`-t <N>` установить значение поля TTL IP-пакета в N

```
# Проверить связь с узлом (нажмите Ctrl-C, чтобы остановить работу программы):
ping example.com

# Выполнить Ping для десяти пакетов и выйти:
ping -c 10 example.com

# Проверить связь с помощью высокой загрузки сети (не использовать для внешних узлов, это может быть расценено как атака!):
sudo ping -A -s 65000 192.168.100.1

# Получить IP-адрес шлюза, используемого по умолчанию: при значении TTL = 1 пакет будет отброшен ближайшим промежуточным узлом (то есть вашим шлюзом, используемым по умолчанию) с отправкой сообщения «Время истекло»
ping -t 1 example.com
```

#### Проблемы с маршрутизацией и узлами, отключенными от сети

С точки зрения маршрутизации и доступности узлов может возникнуть три основных проблемы:
1. Вы пытаетесь связаться с узлом, для которого нет ни одного правила в вашей таблице маршрутизации, и в ваших настройках не указан маршрутизатор, используемый по умолчанию. В таком случае вы получите от операционной системы (ОС) сообщение **"No route to host" ("нет маршрута к узлу)"**.
2. В ваших настройках указан маршрут, используемый по умолчанию, но маршрутизатор не знает, что делать с вашим пакетом IP. Например, когда вы пытаетесь связаться с узлом из другой частной подсети, а у вашего маршрутизатора нет маршрута к ней. В таком случае вы получите сообщение ICMP  **"Destination host unreachable" («Узел назначения недостижим»)**.
Примечание: такое же сообщение вы можете получить при попытке связаться с несуществующим в вашей локальной сети узлом.
3. Узел назначения может быть просто не в сети (отсоединён от сети, выключен…) и поэтому не способным на какое-либо сетевое взаимодействие. Сообщение **"Destination host unreachable" («Узел назначения недостижим»)** будет отправляться маршрутизатором, ближним к этому узлу.

Если ICMP на сервере заблокирован, можно проверить, что сервер в сети через доступность порта командой:  
`nc -vz mx1.ptsecurity.com 25`

#### Проблемы с системой DNS

Наиболее очевидная проблема с системой DNS связана с преобразованием имени FQDN (Fully Qualified Domain Name — полностью определённое имя домена) в IP-адрес.

Возможные причины:
* Опечатка в имени узла или такое имя узла просто не существует. 
* Доменное имя существует, но у него нет соответствующего IP-адреса. Например, когда вы пытаетесь подключиться к недавно созданному доменному имени, сведения о котором ещё не распространились по всем ответственным серверам DNS.
Примечание: доменное имя можно купить (т. е. зарегистрировать), но при этом не настроить доменную зону - таким образом, ни само доменное имя, ни любой из его поддоменов не смогут преобразоваться в IP-адрес. Чтобы определить, существует ли определённое доменное имя, и найти соответствующую контактную информацию, можно использовать инструмент командной строки `whois` в ОС Linux и macOS или сайты, похожие по назначению на "whois".
* На клиентском узле неправильно настроены сведения, касающиеся «резолверов». Если вы работаете на ОС Linux, посмотрите настройки в файле /etc/resolv.conf и проверьте, все ли указанные «резолверы» DNS настроены корректно.
* Что-то не так с вашим «резолвером». Если вы пытаетесь преобразовать общедоступное имя узла, попробуйте использовать один из публичных «резолверов» (8.8.8.8, например):   
`host badhostname.com 8.8.8.8`
`dig badhostname.com @8.8.8.8`

#### Потеря пакетов

Признаком этой проблемы обычно является следующее: слишком медленное соединение; передача данных застопорилась; и порой даже неожиданные сбросы соединения TCP.

Эта проблема тесно связана с уровнем протокола IP, но обычно становится видна на транспортном или прикладном уровне, когда сетевое приложение начинает медленно работать или даже показывать ошибки.

Самая распространённая причина — перегрузка интерфейса одного из узлов (включая шлюзы) или проблемы с физическим каналом.

Диагностика:
1. Выполните проверку связи с удалённым узлом с помощью пакетов размером примерно 1 КБ и опции "-s" и посмотрите статистику. Если показана значительная (например, > 5 %) доля потерянных пакетов, значит, дело может быть именно в потере пакетов.
2. Создайте файл PCAP с образцом потока пакетов между клиентом и удалёнными узлами, используя программу tcpdump с фильтрами для узлов и портов. Если есть такая возможность, выполните то же самое на узле назначения.
3. Откройте сохранённый файл в программе Wireshark и поищите красные и (или) чёрные метки.

`ping -s1024 -c8 192.168.40.100`

### Проблемы транспортного уровня

#### Открытые и закрытые порты

Что касается проблем с протоколами TCP и UDP, то самым часто возникающим вопросом является: «Открыты порты или нет?» Для удалённой проверки можно использовать две утилиты: **nc** и **nmap**

**nc**

Если у вас нет доступа к удалённому узлу (т. е. вы не можете подключиться к нему посредством сессии SSH), но вы хотите проверить, открыт ли определённый порт TCP, то просто запустите следующее:  
```
# Проверить только один порт
# используйте опцию "-z" для проверки доступности порта
# используйте опцию "-v" для получения подробного вывода (т.е. будут показаны и неудачные попытки)

nc -vz server_address port

# Чтобы проверить диапазон портов, например, от 1000 до 2000
# Здесь мы не используем опцию "-v" для подавления массового сообщения о неудачных попытках

nc -z server_address 1000-2000
```

**nmap**

nmap может выполнять только одну функцию — сканировать открытые порты с целью сбора информации о сети (это часто делается непосредственно перед атакой) и определять работающие на этих портах службы.

Помните о следующем:
* Никогда не сканируйте чужой компьютер, если только вы не являетесь аудитором безопасности, нанятым специально для такой работы.
* Если вы хотите нарушить пункт 1, то делайте это настолько мягко, насколько можете (т. е. без высокой интенсивности, не все 2 * 65 536 портов для TCP и UDP за раз и т. д.).
* НИКОГДА не пытайтесь проделать это с органами власти, большими компаниями и узлами критической инфраструктуры (больницы, промышленность…)!

Все встречающиеся далее параметры «адрес_узла» ("host_address") можно заменить полным диапазоном сети, указав «адрес_сети/маска_подсети» ("network_address/netmask"):
* Для сканирования портов TCP в диапазоне от A до B на определённом узле, аналогично программе nc (т. е. с установкой соединения TCP посредством «рукопожатия»). Опция -sT означает режим сканирования — «рукопожатие TCP»:  
`nmap -sT -pA-B адрес_узла`
* То же самое, но намного быстрее (посредством отправки только пакетов TCP SYN, без установки соединения); требуются права пользователя root. -sS означает режим сканирования — SYN:  
`sudo nmap -sS pA-B адрес_узла`
* Для сканирования портов UDP; эта операция по сути своей намного медленнее, даже чем режим с опцией -sT. -sU означает режим сканирования — UDP. Также нужны права root:  
`sudo nmap -sU pA-B адрес_узла`
* Для поиска доступных в сети узлов,-sP означает режим сканирования — ping (хотя, на самое деле, сам ping для сканирования используется не всегда, в локальных сетях вместо этого применяется протокол ARP):  
`nmap -sP адрес_сети/маска_подсети`

#### Connection refused

Ошибка “Connection refused” ("в подключении отказано") обычно возникает при попытке соединения с закрытым портом. Как правило, такое происходит в случае остановки сетевого приложения на удаленном сервере, которое должно было прослушивать порт назначения, или в случае указания неверного порта, или из-за межсетевого экрана.

Если речь о протоколе TCP, то в сетевом потоке вы увидите пакет **RST**.  
В протоколе UDP механизм сообщения о закрытых портах не предусмотрен. Но, как сказано в стандарте протокола ICMP, вы можете (но это не обязательно) получить сообщение ICMP «Порт назначения недостижим» от удалённой операционной системы.

#### Connection timeout

Ошибка "Connection timeout" обычно возникает при попытке соединиться с недоступным удалённым узлом (и отсутствии ответа на ваш пакет SYN) или при блокировании порта назначения со стороны межсетевого экрана.

Эти случаи различны по сути, поэтому, чтобы найти верную причину, выполните следующее:
1. Определите, находится ли этот удалённый узел в сети с помощью других способов, например следующих:
	* ping / traceroute с использованием протокола ICMP.
	* nc -z с использованием других (возможно, открытых) портов.
	* nmap со сканированием диапазона портов (только если у вас есть на это разрешение).
2. Если узел обнаружен в сети, но не отвечает на определённые запросы и вы получаете сообщения об ошибке «Время ожидания подключения истекло», значит, этот порт и (или) протокол блокируются межсетевым экраном.
3. Это также можно проверить с помощью программы tcpdump. Если ваш узел-клиент отправляет запросы и не получает никаких ответов от узла-сервера (но при этом сервер в сети), это также явное свидетельство работы межсетевого экрана.

#### Конфликты портов

Один порт TCP (и UDP тоже) не может прослушиваться одновременно двумя приложениями.  
При запуске приложения, работающего с портом, который уже используется другим приложением, вы получите ошибку «Address already in use» (адрес уже используется).

`netstat -ntlp` - открытые порты и процессы, которые с ними работают

Открытие портов TCP и UDP с номерами меньше 1024 разрешено только пользователю root. Если процесс, запущенный от имени простого пользователя, попытается открыть один из таких портов, то получит ошибку «Permission denied» (в доступе отказано).

### Проблемы прикладного уровня

Главная причина проблем, связанных с прикладным уровнем, заключается в том, что у похожих программных продуктов могут быть отличающиеся реализации протоколов.

Пример: HTTP CRLF

В официальном описании протокола HTTP(opens in a new tab) говорится следующее:
* Каждая строка в запросе клиента должна заканчиваться символами CRLF.
* Но лучше, если серверное приложение также сможет работать и с одним символом LF на конце строки.

### Основы работы межсетевых экранов

**Межсетевой экран** — это программное обеспечение или сетевое устройство, блокирующее или пропускающее определённые сетевые пакеты согласно настроенным правилам. Межсетевые экраны могут быть реализованы в следующих вариантах:
* Программное обеспечение, установленное на клиентских или серверных узлах. То есть это ПО может быть установлено на любом узле (независимо от ОС), участвующем в сетевом взаимодействии любого типа (клиенты, серверы, маршрутизаторы).
* Аппаратное обеспечение, такое как сетевые устройства, специально разработанные для обеспечения безопасности. Их часто можно встретить в сетях крупных организаций.

Независимо от вида реализации, у межсетевых экранов могут быть следующие состояния и правила:
* **Отключён**. Часто встречается на клиентских компьютерах. Например, на узлах, работающих на ОС Windows, могут присутствовать отключённые межсетевые экраны.
* **Включён с правилами по умолчанию**, означающими разрешение всего трафика и блокировку только явно указанного. Такую конфигурацию часто можно встретить на клиентских узлах, серверах и сетевом оборудовании во внутренних сетях компаний.
* **Включён с правилами по умолчанию**, означающими блокировку всего трафика и разрешение только явно указанных пакетов. Такая конфигурация типична для корпоративного окружения, которому характерны высокие требования к безопасности, и для серверов, доступных из глобальной сети Интернет, которым нужна защита от атак злоумышленников.

Типичное правило (т. е. разрешение или ограничение) межсетевого экрана содержит следующие элементы:

Описание пакетов, в которое могут входить следующие сведения:
* IP-адрес(а) назначения и (или) источника.
* протокол транспортного уровня.
* номер(а) порта(ов) назначения и (или) источника.
* сетевой интерфейс, используемый в ходе этого сетевого взаимодействия.  
Действия для этих пакетов, например, следующие:
* Блокировать (block) (также могут использоваться термины: отбросить (drop), запретить (deny) и т. п.). Соответствующие пакеты молча отбрасываются так, что ни клиент, ни сервер не узнают о блокировке.
* Разрешить (allow) (также могут использоваться термины: принимать (accept), пропустить (pass) и т. п.).
* В некоторых случаях: выполнить ещё что-либо, согласно функциям межсетевого экрана. Например, в межсетевом экране ОС Linux предусмотрено также действие REJECT (отклонить), означающее отбрасывание входящих пакетов и имитацию закрытого порта назначения.

#### Nmap, состояния портов и межсетевые экраны

* "open" (открытый): порт доступен для клиентов и не заблокирован межсетевым экраном. На серверной стороне этот порт прослушивается неким приложением.
* "closed" (закрытый): порт доступен для клиентов и не заблокирован межсетевым экраном, но этот порт не прослушивается ни одним приложением.
* "filtered" (фильтруется): порт заблокирован межсетевым экраном, все пакеты, отправленные на этот порт, были отброшены; неизвестно, прослушивается ли этот порт каким-либо приложением

Если в вашем рабочем окружении нет возможности использовать nc или nmap, то могут помочь анализаторы сетевых пакетов, наподобие tcpdump. Если мы видим серию пакетов TCP SYN (отмеченных буквой «S», означающей флаг SYN), отправленных на удалённый сервер от клиента во время запуска программы nc, но ответов сервера не наблюдается, Скорее всего, это означает, что этот порт скрыт за межсетевым экраном.

