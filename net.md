# Сети

## Основные понятия сетей

### Модель клиент-сервер

Большая часть данных в Интернете передается между двумя узлами. Первый узел — это программа, которая хочет получить данные, называемая "клиент". В нашем примере клиентом является веб-браузер. Когда вы открываете веб-сайт, браузер пытается подключиться к этому сайту и запросить данные.

Второй узел — это сервер, программа, обрабатывающая ваш запрос (здесь и далее в этой главе под сервером мы понимаем программу, а не специальный компьютер, отличающийся от вашего ноутбука или настолького ПК).

Отправка запроса из терминала:
```
nc example.com 80
GET / HTTP/1.1
Host: example.com
```

### Адреса и маршрутизация

Вы написали в адресной строке веб-браузера «example.com» и нажали Enter. Адрес example.com понятен людям, однако компьютерам ничего о нём не известно. Это просто удобное для людей доменное имя, которое для использования компьютером необходимо преобразовать в так называемый IP-адрес. Процесс преобразования одного адреса в другой называется **resolving** («разрешение»).

Этот процесс - "разрешение имени", или, если короче, resolving - работает следующим образом: ваша операционная система берет адрес DNS-сервера из своих сетевых настроек. Когда вы пытаетесь подключиться к ресурсу с определённым доменным именем, ОС отправляет серверу DNS специальный запрос: «отправь мне IP-адрес, соответствующий имени example.com». Получив запрос, сервер DNS ищет в очень большой таблице адрес для имени example.com и отправляет результат.

Теперь компьютер знает адрес ресурса с именем example.com.

Узнать IP-адрес:  
`host example.com` - Linux  
`nslookup example.com` - Windows

Статус DNS-сервера:  
`resolvectl status` - Linux  
`ipconfig /all` - Windows  

**IP-адрес** — это набор из четырёх чисел, разделённых точками. Каждое число (они называются октетами) должно быть между 0 и 255. Например: 127.0.0.1, 8.8.8.8 или 192.168.0.1. Вы можете воспринимать его как почтовый индекс, необходимый для отправки посылки определённому человеку. IP-адрес есть у всех устройств, подключённых к современным сетям.

Чтобы установить соединение с удаленным узлом, нужно знать еще одно число, называемое **номером порта**. Если IP-адрес — это почтовый индекс здания, то порт — это дверь с определённым номером в этом здании. В большинстве случаев каждый номер порта используется только для конкретной службы или протокола. Нам необходимо установить соединение HTTPS, поэтому будем использовать номер порта 443 (он используется для этого протокола по умолчанию, поэтому его не нужно будет указывать).

Итак, у нас есть адреса и номера портов, чтобы можно было отправить запрос.

Но есть одна маленькая проблема: мы не знаем, как добраться до сервера назначения, поскольку он может находиться где угодно, даже в другой стране или на другом континенте. На самом деле нам не нужно знать полный маршрут, так же как нам не нужно его знать, когда отправляем открытку другу. Нам необходимо лишь найти ближайший почтовый ящик.

Скорее всего, ваш компьютер уже подключен к локальной сети, и у вас уже есть  IP-адрес; кстати, IP расшифровывается как "Internet Protocol", т.е. "протокол межсетевого общения". Кроме того, если у вас дома есть роутер, то поздравляем — у вас уже есть собственная маленькая локальная сеть!

По сути, Интернет - не что иное, как огромное количество сетей, соединенных друг с другом. Как каждый компьютер, подключённый к Интернету, обладает IP-адресом, так и каждый IP-адрес является частью некой сети. У сетей тоже есть адреса, состоящие из двух частей, разделённых косой чертой: **адрес сети** (network address) и **маска подсети** (netmask).

Адрес сети выглядит абсолютно так же, как IP-адрес узла. А маска сети (или "подсети", могут применяться оба термина) — это просто число между 0 и 32, с помощью которого компьютер узнаёт размер сети и диапазон IP-адресов, доступных в ней.

Чем больше значение маски подсети, тем меньше размер подсети и тем меньше IP-адресов в ней.
Например, маска /24 соответствует 256-и IP-адресам, а /28 — только 16-и.

Также маску подсети можно записать в длинной форме. В этом случае она выглядит похожей на IP-адрес.
Например, /16 и 255.255.0.0 — это одна и та же маска подсети в короткой и длинной форме соответственно.

Операционная система применяет адреса сетей и их маски внутри очень важной таблицы, называемой **таблица маршрутизации** (routing table).
С помощью этой таблицы компьютер узнаёт, как подключиться к тому или иному адресу.

`ip route list` - таблица маршрутизации Linux  
`route -4 PRINT` - таблица маршрутизации Windows

Внутри каждой сети, подключенной к интернету (или просто к другим сетям, даже без выхода в Интернет), должен быть шлюз.  
**Шлюз** — это специальным образом сконфигурированный компьютер или сетевое устройство, подключённое к двум или более сетям и способное пересылать данные из одной сети в другую. Наиболее распространённым примером аппаратного сетевого шлюза является домашний роутер. IP-адрес шлюза указывается в настройках сети каждого подключенного к этой сети компьютера.

Таким образом, когда пользователь хочет установить соединение с любым другим узлом из внешних сетей, операционная система будет применять маршрут по умолчанию, чтобы отправить клиентский запрос через свой шлюз. Далее ближайший шлюз пересылает запрос другому шлюзу, тот в свою очередь — следующему и т. д. Каждый шлюз маршрута называют  **хоп**, или транзитный узел. Таким образом ваш запрос и достигает сервера example.com.

Получив запрос, сервер формирует ответ и отправляет его аналогичным способом.

Узнать IP-адрес, маску подсети:  
`ifconfig`  
`ip addr list` - Linux

`ipconfig` - Windows

Построение маршрута:  
`traceroute example.com` - Linux  
`tracert example.com` - Windows

### Физический уровень

В момент, когда данные уже готовы к передаче, клиентская ОС запрашивает сетевой адаптер для отправки этих данных по кабелю или беспроводному каналу. Сетевому адаптеру ничего не известно об IP-адресах, масках посети, шлюзе, используемом по умолчанию, и других программных сущностях, таких как ОС или предпочитаемый веб-браузер. Зато ему известен свой уникальный аппаратный адрес, называемый **MAC-адресом** (Media Access Control address — адрес управления доступом к среде передачи данных). MAC-адрес состоит из шести пар шестнадцатеричных символов, разделённых двоеточиями, например 46:09:9f:f5:87:aa.

К этому моменту уже известно, что узел example.com находится за пределами вашей сети, поэтому вам нужен шлюз (в данном случае это 10.8.0.1). Первым делом операционная система запросит сетевой адаптер отправить специальное широковещательное сообщение: «узел с IP 10.8.0.1, ответь, мне нужен твой MAC-адрес, чтобы пообщаться с тобой» (при этом 10.8.0.1 — адрес из нашей локальной сети). В случае успеха операционная система получит следующую информацию: «узел с IP-адресом 10.8.0.1 обладает MAC-адресом 46:09:9f:f5:87:aa», и запишет её в специальную таблицу. В этой таблице отображаются устройства, с которым ваш узел "общался" в пределах локальной сети.
Так работает протокол **ARP** (Address Resolution Protocol — протокол определения адресов).

На следующем шаге клиентская ОС запрашивает сетевой адаптер передать сообщение вида "Узел с MAC-адресом  46:09:9f:f5:87:aa, для тебя есть сообщение: [текст сообщения]". Операционная система роутера (внутри этой маленькой коробочки также есть ОС) поместит ваше сообщение в пакет программного уровня, прочтёт IP-адрес узла назначения, выберет нужный интерфейс для дальнейшей пересылки и отправит сообщение через физический уровень этого интерфейса.

**Сетевой адаптер** (также может применяться термин **сетевой интерфейс**) - физическое или виртуальное оборудование, предназначенное для приема-передачи сигналов по сети. Узлы и сетевые интерфейсы связаны как "один ко многим" (аналогично сущностям баз данных), например:

* Компактный ноутбук может иметь всего 1 встроенный физический сетевой интерфейс, это WiFi-адаптер
* Ноутбук большего размера как правило имеет 2 и более физических сетевых интерфейса, например один WiFi-адаптер и одну сетевую Ethernet-карту
* Cовременные смартфоны имеют как минимум 2 сетевых интерфейса (оба - беспроводные): один для передачи данных по мобильным сетям (4G или 5G), второй - WiFi-адаптер
* Маршрутизаторы как правило имеют 2 или более сетевых интерфейса для соединения с разными сетями и передачи данных между ними
* При установке VPN-соединения в системе появляется еще минимум 1 виртуальный сетевой интерфейс для обмена данными внутри VPN-соединения

Даже если у компьютера нет ни одного исправного физического сетевого интерфейса, все равно в системе присутствует минимум 1 виртуальный интерфейс, часто называемый loopback-интерфейсом или "интерфейсом обратной петли". Он нужен для взаимодействия клиентского и серверного ПО, запущенного на одном и том же узле.

Не бывает случаев, когда один и тот же сетевой интерфейс принадлежит нескольким разным узлам. Даже если на узле запущено несколько виртуальных машин, которые имеют доступ к одному и тому же физическому сетевому интерфейсу, каждая из виртуальных машин имеет свой собственный виртуальный сетевой интерфейс.

Как отмечалось выше, должна быть связь между сетевыми интерфейсами и IP-адресами. Эта связь также имеет тип "один ко многим"; примеры ниже указаны в порядке убывания вероятности встретить такие настройки:

1. Самый частый случай: 1 сетевой интерфейс имеет 1 IP-адрес. Чаще всего именно так и происходит, когда вы подключаете узел к локальной сети.
2. Один сетевой интерфейс не имеет ни одного настроенного IP-адреса. Пример: вы включаете ноутбук там, где нет никаких точек доступа WiFi.
3. Один сетевой интерфейс имеет несколько IP-адресов. Такие настройки могут быть встретиться на сетевых устройствах или серверах в специфических ситуациях.

Один и тот же IP-адрес НЕ может быть назначен нескольким сетевым интерфейсам в рамках одной сети.

Cодержимое ARP-таблицы вашего компьютера:
`arp -a -n` - Linux  
`arp /a` - Windows

## TCP/IP

**TCP/IP** — сетевая модель передачи данных, представленных в цифровом виде. Модель описывает способ передачи данных от источника информации к получателю.

Модель TCP/IP разделена на четыре уровня (иногда на пять; самый нижний уровень, физический):
1. **Прикладной уровень (Application Layer)**. Как следует из названия, это группа протоколов, служащих для взаимодействия между приложениями. Они используются каждый раз, когда пользователь запрашивает в сети какую-либо информацию с помощью приложения. Большая часть протоколов, работающих в рамках модели клиент-сервер, относится к прикладному уровню.
*HTTP*-протокол, упомянутый в предыдущем модуле, является наглядным примером прикладного протокола. Запрос клиента GET и ответ сервера с кодом 200 (успешное выполнение запроса), отправленные по протоколу HTTP 1.1 являются передачей данных приложения через сеть.
Протоколы прикладного уровня предназначены для запроса и передачи данных, то есть на этом уровне задаётся вопрос “***ЧТО*** должно быть отправлено и получено”.
2. **Транспортный уровень (Transport Layer)**. Для управления передачей данных необходимо добавить некоторую служебную информацию: номера портов, поле подтверждения доставки или специальные данные для управления скоростью передачи.
Вспомните практические упражнения и домашнее задание из предыдущего модуля, где для доступа к веб-серверу с сайтом example.com использовались программы nc и telnet. Такие числа, как 80 и 443, являются номерами портов. Эту служебную информацию необходимо добавить к данным приложения до их отправки другой стороне.
Самые распространённые протоколы транспортного уровня это *TCP* (Transmission Control Protocol — протокол управления передачей) и *UDP* (User Datagrams Protocol — протокол пользовательских датаграмм).
Протоколы транспортного уровня описывают ***КАК ИМЕННО*** запросы и ответы должны отправляться и приниматься: какой порт использовать, нужно ли проверять целостность данных и очерёдность пакетов, нужно ли повторно отправлять потерянные пакеты и т. д.
3. **Сетевой уровень (Network Layer)**. Предназначен для адресации и поиска узла назначения, а также для маршрутизации. В модели TCP/IP сетевой уровень представлен протоколом *IP* (Internet Protocol — межсетевой протокол). Как видно из названия, это вторая часть, необходимая для реализации модели. Этот уровень отвечает на вопрос, ***как клиентам и серверам найти друг друга***, даже если они расположены в различных несмежных сетях. Например, чтобы обеспечить доступ к серверу example.com из домашнего компьютера, задействуется протокол IP с элементами, необходимыми для маршрутизации.
4. **Уровень сетевого интерфейса** (Datalink Layer / Interface Layer, он же "канальный уровень", либо "уровень сетевого доступа"). Говоря о предыдущих уровнях, мы обсуждали программные сущности, но они не могут обойтись без физической передачи данных от одного компьютера к другому. Этот уровень служит интерфейсом между программным обеспечением (ПО) и физическими устройствами, например адаптерами для ***Ethernet, Wi-Fi, Bluetooth*** или модемами DSL.  Этот уровень также применяется для соединения устройств, находящихся в одной локальной сети, где используются аппаратные адреса без обращения к IP-адресам.
5. Иногда упоминается ещё один уровень — **физический уровень** (Physical Layer). Он располагается после уровня сетевого интерфейса и используется для  передачи данных по физической среде, например медному проводу, оптическому волокну или воздуху. На этом уровне нет программных протоколов, только физические сигналы.

Каждый уровень можно рассматривать независимо, например:
* Сетевые приложения, работающие на верхнем уровне, ничего не знают об интерфейсе или физическом уровне. Разработчики приложений не заботятся о том, передаются ли данные через Ethernet по медному проводу, через Wi-Fi или спутник.
* Программному обеспечению сетевого уровня (протокол IP) нет разницы, какие именно данные отправляет приложение на удалённый компьютер; главная задача этого уровня — проложить путь между клиентом и сервером.

Уровни модели TCP/IP связаны друг с другом посредством инкапсуляции, то есть помещения простых объектов в более сложные.  
Стек TCP/IP состоит из вложенных уровней, как матрёшка.  
Каждый уровень выполняет определённые задачи и включает в свой пакет все данные предыдущих уровней (как служебные заголовки, так и «полезную нагрузку»).

**Данные прикладного уровня** — это текст или двоичный код. В сущности, можно передавать любую информацию. Другая причина, почему прикладной уровень называется именно так, заключается в том, что только на этом уровне вы можете составлять данные самостоятельно, на всех остальных уровнях вам придётся просить об этом операционную систему (ОС).  

**Пакет TCP** — это определённая структура данных, состоящая из заголовка, в котором содержится служебная информация, необходимая для передачи данных, и полезной нагрузки — поле Data, т. е. данные.

Следующий уровень: **структура пакета IP**, в поле Data которого содержится пакет TCP вместе с прикладными данными.  
ОС поместит в поле Protocol (протокол) специальное число, говорящее получателю, что в поле Data лежит пакет TCP. Далее ОС помещает в поле Source address (адрес источника, отправителя) IP-адрес вашего компьютера, а в поле Destination address (адрес назначения, получателя) помещает IP-адрес удалённого узла. Весь пакет TCP будет помещён в поле Data. Ещё одно важное поле — TTL (Time to live — время существования). Оно содержит максимальное количество шлюзов, через которое может пройти пакет. Значение по умолчанию: 64 для Linux и macOS, 128 для современных версий Windows.

На **нижнем уровне** все предыдущие данные, помещённые в пакет IP, будут упакованы в поле Data кадра Ethernet (если используется именно Ethernet). Поле Destination address будет заполнено MAC-адресом узла назначения (или MAC-адресом шлюза, если таковой применяется), полученным с помощью протокола ARP. Аппаратный адрес вашего сетевого адаптера будет расположен в поле Source address. В поле CRC будет помещена контрольная сумма, необходимая для проверки того, что у отправителя и у получателя одинаковые копии данных.

## Основы IP-сетей

**IP** — это протокол сетевого уровня, реализующий две основные функции: адресацию и маршрутизацию.

### IP адресация

У каждого узла сети, построенной на основе протокола IPv4, есть специальный 32-битный IP-адрес, который используется для сетевого взаимодействия.  
**Маска подсети** - специальный параметр, описывающий размер сети, к которой подключён компьютер. Маску подсети можно указать в двух формах: число между 0 и 32 или формат IP-адреса. Например, маски подсети "24" и "255.255.255.0" эквивалентны. Применение пар «адрес-маска подсети», разделённых косой чертой (например, 192.168.0.0/24 или 192.168.0.0/255.255.255.0), также известно как **CIDR-адресация** (Classless Inter-Domain Routing — Бесклассовая междоменная маршрутизация).

С помощью побитовой операции между IP-адресом и маской компьютер вычисляет диапазон адресов подсети. Например, узел с IP-адресом 192.168.0.1 и маской подсети 24 является частью подсети 192.168.0.0/24, включающей 256 адресов от 192.168.0.0 до 192.168.0.255. Расчёты проводятся с помощью простой двоичной арифметики: 2 ^ (32 - 24) = 2 ^ 8 = 256.

`ipcalc` - двоичные операции с IP-адресами (Linux)

* Существует 33 варианта масок подсети (от 0 до 32), которые можно описать двумя равнозначными способами, "длинным" и "коротким".
* Значение маски обратно пропорционально размеру сети. Например, есть только один узел в сети с маской "32", 4 узла в сети с маской "30", 256 узлов в сети с маской "24".

### Маршрутизация

В основе IP-сетей лежит следующая идея: разделить адресное пространство на подсети, поместить узлы внутрь подсетей, а затем, при необходимости, обеспечить установку соединения между подсетями. Механизм взаимодействия между сетями называется маршрутизацией.  
Путь к узлу назначения операционная система выбирает, основываясь на таблицах маршрутизации.

Каждая строка **таблицы маршрутизации** содержит три основных объекта:

* **Адрес назначения** (первый элемент в строке), доступ к которому можно получить с помощью этой записи. Предусмотрено два варианта: адреса CIDR и default (по умолчанию). Последний вариант используется для связи со всеми узлами, которые не подходят под существующие правила маршрутизации. IP-адрес одного узла — это экземпляр адреса подсети (192.168.0.1 будет эквивалентен 192.168.0.1/32).

* **Устройство**. Если вы пытаетесь получить доступ к узлу назначения, располагающегося в одной из подсетей, подключённых к вашим интерфейсам, то шлюз вам не потребуется. В случае использования адреса шлюза нужный интерфейс будет определён автоматически с помощью маршрута к подсети шлюза.

* **Шлюз** — это узел, который будет использоваться для доступа к сетям, к которым вы не подключены напрямую. 

`ip route get 1.2.3.4` - получить соответствующее правило для узла назначения из таблицы маршрутизации (Linux)  
`traceroute 1.2.3.4` - покажет список транзитных узлов между вами и удалённым узлом.  
Эта команда отправляет узлу назначения специальные пакеты IP со значением поля TTL, начинающимся с 1 (увеличивая значение с каждым шагом на 1 до момента получения ответа от узла назначения). Благодаря такому значению промежуточные шлюзы отправляют обратно другой специальный пакет (об исчерпании поля TTL), таким образом обнаруживая себя (если это не отключено в настройках шлюза).  
`tracert` - Windows

### Откуда берутся IP-адреса

Пространство IP-адресов разделено на две части: частные и глобальные.  
**Частные области** были зарезервированы в документации межсетевого протокола (Internet Protocol — IP) как подсети для создания локальных сетей. Вот список зарезервированных для этого подсетей: 10.0.0.0/8, 172.16.0.0/12, 192.0.0.0/24 и 192.168.0.0/16. Эти сети не участвуют в глобальной маршрутизации, поэтому вы не сможете напрямую отправить пакет через Интернет в другую локальную сеть. Примечание: также есть специальная частная подсеть 127.0.0.0/8 (localhost).  
**Глобальные (также называемые публичными)** — это просто адреса, не принадлежащие зарезервированным областям. Если вам нужен публичный адрес, вы можете запросить его у вашего интернет-провайдера. В свою очередь провайдер, как и все компании, которым нужно большое количество IP-адресов, может получить их у специальных компаний, называемых брокерами IP-адресов, или у региональных интернет-регистраторов.

`whois` - получение сведений о владельце публичных подсетей (Linux)

Для назначения IP-адресов в локальных сетях обычно применяются два подхода:  
Большинство современных маршрутизаторов используют протокол **DHCP (Dynamic Host Configuration Protocol — протокол динамического конфигурирования узлов)** для автоматического назначения IP-адресов, адресов подсетей, маршрутов и адресов серверов DNS.  
Вы можете использовать **статическую конфигурацию**, полученную от вашего интернет-провайдера или системного администратора. Аналогичным образом, если вы не хотите по какой-либо причине использовать протокол DHCP, то в своей собственной сети, дома, например, вы можете назначать адреса вручную, используя одну из частных подсетей.

### NAT: преобразование сетевых адресов

Что же делает маршрутизатор для соединения вашего компьютера с Интернетом. Предположим, у нас есть адрес 10.0.0.2 в локальной сети 10.0.0.0/24. У нашего маршрутизатора есть два интерфейса с адресами 10.0.0.1 и 1.2.3.4. Мы хотим отправить запрос публичному серверу DNS с адресом 8.8.8.8.

Первым делом ваш компьютер на сетевом уровне упаковывает запрос в пакет IP с адресом назначения 8.8.8.8, ищет в таблице маршрутизации маршрут для адреса 8.8.8.8 и даёт понять, что пакет должен отправляться на маршрутизатор посредством его MAC-адреса. Маршрутизатор получает пакет. Анализируя пакет IP, понимает, что он не конечный получатель. В этот момент в игру и вступает механизм NAT (Network Address Translation — преобразование сетевых адресов). Следите внимательно:

Маршрутизатор ищет в своей таблице маршрутизации маршрут к узлу назначения. В нашем случае он выберет интерфейс с публичным адресом 1.2.3.4.
Маршрутизатор сохраняет у себя информацию, что он теперь является промежуточным узлом между 10.0.0.2 и 8.8.8.8.
Маршрутизатор изменяет адрес источника в вашем пакете IP: с 10.0.0.2 на публичный адрес 1.2.3.4.
Маршрутизатор уменьшает значение поля TTL в вашем пакете IP на единицу. Это поле не позволяет пакету бесконечно блуждать по сети в случае образования маршрутной петли (контура). Каждый последующий маршрутизатор выполнит те же действия. Пакет с обнулившимся полем TTL будет отброшен.

Удалённый сервер DNS с адресом 8.8.8.8 обработает запрос и отправит ответ в новом пакете IP маршрутизатору с адресом 1.2.3.4, так как он думает, что узел с адресом 1.2.3.4 и есть автор запроса.
Маршрутизатор получает пакет с ответом от узла с адресом 8.8.8.8, проверяет свой список соединений и определяет, что этот пакет предназначен узлу с адресом 10.0.0.2.
Маршрутизатор изменяет в пакете адрес назначения с 1.2.3.4 на 10.0.0.2 и отправляет пакет клиенту.

### Localhost

127.0.0.0/8.  
В реальности встречается множество случаев, когда вашему компьютеру нужно установить соединение с какой-либо сетевой службой, работающей локально, то есть нужно буквально подключиться к самому себе.

Например, если вы хотите развернуть на своём локальном компьютере серверное ПО и протестировать его посредством соответствующего клиента, установленного на этом же компьютере, то вы можете сделать это даже без подключения к какой-либо сети, поскольку у вашего компьютера всегда есть как минимум один IP-адрес — 127.0.0.1.

Другой случай. В современных дистрибутивах Linux чаще всего DNS-сервер устанавливается локально (это простое ПО для кэширования запросов и ускорения работы). Поэтому ваша операционная система устанавливает соединение с адресом 127.0.0.1 и портом 53 каждый раз, когда нужно преобразовать какое-либо имя в IP-адрес. И только если требуемая запись не найдена в кэше локального сервера DNS, то приложение сервера DNS передаст запрос вышестоящему серверу.

Вот как это работает:

1. Есть виртуальный сетевой интерфейс, реализующий механизм «обратной петли», обычно с именем lo (на ОС Linux) с назначенным адресом 127.0.0.1 и маской подсети 255.0.0.0. Хитрость интерфейса с обратной петлей в том, что он всегда ответит, на какой бы адрес этой подсети вы не отправили сообщение. Поэтому, хотя вы видите только один назначенный интерфейсу адрес 127.0.0.1, если вы попытаетесь подключиться к любому адресу из подсети 127.0.0.0/8, то результат всегда будет одинаков.
2. Есть специальное имя localhost (локальный узел), служащее псевдонимом для узла с адресом 127.0.0.1. Его можно использовать вместо IP-адреса, если вам так удобнее.
3. Когда вы пытаетесь подключиться к 127.0.0.1, операционная система видит, что этот адрес относится к маршруту, связывающему подсеть 127.0.0.0/8 с интерфейсом lo. Затем ваши данные будут отправлены виртуальному интерфейсу с обратной петлёй, а операционная система получит входящее сообщение, обработает его и самостоятельно ответит.

`netstat -vpntul` - какие порты слушаются на localhost (Linux)

### DNS: Система доменных имён (Domain Name System)

Основной способ использования системы DNS — это преобразование доменных имён в IP-адреса. 

Сначала операционная система будет искать это имя в локальном списке, состоящем из пар «имя узла — IP-адрес». В большинстве UNIX-подобных систем он находится в файле /etc/hosts. Например, запись, гласящая, что имя localhost эквивалентно адресу 127.0.0.1, находится именно здесь. В случае неудачи ОС возьмёт адрес DNS сервера  из файла /etc/resolv.conf и инициирует отправку запроса ему (в/etc/resolv.conf часто указано, что основной DNS-сервер расположен локально на 127.0.0.1).

Узнать IP-адрес:  
`host example.com` - Linux  
`nslookup example.com` - Windows

Статус DNS-сервера:  
`resolvectl status` - Linux  
`ipconfig /all` - Windows

Каждое доменное имя может быть разделено точками на **зоны** (www, example и com). Если зона действительно существует, то должен быть по крайней мере один сервер DNS, располагающий полной информацией об этой зоне. Такие серверы называются полномочными (authoritative) серверами DNS

Зоны и их полномочные сервера упорядочены в иерархической структуре, начинающейся с конца доменного имени. Существует группа корневых серверов, в которых хранится информация о зонах первого уровня и об их полномочных серверах. В свою очередь серверы первого уровня располагают информацией о зонах второго уровня. Это может продолжаться бесконечно, но обычно серверы зон второго уровня и следующих работают в рекурсивном режиме (т.е. отвечают на все запросы про нижестоящие доменные имена).

Другой тип серверов DNS, которые всегда работают в рекурсивном режиме, это **резолверы** (преобразователи, сопоставители). Такие преобразователи обычно не хранят информацию о доменах, они просто обрабатывают запросы клиентов и перенаправляют их серверам иерархического дерева.  
В некоторых случаях «резолверы» дополнительно настраивают на хранение информации о локальных зонах. Например, если в локальной сети вашей компании множество узлов, то удобней всего было бы назначить им доменные имена, такие как "что_то.local" или "что_то.название_компании.com", которые будут доступны только в интранете (внутренней локальной сети организации).

Самые распространённые записи системы DNS:
1. **Запись "A"** используется для преобразования имени домена в IP-адрес. У домена может быть несколько записей "A", содержащих несколько IP-адресов, назначенных этому домену. В таком случае ОС выберет адрес из списка случайным образом. Этот механизм называют каруселью, циклическим перебором, алгоритмом кругового обслуживания (round robin). Что касается обратной процедуры - количество доменных имён, связываемых с одним IP-адресом, не ограничено.
2. **Запись PTR** (pointer — указатель) выполняет обратную функцию, преобразуя IP-адреса в доменные имена. В большинстве случаев значения записей "A" и PTR не синхронизированы между собой.
3. **CNAME** (canonical name — каноническое имя) — это псевдоним. Например, если у вашего веб-сайта несколько доменных имён, то вы можете привязать одно к другому, указав это имя как псевдоним к имени, содержащемуся в записи "A". Пример: А-запись my-site.com ссылается на IP-адрес a.b.c.d, а доменное имя www.my-site.com с помощью CNAME ссылается на my-site.com.
4. **MX** (mail exchanger — почтовый обменник) — это запись, указывающая, какой почтовый сервер  обрабатывает электронную почту этого домена.
5. Записи **NS** (Authoritative Name Server — полномочный сервер имён) и SOA (Start-of-authority — начальная запись зоны) содержат сведения о полномочных серверах зоны. С помощью этих записей «резолверы» получают информацию о следующем сервере DNS, которому следует оправить запрос.
6. Записи **SRV** (Server selection — выбор сервера) и **TXT** (Text String — текстовая строка) можно использовать для хранения любой текстовой информации.

## Транспортный уровень модели TCP/IP

Передача данных в сети - это не просто копирование файлов. Все данные приложения инкапсулируются в пакеты транспортных протоколов. Транспортный уровень служит для обеспечения некоторых функций по передаче данных, которые нельзя реализовать ни на прикладном, ни на сетевом уровне. Суть транспортного уровня - в определении способов передачи данных, то есть в определении, *как именно данные будут передаваться*.

Транспортный уровень модели TCP/IP представлен в большинстве случаев протоколами **TCP** (Transmission Control Protocol — протокол управления передачей) и **UDP** (User Datagram Protocol — протокол пользовательских датаграмм).

### Основные принципы и понятия

#### Сетевые пакеты

Данные запросов и ответов серверов и клиентов не текут по сети плавно и непрерывно, как река. Поток данных больше похож на фотоны — поток множества незаметных частиц.  
Поэтому нельзя передать большой файл за раз одной порцией. Он разделяется на **пакеты** (порции данных наподобие фотонов), а затем эти пакеты отправляются и принимаются, далее пакеты снова собираются в файл и передаются приложениям (это верно как для приложений клиентов, так и для приложений серверов).
Максимальный размер пакета зависит от настроек канального уровня, в современных сетях он обычно равен 1500 байтов. Теоретически каждый пакет может маршрутизироваться отдельно. Это зависит от настроек маршрутизаторов, находящихся между клиентом с сервером.

#### Сетевые порты

Порты используются как протоколом TCP, так и протоколом UDP.

Как же операционные системы будут различать все входящие и исходящие потоки данных, передаваемые одновременно? То есть как именно клиенту указать, что он отправляет запрос приложению веб-сервера, а не приложению почтового сервера, учитывая, что оба находятся на одном удалённом узле?
Это выполняется с помощью так называемых **сетевых портов**.

При запуске сетевое серверное приложение (например, веб-сервер) открывает порт и начинает прослушивать его. 
Представьте, что у аппаратного сервера есть IP-адрес 1.2.3.4 и приложение веб-сервера прослушивает порт 80.
Одновременно на этом же аппаратном сервере может работать приложение сервера электронной почты, использующее порт 25 для принятия входящих запросов.
Это означает, что если клиент хочет получить веб-страницу, то он должен отправить запрос на порт 80, но если он хочет отправить электронное письмо, то он должен направить его на порт 25.

Когда клиент обменивается данными с сервером, порт также открыт и на стороне клиента; этот порт используется приложением клиента, для взаимодействия с удалённым сервером.
Каждое соединение будет представлено уникальным кортежем значений: {transport_protocol, client_IP, client_port, server_IP, server_port} (транспортный_протокол, IP_клиента, порт_клиента, IP_сервера, порт_сервера). Это позволяет операционной системе (ОС) клиента различать соединения разных программ, обменивающихся данными с разными удалёнными серверами.
Итак, узел клиента работает с несколькими серверами одновременно.

Более того, один и тот же узел клиента может работать с одним и тем же приложением сервера (например, 1.2.3.4:80), используя одновременно несколько приложений (например, вы можете запрашивать страницы одного и того же веб-сайта с помощью браузеров Firefox, Safari, Chrome, Opera), — для каждого соединения будет использоваться свой порт клиента, поэтому потоки данных не перепутаются.

Для каждого протокола, TCP и UDP, доступно по 65 536 портов. То есть невозможно одновременно прослушивать больше 65 536 портов на одном аппаратном сервере.

### TCP — протокол управления передачей

Процесс передачи любых данных непредсказуем даже в современных сетях с широкополосными каналами. Этому есть несколько причин:
* Любой пакет может быть повреждён из-за ошибок в сетевых устройствах (транзитных узлах), расположенных где-то между клиентом и сервером.
* Пакет может потеряться из-за отказов сети.
* Пакеты могут оказаться продублированными из-за ошибок в транзитных узлах и (или) конечных точках (на стороне как клиентов, так и серверов).
* Пакеты могут маршрутизироваться по отдельности, поэтому они могут достичь узла назначения в произвольном порядке.
* У каждой конечной точки (клиента и сервера) может быть различная пропускная способность и производительность. Поэтому одна сторона может перегрузить другую, сетевая подсистема которой более медленная.

Все эти факторы особенно опасны для критических сетевых приложений.

Для решения этих проблем был создан протокол TCP. Он выполняет следующие очень важные функции:
* Управление очерёдностью данных. На стороне получателя пакеты собираются воедино в том же порядке, в котором они были отправлены.
* Повторная отправка потерянных пакетов. Если получение пакета не подтверждено любой из сторон, этот пакет запрашивается снова.
* Управление потоком. Если одна конечная точка отправляет данные быстрее, чем вторая способна обрабатывать, то более медленная сторона может запросить снижение скорости отправки.

Все эти функции реализуются с помощью **заголовков** TCP. Размер заголовка TCP колеблется между 20 и 40 байтами, это не так мало, учитывая максимальный размер пакета (1500 байт в большинстве случаев), но такие дополнительные накладные расходы позволяют достичь хорошего уровня надёжности.  
Некоторые функции протокола TCP реализованы с помощью так называемых **флагов**, представляющих собой специальные данные в заголовке TCP.

Важная часть протокола TCP — это **соединение**.  
По протоколу TCP данные можно отправлять только после установки соединения между клиентом и сервером. Процедура установки соединения называется **рукопожатием TCP (TCP handshake)**:
* Клиент отправляет серверу специальный пакет с установленным флагом SYN (synchronization — синхронизация). 
* Сервер получает этот пакет и отправляет ответ с установленными флагами SYN и ACK (acknowledgement — подтверждение).
* Клиент отправляет пакет с установленным флагом ACK.
* После этого соединение считается установленным и обе стороны могут отправлять запросы и ответы.

Если одна из сторон хочет **завершить соединение** (это может быть как клиент, так и сервер), то выполняется очень похожая процедура, называемая закрытием связи или завершением соединения (**TCP teardown** от англ. teardown — демонтаж, разрушение, разборка, освобождение канала). 
* Инициирующая сторона отправляет пакет с флагом FIN (finish — завершать; окончание).
* Вторая сторона отвечает пакетом с флагом ACK и затем ещё одним пакетом с флагом FIN — они могут быть объединены в один пакет FIN+ACK.
* Инициирующая сторона отправляет подтверждение с флагом ACK.

Протокол TCP обычно используется как основа для обмена данными между сетевыми приложениями, которым необходим строгий порядок отправки и получения данных и гарантия доставки. Примеры таких приложений:
* Электронная почта
* Торговля через Интернет и банковские приложения
* Базы данных
* Веб-сервисы

### UDP — протокол пользовательских датаграмм

Этот протокол работает с высокой скоростью и требует меньше вычислительных ресурсов. При инкапсуляции протокол UDP добавляет в пакет IP минимум информации. Но это единственная хорошая новость, поскольку протокол UDP не предусматривает упорядочивание пакетов, подтверждение получения данных и управление скоростью потока. UDP не использует соединение: нет ни «рукопожатия», ни вежливого «прощания», только передача данных от одной точки к другой.

Заголовок включает только восемь байт с четырьмя двухбайтовыми полями.

 Полезно применять протокол UDP в случае потоковой передачи мультимедиа, голосовой связи (VoIP), преобразования доменных имён в системе DNS и онлайн-игр. Во всех этих случаях просто нет времени на повторную отправку повреждённых данных. К моменту повторной отправки эти данные уже утратят актуальность.
 
 ### Анализаторы сетевого трафика
 
 Чтобы заглянуть внутрь сетевых пакетов, проще всего использовать анализаторы сетевого трафика (известные также как «снифферы», от англ. sniff — нюхать). Это специальные программы, собирающие необработанные данные на сетевых интерфейсах узла, на котором они запущены, и представляющие эти данные в формате, удобном для человека. Самые популярные анализаторы — tcpdump и Wireshark.
 
 #### tcpdump
 
 `tcpdump <options> <expression>`
 
 **Опции для сбора пакетов**:  
 `-c <N>` (например, -c 20): собрать первые N пакетов и выйти. По умолчанию, "tcpdump" работает до остановки нажатием Ctrl+C (на самом деле эта комбинация клавиш отправляет сигнал SIGINT).  
`-i <interface_name>` (название интерфейса): с помощью этой опции можно указать сетевой интерфейс, например lo или eth0; по умолчанию берётся первый интерфейс, не являющийся "lo". Для сбора пакетов со всех интерфейсов нужно указать следующее: `-i any`.  
`-s <N>`: установка захватываемой длины пакета. -s 0 — для сбора полных пакетов; -s60 — для сбора только первых 60 байт каждого пакета.  
`-w <file>` (файл): сохранять поток собранных данных в файле формата PCAP (специальный формат файлов для хранения необработанных сетевых данных) вместо вывода на терминал.  
`-r <file>` (файл): считывать пакеты из файла PCAP, а не из сетевых интерфейсов. Опция полезна для глубокого исследования сетевого потока, например, когда вы изучаете сетевые неисправности.  

**Опции для отображения**:  
`-n`: не преобразовывать IP-адреса в имена узлов.  
`-nn`: показывать адреса узлов в виде IP-адресов, а порты в виде номеров. Эту опцию рекомендуется использовать в большинстве случаев.  
`-X`: вывод необработанного содержимого пакетов, представленного как шестнадцатеричной формой, так и форматом, удобным для человека (символы ASCII). Очень полезна для более тщательного анализа содержимого пакетов при изучении неисправностей.  
`-A`: вывод необработанного содержимого пакетов в компактном формате без шестнадцатеричной части. Если не указаны -X, и -A, то в формате, удобном для человека, отображаются только заголовки.  
`-ttt`: вместо полной временной метки выводить прирост времени с момента предыдущего элемента.  
`-v / -vv / -vvv`: три степени подробности.  

**Выражения (фильтры)**  
Все эти элементы можно сочетать с помощью ключевых слов or (или), and (и), not (не), а также с помощью скобок. Если применяются скобки, то выражение необходимо заключать в кавычки, например: "(tcp or icmp)", а не (tcp or icmp). Можно применять как двойные, так и одинарные кавычки.

|Синтаксис|Значения|Примеры выражений (фильтров)|Пояснение|
|---------|--------|----------------------------|---------|
|host X|Только трафик, исходящий от узла X или предназначающийся ему. Это двунаправленное условие, поэтому собираются как запросы клиентов, так и ответы серверов|`host example.com`<br> `host 8.8.8.8`|Весь поток пакетов между данным узлом (на котором установлена программа tcpdump) и удалённым узлом example.com. То же для узла 8.8.8.8|
|net X/Y|Подобно host, но собирается поток данных для всех узлов этой сети. X — адрес сети, Y — маска подсети|`net 8.8.0.0/16`|Весь поток пакетов, проходящий между данным узлом и любым узлом сети 8.8.0.0/16|
|tcp / udp / icmp|Название протокола, поток которого будет собираться|`tcp and port 8080` `udp and not port 53` `icmp`|Пакеты TCP, исходящие из порта 8080 или предназначающиеся ему. Пакеты UDP, исходящие из любого порта или предназначающиеся любому порту кроме 53. Все пакеты протокола ICMP|
|port X|Номер порта протокола TCP или UDP. Не применимо к ICMP, так как в рамках этого протокола порты не используются|	`"tcp and (port 22 or port 3389)"` `port 53`|Пакеты TCP, исходящие из порта 22 или 3389 или предназначающиеся им. Пакеты TCP и UDP, исходящие из порта 53 или предназначающиеся ему|
|src|Применимо к ключевым словам host, net, port, portrange. Означает поток данных, исходящий от этого источника: узла, сети, порта или диапазона портов (portrange)|`tcp and src host 192.168.40.150 and src port 22`|Пакеты TCP, исходящие от узла 192.168.40.150 и с портом источника 22.Это входящий поток данных протокола SSH от узла 192.168.40.150, этот узел выполняет роль сервера SSH.|
|dst|Подобно src, но означает поток данных, идущий к указанному узлу, сети, порту, диапазону портов|`udp and dst host 8.8.8.8 and dst port 53`|Запросы клиента «резолверу» DNS с IP-адресом 8.8.8.8 (ответы сервера не будут собираться).|
|portrange X-Y|Сбор только пакетов протокола TCP или UDP с любым номером порта (исходящего и входящего) в диапазоне от X до Y|`tcp and src portrange 1-1023`|Все пакеты TCP, исходящие от портов с номерами от 1 до 1023|

