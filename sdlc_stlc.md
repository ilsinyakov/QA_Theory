# SDLC и STLC

## Определение SDLC

**SDLC (Software Development Life Cycle)** — последовательность этапов разработки тем или иным способом, с применением тех или иных подходов. После возникновения бизнес-идеи и сбора требований они будут реализованы в функциях приложения, которые удовлетворят потребности клиентов.

## Этапы SDLC

![SDLC](https://github.com/ilsinyakov/QA_Theory/blob/main/Pictures/sdlc1.png)

|Порядок|Этап SDLC|Что надо сделать?|Кто исполнитель|Какой артефакт в итоге получается|
|--|--|--|--|--|
|1|Планирование|Определить цель проекта, сроки, бюджет, риски и ресурсы|ПМ|План проекта, Роадмэп, Бюджет, План реагирования на риски, Матрица ответственности|
|2|Анализ|Сбор требований, анализ и утверждение|БА, СА, ПМ|Протоколы требований от бизнеса, БТ, ТЗ|
|3|Проектирование|Создать архитектуру, выбрать стек технологий и средства разработки|Архитектор, команда|ТЗ, Спецификации|
|4|Разработка|Непосредственное написание кода, юнит тесты|Разработчики|Рабочий код|
|5|Тестирование|Проверить на соответствие требованиям, выявить и исправить ошибки (отдать на исправление в разработку)|Тестировщик, ПМ|Тест план, тест кейсы, баг репорт, протокол ПСИ, пользовательские инструкции|
|6|Внедрение|Запустить на продуктовой среде и обучить пользователей|Девопсеры, ПМ|Работающий функционал при эксплуатации пользователей|
|7|Сопровождение|Регулярно обновлять, исправлять ошибки в процессе эксплуатации, поддерживать пользователей|Команда поддержки|Закрытые обращения в SD|

## Методологии SDLC (модели)

Методологии выбирают исходя из контекста проекта и бизнес-требований.

![SDLC модели](https://raw.githubusercontent.com/ilsinyakov/QA_Theory/refs/heads/main/Pictures/SDLC-модели-упрощенно-min.webp)

### Модель водопада (каскадная)

![Каскадная модель](https://raw.githubusercontent.com/ilsinyakov/QA_Theory/refs/heads/main/Pictures/Каскадная-модель-разработки-min.webp)

Представляет собой линейный процесс последовательной имплементации продукта, идущий «сверху вниз», как каскад, или водопад. Это значит, что каждый этап разработки начинается только после завершения предыдущего. Не предполагается возвращение на предыдущие этапы, чтобы отработать изменения в требованиях. Водопадная модель исторически самая первая из возникших, и все еще применяется в разработке.

#### Применение

В проектах, не предполагающих изменение требований после начала разработки, в частности это проекты, инициированные RFP-запросом (документированный запрос организации, заинтересованной в приложении), и проекты, в которых клиент очень ясно и подробно изложил требования.

#### Преимущества

* Легко объяснять клиентам процесс разработки и текущее состояние проекта
* Упорядоченный подход
* Все стадии и активности известны и подробно описываются
* Легко планировать проект
* Верификация на каждом этапе обеспечивает раннее обнаружение дефектов и ошибок в требованиях
* На каждом этапа есть соответствующая документация

#### Недостатки

* Предполагается, что требования «заморожены», то есть не будут изменяться в процессе
* Очень сложно вернуться на любой этап после его завершения
* Негибкий процесс
* Трудное и дорогое масштабирование и приспособление проекта к изменениям
* Требует наличия детализированного плана
* Достаточно дорогая модель в плане ресурсов и «человеко-часов»

### V-модель

![V-модель](https://raw.githubusercontent.com/ilsinyakov/QA_Theory/refs/heads/main/Pictures/V-модель-разработки-min.webp)
![V-модель подробно](https://raw.githubusercontent.com/ilsinyakov/QA_Theory/refs/heads/main/Pictures/V-модель-SDLC-min.webp)

Является расширением каскадной модели. Вместо линейного продвижения проекта, процесс как бы «располовинивается» после этапа имплементации и создания кода, визуально формируя специфическую V-образную модель. Разница между стандартной водопадной и V-моделью состоит в очень раннем планировании тестирования в V-модели.

V-моделью называется еще и потому, что как бы своим названием указывает на V-алидацию и V-ерификацию.

В контексте использования V-модели нужно понимать разницу между верификацией и валидацией.  Подробнее здесь: [Верификация и валидация](https://github.com/ilsinyakov/QA_Theory/blob/main/verification_validation.md)

#### Применение V-модели

* Когда требования к продукту четко описаны, известны и понятны
* Когда пользуются техниками разработки и инструментами, хорошо изученными командой

#### Преимущества V-модели

* Простая и легкая методика
* На каждом этапе документируется
* Превосходит каскадную модель тем что тестирование начинается раньше
* Хорошо работает если с требованиями все ОК
* Верификация и валидация продукта на ранних этапах

#### Недостатки V-модели

* Не очень гибкая, если нужна гибкость — то Agile
* Трудности с масштабированием
* Продукт разрабатывается на этапе имплементации, и не создаются так называемые ранние работающие прототипы
* Нет четкого пути отработки проблем с тестированием
* Достаточно дорогая модель, большие и негибкие затраты времени и труда
* Нужен большой детализированный и четко соблюдаемый план

### Модель прототипирования

Предполагает создание **прототипов** — неполных версий разрабатываемого приложения. Эта активность обычно направлена на визуализацию неких компонентов приложения, представляющих интерес, с целью прояснить/уточнить для команды пользовательские требования. Также прототипирование помогает снизить количество излишних итераций (этапов) в каскадной модели, трудных в имплементации из-за негибкости, присущей этой модели. После создания финального прототипа требования «замораживаются».

Существуют разновидности прототипной модели:

* **Быстрое прототипирование** — прототипы затем не становятся частью финальной версии продукта.

* **Эволюционное прототипирование** — прототипы «развиваются» до финальной системы, включаются в нее как основа, путем последовательного включения в систему результатов пользовательского фидбэка.

* **Инкрементальное прототипирование** — продукт создается как последовательность отдельных прототипов, которые в конце интегрируются в единое целое.

* **Экстремальное прототипирование** — в основном в веб-разработке. Она разбивается на три фазы. На первой делают статический прототип, состоящий из HTML-страниц. На второй работают с уровнем сервисов, программируя поведение. На третьей имплементируют сервисы.

#### Применение прототипирования

Как отдельная методология или как дополнение к любой другой SDLC-модели. Особенно полезна при разработке системы с множеством пользовательских взаимодействий. И обратно, если в системе нет большого количества взаимодействий с пользователем (например специализированная система для вычислений), ей не нужны прототипы.

#### Преимущества прототипирования

* Уменьшение затрат времени и ресурсов (если на создание прототипов не уходит слишком много времени)
* Улучшение качества взаимодействий с пользователем

#### Недостатки прототипирования

* Мало возможностей для анализа
* Прототипы не всегда понятны пользователям, и недооценка прототипа (делают поспешный вывод о несовершенстве системы вообще)
* Иногда неполное понимание разработчиками целей пользователей
* Иногда большие затраты времени на создание и поддержку прототипов

### Спиральная модель разработки (SDM)

![Спиральная модель](https://raw.githubusercontent.com/ilsinyakov/QA_Theory/refs/heads/main/Pictures/спиральная-модель-min.webp)

Комбинация этапов дизайна и прототипирования — пытаясь сочетать преимущества подходов «снизу вверх» и «сверху вниз». В общем виде гибрид прототипной и каскадной моделей. Предназначена для больших, дорогих, сложных проектов. Этапы в целом взяты из водопадной модели, идут в том же порядке, но отделяются этапами планирования, оценки рисков, и создания прототипов (симуляций).

#### Применение спиральной модели

В больших проектах и системах с множеством встраиваемых этапов/сегментов.

#### Преимущества спиральной модели

* Оценка предстоящих затрат бюджета и усилий более реалистична по мере развития проекта, поскольку проблемы определяются раньше
* Раннее включение разработчиков в процессы
* Хороший контроль рисков

#### Недостатки спиральной модели

* Высокая стоимость финального продукта
* Нужны специальные скиллы оценки рисков
* Высокая специфичность проекта определяет трудность применения наработок в следующих проектах (нет реюзабельности)

### Итеративная и инкрементальная модели

![Итеративная и инкрементальная модели](https://raw.githubusercontent.com/ilsinyakov/QA_Theory/refs/heads/main/Pictures/mini_waterfall-min.webp)

Тоже создавалась как развитие водопадной модели. Начинается с планирования, завершается деплоем, и между ними циклические операции. Базовая идея такого подхода — создание системы последовательными циклами (итерациями) и небольшими «порциями» (инкрементально), что позволяет разработчикам изучать продукт на ранних стадиях и вносить корректировки. Можно представить эти модели как мини-водопады, или мини-V-модели.

#### Применение итеративной модели

В приложениях, которые могут модифицироваться на расширение/сужение функциональности, и в больших системах, состоящих из множества маленьких сегментов, например ERP-системах. Например, начинают с модуля бюджета как первой итерации, и продолжают разработкой складского модуля и так далее.

#### Преимущества итеративной модели

* Создание бизнес-ценности в продукте на раннем этапе
* Экономное использование ресурсов, контролируемыми небольшими «порциями»
* Гибкое применение запросов на изменения между итерациями
* Фокус на ценности для пользователей, а не грубо-прямолинейный подход к разработке
* Раннее определение и устранение возникающих проблем

#### Недостатки итеративной модели

* Нужно много документации
* И соблюдение предписанных процессов
* Инкременты (стадии) основаны на зависимостях между функциями приложения
* Нужно больше включения пользователей/клиентов в процесс, чем в «линейных» методиках, что не всегда достижимо
* Разбивка функций поэтапно может быть проблематичной
* Интеграция между итерациями может быть проблемной в случае если она не предусматривалась при планировании и разработке проекта

### Agile

Основана на итеративной и инкрементальной моделях.  
Подробнее здесь: [Agile](https://github.com/ilsinyakov/QA_Theory/blob/main/agile.md)

#### Применение Agile

В принципе, в любых проектах, допускающих широкое привлечение клиентов/пользователей в процесс, поскольку предполагается что модель должна быть очень интерактивной. Также в случаях, когда клиенту нужно видеть выполненными некоторые функциональные требования уже за две-три недели, а требования не так чтобы очень ясно сформулированы. Гибкая модель позволяет создать ценный и вполне рабочий продукт очень рано в цикле и далее его быстро совершенствовать.

#### Преимущества Agile

* Уменьшение времени доставки важных функций
* Хорошая личная коммуникация и непрерывный фидбэк от пользователей/клиентов, закрывающий «пробелы» и догадки
* На выходе качественный продукт, получаемый за короткое время

#### Недостатки Agile

* Не всегда хорошая масштабируемость
* Не всегда команда способна обеспечивать качественную коллаборацию внутри себя и с клиентами
* Документация создается на достаточно поздних этапах
* Уменьшение реюзабельности компонентов
* Нужно специальное обучение персонала как работать «по эджайлу»
