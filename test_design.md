# Техники тест дизайна

## Черный, серый, белый ящик

Подход **"белого ящика"** —  это способ тестирования, когда QA знает структуру кода и использует это знание.

Подход **"черного ящика"** —  это способ тестирования, когда QA может знать структуру кода, но не использует эти знания

### Подход "белого ящика"

В качестве примера применения метода "белого ящика" рассмотрим очень простой фрагмент кода.
```java
public void compareTwoNumbers (int a, int b) {
   if (a > b)
        System.out.println "A greater than B"
   else
        System.out.println "A less than B"
}
```
Наша задача —  покрыть этот метод тестами, принимая во внимание код, используя, например, один из методов покрытия кода:
* Покрытие операторов (statement coverage): каждый оператор кода (строка, которая что-то делает) должен быть выполнен хотя бы один раз.
* Покрытие ветвей (branch coverage): каждая ветвь (условие) кода должна быть выполнена хотя бы один раз.
* Покрытие условий (condition coverage): каждый результат условия должен быть протестирован хотя бы один раз.
* и т.д.

Рассмотрим покрытие операторов.

Первый случай. A > B

Выполняется два оператора:
```java
   if (a > b)
        System.out.println "A greater than B"
```
Второй случай. A < B

Выполняются три оператора:
```java
   if (a > b)
...
else
        System.out.println "A less than B"
```

Оба случая полностью охватывают все операторы. Тестирование "белого ящика" завершено.  
Такое же тестирование охватывает все ветви и условия (здесь у нас только 2 ветви).  
Таким образом, для тестирования "белого ящика" достаточно 2 случаев.

### Подход "черного ящика"

Теперь рассмотрим ту же функциональность, но с точки зрения пользователя. Предположим, у нас есть пользовательский интерфейс с двумя полями для ввода A и B, кнопкой "Сравнить"(Compare) и сообщением о результате (Result).

С точки зрения программиста, двух тестов достаточно. Но с точки зрения пользователя, должен быть третий, A = B, и дополнительные нефункциональные тесты, например, UI и юзабилити, надежность, или даже безопасность, если работа ограничена какими-то определенными ролями. 

### Подход "серого ящика"

Это так называемое тестирование "серого ящика". По сути, это нечто среднее между белым и черным ящиком, между четкой пользовательской точкой зрения, когда мы тестируем только пользовательский интерфейс и реальные сценарии пользователей, и тестированием белого ящика, когда нас интересует только код, и мы совсем не проверяем точку зрения пользователя.

Серый ящик подразумевает знание системы, изучение технической документации, фокусировку на внутренних процессах системы, интеграцию с базами данных, чтение и анализ логов, устранение неполадок и поиск первопричины дефекта, другими словами, серый ящик — это наиболее частая деятельность профессионального QA.

## Регрессионное тестирование

Повторное тестирование любой функциональности известно как регрессионное тестирование. Оно используется, когда исправляется дефект или вносятся какие-либо изменения в систему. Регрессионное тестирование можно разделить на три типа:

1. **Дымовое тестирование (Smoke testing)**. Повторно тестируются только cамые простые сценарии, так называемые happy path — счастливые пути. Это очень поверхностное тестирование.
2. **Проверка на адекватность, называемая по-русски санитарным тестированием (Sanity testing в оригинале)**. Перепроверяется только измененная функциональность, например, когда добавляется новая роль пользователя, все старые роли подвергаются глубокой перепроверке.
3. **Полное регрессионное тестирование**. Вся система тестируется повторно, запускаются все существующие тест-кейсы.

### Регрессионное тестирование методом белого ящика

Этот термин обычно означает автоматический запуск юнит-тестов. Юнит-тесты встраиваются во весь процесс разработки и выпуска и автоматически запускаются по какому-либо событию, например, в определенное время суток или с каждым изменением, внесенному в репозиторий.

Например, добавление новой роли обычно выглядит как набор изменений, внесенных в код. Когда изменения попадают в репозиторий и новая версия приложения собирается в среде разработки, окончание процесса сборки запускает юнит-тесты всей системы. Если все юнит-тесты пройдены, стадия "белого ящика" считается успешной, и можно приступать к следующей стадии — "черного ящика" или "серого ящика".

### Регрессионное тестирование методом черного ящика

Этот процесс может проводиться как вручную, так и автоматически. Процесс регрессии "черного ящика" обычно проводится в следующем порядке:

*Дымовое (Smoke)* тестирование методом черного ящика
С этого этапа процесс должен начинаться. Концентрироваться следует на "счастливых путях" в приложении. Ожидается, что все юнит-тесты пройдены, иначе дальнейшее тестирование не имеет смысла. Если реализована автоматизация тестирования, эти тесты могут выполняться автоматически, но если нет, за них отвечает команда ручного тестирования. В случае добавления новой роли необходимо протестировать все приложение (не только функциональность роли), но очень поверхностно.

*Санитарное (Sanity)* тестирование методом черного ящика
Термин "санитарное тестирование" является устоявшимся переводом англоязычного термина  Sanity, но нужно иметь в виду, что такое тестирование не имеет никакого отношения к санитарам. Это, по сути, тестирование на адекватность. Если все дымовые тесты пройдены, необходимо проверить функциональность, на которую повлияли изменения. В нашем примере это функциональность ролей, поэтому все сценарии пользователей, которые работают с ролями, должны быть вовлечены в эту проверку. В некоторых случаях этого может быть достаточно, чтобы вынести вердикт о качестве приложения после изменений.

*Полное регрессионное (Full Regression)* тестирование методом черного ящика
Если пройдены и юнит-тесты, и смоки (дымовые тесты), то вместо sanity тестирования в качестве финального этапа регрессии выбирается полное регрессионное тестирование. Это делается, если релиз приближается, внесенные изменения значительны, или в случае хорошего покрытия автоматизацией (если все автоматизировано, почему бы нам не запустить все?) В любом случае, фокус здесь — ВСЕ пользовательские сценарии.

### Регрессионное тестирование методом серого ящика

Принцип здесь тот же, что и при подходе "черного ящика", но объект тестирования обычно находится во внутренних модулях приложения, а не в пользовательском интерфейсе.

*Дымовое тестирование методом серого ящика*
В случае добавления новой роли пользователя, тестирование в режиме "серого ящика" может проводиться на уровне базы данных (добавляется ли новая таблица или строка в базу данных) или на уровне бэкенда (возвращаем ли мы новую роль в ответ на GET /roles) и работают ли другие внутренние модули так, как ожидается после изменений.

*Тестирование методом серого ящика с точки зрения здравого смысла*
Пользовательские сценарии, которые работают с ролями, проверяются с точки зрения их внутреннего поведения. Если роль может войти в систему из пользовательского интерфейса, отправляют ли сервисы правильные запросы? Правильно ли регистрируется активность роли? Сохраняется ли она в истории этого пользователя? И так далее.

*Полное регрессионное тестирование методом серого ящика*
Здесь акцент смещен с пользовательского интерфейса на бэкенд и базу данных, но идея та же — проверить внутреннее поведение системы, принимая во внимание все возможные сценарии.

## Классы эквивалентности и анализ граничных значений

### Классы эквивалентности

Классы эквивалентности пришли из математики, где домены входных переменных можно разделять на поддомены. 

В сфере тестирования программного обеспечения поддомены называются классами эквивалентности. 

Для тестирования входных данных программы берётся по одному значению из каждого класса эквивалентности.

Чтобы корректно определить классы эквивалентности для определённого параметра необходимо выполнить следующие шаги. 
1. Определить тип параметра.
2. Определить домен входных значений.
3. Разделить домен на поддомены (классы эквивалентности).
4. Выбрать по одному значению из каждого класса.
5. Составить список предполагаемых ошибок, которые может совершить пользователь, и разделить их на классы.
6. Выбрать по одному значению из каждого класса ошибок.

Для разделения на классы эквивалентности необходимо использовать знания об архитектуре программного обеспечения и процессах передачи данных, даже если тестируется лишь небольшой фрагмент приложения.

### Анализ граничных значений

Главное отличие математики от разработки ПО в том, что невозможно просто сказать, что значение не определено или бесконечно. Все значения должны быть ограничены с обеих сторон, а реакция ПО должна быть известна не только для «нормальных действий» в рамках ограничений, но и для «ненормальных действий» за рамками ограничений.

Почему тестирование граничных значений важно?  
Из-за человеческого фактора. Функция программного обеспечения — это по сути программный код с множеством точек принятия решений и сравнений.  
Вероятность найти дефекты в области граничных значений выше, чем в середине диапазона.  

А что делать с ошибками пользователей, о которых мы говорили ранее? Связаны ли они с граничными значениями?  
Да. И поэтому набор тестов не должен касаться только граничных значений, но также и значений вокруг граничных.

Алгоритм анализа граничных значений:
1. Определите границы функции или переменной.
2. Если границы не описаны в требованиях, изучите исходный код или используйте свои знания. 
3. Включите в набор тестов случай для граничных значений.
4. Для покрытия возможных ошибок включите тестирование для значений, отличных от максимальных и минимальных на единицу (-1 и +1). 

### Классы эквивалентности и граничные значения в тестах

Используйте следующий общий алгоритм:
1. Определите классы эквивалентности.
2. Определите границы между классами.
3. Включите в тестирование по одному значению из каждого класса (лучше из середины диапазона).
4. Включите в тестирование все граничные значения.
5. Включите в тестирование значения, отличающиеся на единицу (+1 и -1) от каждого граничного значения. 
6. Объедините идентичные тесты при наличии таковых (например, если у двух классов общее граничное значение).

Последний шаг: определите, какие тесты должны привести к положительному результату, а какие к отображению ошибки. Первую группу тестов называют **позитивными**, а вторую — **негативными**.

## Попарное тестирование (Pairwise testing)

Опытные данные показывают, что тестовые комбинации каждой пары значений способны обнаружить от 68 % до 97 % дефектов и что любой из этих дефектов вызывается не комбинацией нескольких значений (например, статус заказа = выполнен, город = Владивосток, покупатели = Алиса Селезнёва, пустой адрес доставки 3), но парой этих параметров (в теории попарного тестирования они называются **факторами**).  
Другими словами, неважно, какой статус у заказа и кто является покупателем (Алиса или Игорь Селезнёв), поскольку первопричина дефекта кроется, например, в паре: город = Владивосток + пустой адрес доставки.

[pairwiseTool](https://pairwise.teremokgames.com/)

**PICT** — это самый популярный инструмент для попарного тестирования. 
[github](https://github.com/microsoft/pict)
[online](https://pairwise.yuuniworks.com/)

## Таблицы решений

Cоставьте список условий, объединяя те, которые исключают друг друга

|Условия|Правило 1|Правило 2|Правило 3|...|
|-|:-:|:-:|:-:|-|
|Условие 1|
|Условие 2|
|Условие 3|
|...|
|Действия| | | | |
|Действие 1|X| | | |
|Действие 2| |X| | |
|Действие 3| | |X| |
|...| | | |...|




