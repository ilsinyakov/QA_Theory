# Подходы к тестированию. Регресс. Техники тест дизайна

## Содержание

* [Черный, серый, белый ящик](#черный-серый-белый-ящик)
  * [Подход "белого ящика"](#подход-белого-ящика)
  * [Подход "черного ящика"](#подход-черного-ящика)
  * [Подход "серого ящика"](#подход-серого-ящика)
* [Регрессионное тестирование](#регрессионное-тестирование)
  * [Регрессионное тестирование методом белого ящика](#регрессионное-тестирование-методом-белого-ящика)
  * [Регрессионное тестирование методом черного ящика](#регрессионное-тестирование-методом-черного-ящика)
  * [Регрессионное тестирование методом серого ящика](#регрессионное-тестирование-методом-серого-ящика)
* [Классы эквивалентности и анализ граничных значений](#классы-эквивалентности-и-анализ-граничных-значений)
  * [Классы эквивалентности](#классы-эквивалентности)
  * [Анализ граничных значений](#анализ-граничных-значений)
  * [Классы эквивалентности и граничные значения в тестах](#классы-эквивалентности-и-граничные-значения-в-тестах)
* [Попарное тестирование (Pairwise testing)](#попарное-тестирование-pairwise-testing)
* [Таблицы решений (Decision tables)](#таблицы-решений-decision-tables)
* [Диаграммы состояний и переходов (State-transition diagrams)](#диаграммы-состояний-и-переходов-state-transition-diagrams)

## Черный, серый, белый ящик

Подход **"белого ящика"** —  это способ тестирования, когда QA знает структуру кода и использует это знание.

Подход **"черного ящика"** —  это способ тестирования, когда QA может знать структуру кода, но не использует эти знания

### Подход "белого ящика"

В качестве примера применения метода "белого ящика" рассмотрим очень простой фрагмент кода.

```java
public void compareTwoNumbers (int a, int b) {
   if (a > b)
        System.out.println "A greater than B"
   else
        System.out.println "A less than B"
}
```

Наша задача —  покрыть этот метод тестами, принимая во внимание код, используя, например, один из методов покрытия кода:

* Покрытие операторов (statement coverage): каждый оператор кода (строка, которая что-то делает) должен быть выполнен хотя бы один раз.
* Покрытие ветвей (branch coverage): каждая ветвь (условие) кода должна быть выполнена хотя бы один раз.
* Покрытие условий (condition coverage): каждый результат условия должен быть протестирован хотя бы один раз.
* и т.д.

Рассмотрим покрытие операторов.

Первый случай. A > B

Выполняется два оператора:

```java
   if (a > b)
        System.out.println "A greater than B"
```

Второй случай. A < B

Выполняются три оператора:

```java
   if (a > b)
...
else
        System.out.println "A less than B"
```

Оба случая полностью охватывают все операторы. Тестирование "белого ящика" завершено.  
Такое же тестирование охватывает все ветви и условия (здесь у нас только 2 ветви).  
Таким образом, для тестирования "белого ящика" достаточно 2 случаев.

### Подход "черного ящика"

Теперь рассмотрим ту же функциональность, но с точки зрения пользователя. Предположим, у нас есть пользовательский интерфейс с двумя полями для ввода A и B, кнопкой "Сравнить"(Compare) и сообщением о результате (Result).

С точки зрения программиста, двух тестов достаточно. Но с точки зрения пользователя, должен быть третий, A = B, и дополнительные нефункциональные тесты, например, UI и юзабилити, надежность, или даже безопасность, если работа ограничена какими-то определенными ролями.

### Подход "серого ящика"

Это так называемое тестирование "серого ящика". По сути, это нечто среднее между белым и черным ящиком, между четкой пользовательской точкой зрения, когда мы тестируем только пользовательский интерфейс и реальные сценарии пользователей, и тестированием белого ящика, когда нас интересует только код, и мы совсем не проверяем точку зрения пользователя.

Серый ящик подразумевает знание системы, изучение технической документации, фокусировку на внутренних процессах системы, интеграцию с базами данных, чтение и анализ логов, устранение неполадок и поиск первопричины дефекта, другими словами, серый ящик — это наиболее частая деятельность профессионального QA.

## Регрессионное тестирование

**Регрессионное тестирование** — это метод тестирования программного обеспечения, который направлен на проверку того, что изменения в коде не привели к возникновению новых ошибок в уже работающих функциях. Оно используется, когда исправляется дефект или вносятся какие-либо изменения в систему. Регрессионное тестирование можно разделить на три типа:

1. **Дымовое тестирование (Smoke testing)**. Повторно тестируются только самые простые сценарии, так называемые happy path — счастливые пути. Это очень поверхностное тестирование.
2. **Проверка на адекватность, называемая по-русски санитарным тестированием (Sanity testing в оригинале)**. Перепроверяется только измененная функциональность, например, когда добавляется новая роль пользователя, все старые роли подвергаются глубокой перепроверке.
3. **Полное регрессионное тестирование**. Вся система тестируется повторно, запускаются все существующие тест-кейсы.

### Регрессионное тестирование методом белого ящика

Этот термин обычно означает автоматический запуск юнит-тестов. Юнит-тесты встраиваются во весь процесс разработки и выпуска и автоматически запускаются по какому-либо событию, например, в определенное время суток или с каждым изменением, внесенному в репозиторий.

Например, добавление новой роли обычно выглядит как набор изменений, внесенных в код. Когда изменения попадают в репозиторий и новая версия приложения собирается в среде разработки, окончание процесса сборки запускает юнит-тесты всей системы. Если все юнит-тесты пройдены, стадия "белого ящика" считается успешной, и можно приступать к следующей стадии — "черного ящика" или "серого ящика".

### Регрессионное тестирование методом черного ящика

Этот процесс может проводиться как вручную, так и автоматически. Процесс регрессии "черного ящика" обычно проводится в следующем порядке:

*Дымовое (Smoke)* тестирование методом черного ящика
С этого этапа процесс должен начинаться. Концентрироваться следует на "счастливых путях" в приложении. Ожидается, что все юнит-тесты пройдены, иначе дальнейшее тестирование не имеет смысла. Если реализована автоматизация тестирования, эти тесты могут выполняться автоматически, но если нет, за них отвечает команда ручного тестирования. В случае добавления новой роли необходимо протестировать все приложение (не только функциональность роли), но очень поверхностно.

*Санитарное (Sanity)* тестирование методом черного ящика
Термин "санитарное тестирование" является устоявшимся переводом англоязычного термина  Sanity, но нужно иметь в виду, что такое тестирование не имеет никакого отношения к санитарам. Это, по сути, тестирование на адекватность. Если все дымовые тесты пройдены, необходимо проверить функциональность, на которую повлияли изменения. В нашем примере это функциональность ролей, поэтому все сценарии пользователей, которые работают с ролями, должны быть вовлечены в эту проверку. В некоторых случаях этого может быть достаточно, чтобы вынести вердикт о качестве приложения после изменений.

*Полное регрессионное (Full Regression)* тестирование методом черного ящика
Если пройдены и юнит-тесты, и смоки (дымовые тесты), то вместо sanity тестирования в качестве финального этапа регрессии выбирается полное регрессионное тестирование. Это делается, если релиз приближается, внесенные изменения значительны, или в случае хорошего покрытия автоматизацией (если все автоматизировано, почему бы нам не запустить все?) В любом случае, фокус здесь — ВСЕ пользовательские сценарии.

### Регрессионное тестирование методом серого ящика

Принцип здесь тот же, что и при подходе "черного ящика", но объект тестирования обычно находится во внутренних модулях приложения, а не в пользовательском интерфейсе.

*Дымовое тестирование методом серого ящика*
В случае добавления новой роли пользователя, тестирование в режиме "серого ящика" может проводиться на уровне базы данных (добавляется ли новая таблица или строка в базу данных) или на уровне бэкенда (возвращаем ли мы новую роль в ответ на GET /roles) и работают ли другие внутренние модули так, как ожидается после изменений.

*Тестирование методом серого ящика с точки зрения здравого смысла*
Пользовательские сценарии, которые работают с ролями, проверяются с точки зрения их внутреннего поведения. Если роль может войти в систему из пользовательского интерфейса, отправляют ли сервисы правильные запросы? Правильно ли регистрируется активность роли? Сохраняется ли она в истории этого пользователя? И так далее.

*Полное регрессионное тестирование методом серого ящика*
Здесь акцент смещен с пользовательского интерфейса на бэкенд и базу данных, но идея та же — проверить внутреннее поведение системы, принимая во внимание все возможные сценарии.

## Классы эквивалентности и анализ граничных значений

### Классы эквивалентности (Equivalence Partitioning)

Классы эквивалентности пришли из математики, где домены входных переменных можно разделять на поддомены.

В сфере тестирования программного обеспечения поддомены называются классами эквивалентности.

Для тестирования входных данных программы берётся по одному значению из каждого класса эквивалентности.

Чтобы корректно определить классы эквивалентности для определённого параметра необходимо выполнить следующие шаги.

1. Определить тип параметра.
2. Определить домен входных значений.
3. Разделить домен на поддомены (классы эквивалентности).
4. Выбрать по одному значению из каждого класса.
5. Составить список предполагаемых ошибок, которые может совершить пользователь, и разделить их на классы.
6. Выбрать по одному значению из каждого класса ошибок.

Для разделения на классы эквивалентности необходимо использовать знания об архитектуре программного обеспечения и процессах передачи данных, даже если тестируется лишь небольшой фрагмент приложения.

### Анализ граничных значений (Boundary Value Analysis)

Главное отличие математики от разработки ПО в том, что невозможно просто сказать, что значение не определено или бесконечно. Все значения должны быть ограничены с обеих сторон, а реакция ПО должна быть известна не только для «нормальных действий» в рамках ограничений, но и для «ненормальных действий» за рамками ограничений.

Почему тестирование граничных значений важно?  
Из-за человеческого фактора. Функция программного обеспечения — это по сути программный код с множеством точек принятия решений и сравнений.  
Вероятность найти дефекты в области граничных значений выше, чем в середине диапазона.  

А что делать с ошибками пользователей, о которых мы говорили ранее? Связаны ли они с граничными значениями?  
Да. И поэтому набор тестов не должен касаться только граничных значений, но также и значений вокруг граничных.

Алгоритм анализа граничных значений:

1. Определите границы функции или переменной.
2. Если границы не описаны в требованиях, изучите исходный код или используйте свои знания.
3. Включите в набор тестов случай для граничных значений.
4. Для покрытия возможных ошибок включите тестирование для значений, отличных от максимальных и минимальных на единицу (-1 и +1).

### Классы эквивалентности и граничные значения в тестах

Используйте следующий общий алгоритм:

1. Определите классы эквивалентности.
2. Определите границы между классами.
3. Включите в тестирование по одному значению из каждого класса (лучше из середины диапазона).
4. Включите в тестирование все граничные значения.
5. Включите в тестирование значения, отличающиеся на единицу (+1 и -1) от каждого граничного значения.
6. Объедините идентичные тесты при наличии таковых (например, если у двух классов общее граничное значение).

Последний шаг: определите, какие тесты должны привести к положительному результату, а какие к отображению ошибки. Первую группу тестов называют **позитивными**, а вторую — **негативными**.

## Попарное тестирование (Pairwise testing)

Опытные данные показывают, что тестовые комбинации каждой пары значений способны обнаружить от 68 % до 97 % дефектов и что любой из этих дефектов вызывается не комбинацией нескольких значений (например, статус заказа = выполнен, город = Владивосток, покупатели = Алиса Селезнёва, пустой адрес доставки 3), но парой этих параметров (в теории попарного тестирования они называются **факторами**).  
Другими словами, неважно, какой статус у заказа и кто является покупателем (Алиса или Игорь Селезнёв), поскольку первопричина дефекта кроется, например, в паре: город = Владивосток + пустой адрес доставки.

[pairwiseTool](https://pairwise.teremokgames.com/)

**PICT** — это самый популярный инструмент для попарного тестирования.  
[github](https://github.com/microsoft/pict)  
[online](https://pairwise.yuuniworks.com/)

## Таблицы решений (Decision tables)

Таблицы принятия решений – это способ представления сложной прикладной логики в виде формальной таблицы. В таблицу входят условия (которые могут быть истинными или ложными) и действия (ожидаемые результаты, получаемые исходя из комбинаций условий).

Каждый столбец таблицы решений представляет собой правило. Правила нумеруются и служат основой для будущих тест-кейсов.

|Условия|Правило 1|Правило 2|Правило 3|...|
|-|:-:|:-:|:-:|-|
|Условие 1|||||
|Условие 2|||||
|Условие 3|||||
|...|||||
|Действия| | | | |
|Действие 1|X| | | |
|Действие 2| |X| | |
|Действие 3| | |X| |
|...| | | |...|

Каждое правило соответствует одному позитивному тесту, служащему для покрытия функций приложения.

Таблицы решений очень удобны для анализа требований и поиска того, что было упущено.

### Различие между попарным тестированием и таблицами решений

Попарное тестирование применимо для набора равноценных параметров с различными значениями. Невозможные комбинации являются исключениями, а не правилами. Напротив, таблицы решений подразумевают, что параметры могут быть неравнозначными, их комбинации подчиняются сложной логике, а невозможные комбинации, наоборот, являются правилами.

## Диаграммы состояний и переходов (State-transition diagrams)

Диаграмма состояний и переходов показывает высокоуровневые связи между состояниями объектов и способы перехода между ними (в результате действий пользователей или системы).  
В любом приложении, как и в реальной жизни, мы имеем дело с объектами. У объектов есть характеристики (атрибуты) и способности (методы).

### Состояния

Какие состояния возможны для авиарейса?

1. New (новый, или добавлен): известно из диаграммы вариантов использования.
2. Booked (место забронировано): известно из диаграммы вариантов использования.
3. Canceled (бронирование отменено): известно из диаграммы вариантов использования.
4. Expired (прошедший): известно из диаграммы классов и требований предметной области. Поскольку существует дата отправления, то авиарейс может быть прошедшим.

Обратите внимание, что операции Verify (проверить) и Search (поиск) не изменяют состояние рейса. Они лишь показывают его текущее состояние.

Давайте поместим перечисленные состояния на схему.

![State](https://github.com/ilsinyakov/QA_Theory/blob/main/Pictures/state.png)

### Переходы

Изменения состояний называют переходами. Чтобы поместить их на схему, необходимо ответить на следующие вопросы.

* Между какими состояниями возможны переходы?
* Какие действия нужно выполнять, чтобы происходили переходы?

Например, из состояния New (новый) допускается переход только в два состояния: Booked (место забронировано) или Expired (прошедший).

![Transition_1](https://github.com/ilsinyakov/QA_Theory/blob/main/Pictures/transition_1.png)

Чтобы произошёл переход из состояния New в состояние Booked, необходимо выполнить шаги из варианта использования Book Flight (забронировать авиабилет). Для перехода New — > Expired действий пользователя не требуется, переход происходит при наступлении определённого времени. На рисунке ниже эта операция показана как departureDate < now() (датаОтправления < сейчас()), она может быть легко выполнена на уровне базы данных с помощью языка SQL.

![Transition_2](https://github.com/ilsinyakov/QA_Theory/blob/main/Pictures/transition_2.png)

![Transition_3](https://github.com/ilsinyakov/QA_Theory/blob/main/Pictures/transition_3.png)

На схеме есть один странный пробел. В случае отмены бронирования должно ли состояние автоматически смениться на New (новый), чтобы кто-нибудь другой мог забронировать место? В требованиях об этом ничего не сказано, поэтому, есть смысл спросить у заинтересованных лиц.

При проектировании тестов может быть важно, что какое-то из состояний системы является конечным, т.е. придя в это состояние, система будет требовать перезапуска, либо пользователь достигнет цели сценария, либо процесс остановится в этой точке. В то же время иногда не слишком очевидно, что начинать путь необходимо с определенного состояния.

Чтобы отметить начальную и конечную точки процесса, существуют специальные значки - черный круг (начало) и черный круг внутри белого круга - конец.

## Тестирование на основе сценариев использования (Use-Case-Based Testing)

**Что**: создание тестов из реальных пользовательских сценариев (use cases), покрывающих end-to-end поведение.  
**Цель**: проверить систему с точки зрения пользователя, включая интеграцию частей и поток данных.  
**Когда применять**: при приоритизации тестов по бизнес-ценности или для acceptance/интеграционных тестов.  
**Пример**: сценарий «пользователь регистрируется → оформляет заказ → оплачивает → получает подтверждение» — тестировать полный поток.
