# Linux

## Содержание

* [Пользователи, группы и права доступа](#пользователи-группы-и-права-доступа)
	* [Учетные записи ОС](#учетные-записи-ос)
	* [Группы ОС](#группы-ос)
	* [Команды для работы с пользователями и группами](#команды-для-работы-с-пользователями-и-группами)
 		* [Создание пользователя](#создание-пользователя)
   		* [Удаление пользователя](#удаление-пользователя)
		* [Изменение пользователя](#изменение-пользователя)
		* [Изменение пароля](#изменение-пароля)   
	* [Повышение привилегий](#повышение-привилегий)
		* ["su": Переключить пользователя](#su-переключить-пользователя)
		* ["sudo": Выполнить что-то с заменой пользователя (Substitute User Do)](#sudo-выполнить-что-то-с-заменой-пользователя-substitute-user-do)
	* [Разрешения на доступ к файлам и директориям](#разрешения-на-доступ-к-файлам-и-директориям)
		* [Цифровое представление разрешений](#цифровое-представление-разрешений)
		* [Команды для изменения разрешений доступа к файлам и директориям](#команды-для-изменения-разрешений-доступа-к-файлам-и-директориям)
		* [Особые случаи](#особые-случаи)
			* [Символические ссылки](#символические-ссылки)
			* [Sticky bit](#sticky-bit)
			* [Биты SUID и SGID](#биты-suid-и-sgid)
	* [Настройка беспарольного доступа по SSH](#настройка-беспарольного-доступа-по-ssh)
* [Исполняемые файлы, процессы и службы](#исполняемые-файлы-процессы-и-службы)
	* [Процессы и сигналы](#процессы-и-сигналы)
		* [Команда ps](#команда-ps)
		* [Команда pgrep](#команда-pgrep)
		* [Псевдо-директория /proc](#псевдо-директория-proc)
		* [Команда top](#команда-top)
		* [Сигналы](#сигналы)
	* [Службы](#службы)
		* [systemd](#systemd)
		* [Journalctl: вывод журналов служб systemd](#journalctl-вывод-журналов-служб-systemd)
* [Информация о системе](#информация-о-системе)
* [Файловые системы](#файловые-системы)
	* [Удаление папок и файлов](#удаление-папок-и-файлов)
	* [Поиск файлов (find)](#поиск-файлов-find)
* [Архивы и сжатие](#архивы-и-сжатие)
	* [gzip и bzip2](#gzip-и-bzip2)
	* [tar](#tar)
* [Передача файлов между компьютерами с помощью протокола SCP](#передача-файлов-между-компьютерами-с-помощью-протокола-scp)
* [Nano](#nano)

## Пользователи, группы и права доступа

### Учетные записи ОС

1. **Стандартные учетные записи**: создаются для обычных пользователей.  
> Стандартные учетные записи: могут входить в систему, выполнять команды и читать некоторые файлы или директории. Они не могут изменять любую часть ОС и "общесистемных" приложений. По умолчанию они могут изменять данные только в своих домашних директориях и /tmp.
2. **Административная учетная запись**: ее имя - root, и она является единственным администратором ОС (у вас не может быть двух root). Учетная запись root используется для прямого входа в систему очень редко; вместо этого администраторы временно повышают свои привилегии до root для обслуживания системы и других важных операций.  
> Административная (root) учетная запись: может входить в систему и делать все с ОС и пользователями без каких-либо ограничений (в отличие от Windows, где учетная запись администратора не настолько мощная, как учетная запись "Локальная система").
3. **Служебные учетные записи**: создаются для служб и других специальных целей; не должны использоваться пользователями. Например, для запуска бэкэнд-приложения (или приложения сервера базы данных) должна использоваться отдельная учетная запись.  Это минимизирует возможные последствия в случае сбоя или взлома приложения.  
> Служебные учетные записи: не могут входить в систему. ОС, службы и приложения (запускаемые root) используют их для специальных целей, например, для запуска определенных программ, служб и т.д.

**Основные настройки учетной записи: /etc/passwd**

`/etc/passwd` - это основной конфигурационный файл для учетных записей пользователей

`egrep ${USER} /etc/passwd` - информация о своей учетной записи.

Формат файла. В качестве разделителя полей используется ':', таким образом:  
`feodor:x:1000:100:User Description Here:/home/feodor:/bin/bash`  
* feodor - имя пользователя, должно быть уникальным
* x - поле не используется, поэтому мы имеем здесь 'x' как заглушку
* 1000 - идентификатор пользователя, называемый "UID", должен быть уникальным. Пользователи в основном имеют UID >= 1000. Пользователь root всегда имеет UID 0. Учетные записи служб имеют UID от 1 до (в основном) 999. Никто, кроме root, не должен иметь UID 0.
* 100 - идентификатор основной группы. Каждый пользователь должен быть членом хотя бы одной группы (не существует пользователей "без групп"). Если пользователей нужно включить в большее количество групп, это настраивается в /etc/group (см. следующий раздел).
* User Description Here - это поле может быть пустым или содержать что угодно, кроме ':'. Оно не играет никакой роли в ОС и механизмах входа в систему.
* /home/feodor - домашний каталог пользователя; вы автоматически помещаетесь сюда после успешного входа в систему
* /bin/bash - программа, выполняемая при успешном входе в систему. Сервисные учетные записи не предназначены для входа в систему и работы в командной строке, поэтому у них здесь указаны специальные "псевдо" программы, такие как /bin/false или /sbin/nologin

Хеши паролей хранятся в файле `/etc/shadow`

### Группы ОС

Понятие групп в UNIX:

* Группы включают несколько (0 или более) пользователей для упрощения управления пользователями и разделения привилегий
* Каждый пользователь должен быть членом как минимум одной группы - она задается в `/etc/passwd`, такая группа называется "основной" для конкретного пользователя
* Каждый пользователь может быть включен в 0 или более дополнительных групп, называемых "вторичными группами" (secondary groups). Членство во вторичных группах настраивается в файле `/etc/group`.
* Нет никакой разницы (в плане привилегий) между членством в первичной и вторичной группах.

`egrep ${USER} /etc/group`  
```
wheel:x:10:feodor
users:x:100:feodor,[ ... a lot of users here ... ]
feodor:x:1000:
qa:x:1001:feodor,user1,user2
```  
* Название группы
* Всегда 'x'
* Идентификатор группы, называемый "GID", должен быть уникальным
* Список членов группы, разделенный запятыми, может быть пустым

Членство в группе зависит от `/etc/passwd` и `/etc/group` - например, группа "qa" имеет только 3 явно включенных члена, но может быть много других членов в группах "qa", определенных в `/etc/passwd` путем указания 1001 в качестве основного GID. 

### Команды для работы с пользователями и группами

`whoami` - получить имя текущего пользователя

`id` - получить расширенную информацию о текущем пользователя и его членстве в группах  
`id -u` - только UID  
`id -G` - только GID  
`id -Gn` - имена групп

`groups` - имена групп

`last` - лог перезагрузок и авторизации в системе.

#### Создание пользователя

`sudo useradd name` - создание пользователя с настройками по умолчанию

`-b` Базовый каталог. Это каталог, в котором будет создана домашняя папка пользователя. По умолчанию /home  
`-с` Комментарий. В нем вы можете напечатать любой текст.  
`-d` Название домашнего каталога. По умолчанию название совпадает с именем создаваемого пользователя.  
`-e` Дата, после которой пользователь будет отключен. Задается в формате ГГГГ-ММ-ДД. По умолчанию отключено.  
`-f` Количество дней, которые должны пройти после устаревания пароля до блокировки пользователя, если пароль не будет изменен (период неактивности). Если значение равно 0, то запись блокируется сразу после устаревания пароля, при -1 - не блокируется. По умолчанию -1.  
`-g` Первичная группа пользователя. Можно указывать как GID, так и имя группы. Если параметр не задан будет создана новая группа название которой совпадает с именем пользователя.  
`-G` Список вторичных групп в которых будет находится создаваемый пользователь  
`-k` Каталог шаблонов. Файлы и папки из этого каталога будут помещены в домашнюю папку пользователя. По умолчанию /etc/skel.  
`-m` Ключ, указывающий, что необходимо создать домашнюю папку. По умолчанию домашняя папка не создается.  
`-p` Зашифрованный пароль пользователя. По умолчанию пароль не задается, но учетная пользователь будет заблокирован до установки пароля  
`-s` Оболочка, используемая пользователем. По умолчанию /bin/sh.  
`-u` Вручную задать UID пользователю.  

#### Удаление пользователя

`sudo userdel vasyapupkin` - удаление юзера

`-f` - принудительно удалить пользователя, даже если он сейчас работает в системе.  
`-r` - удалить домашний каталог пользователя.

#### Изменение пользователя

`sudo usermod -c "Эта команда поменяет комментарий пользователю" vasyapupkin` - изменение юзера.

usermod использует те же опции, что и useradd.

#### Изменение пароля

`sudo passwd vasyapupkin` - изменение пароля.

passwd может использоваться и обычным пользователем для смены пароля. Для этого пользователю надо ввести  
`passwd`  
и ввести старый и новый пароли.

Основные ключи passwd:  
`-d` Удалить пароль пользователю. После этого пароль будет пустым, и пользователь сможет входить в систему без предъявления пароля.  
`-e` Сделать пароль устаревшим. Это заставит пользователя изменить пароль при следующем входе в систему.  
`-i` Заблокировать учетную запись пользователя по прошествии указанного количества дней после устаревания пароля.  
`-n` Минимальное количество дней между сменами пароля.  
`-x` Максимальное количество дней, после которого необходимо обязательно сменить пароль.  
`-l` Заблокировать учетную запись пользователя.  
`-u` Разблокировать учетную запись пользователя.

### Повышение привилегий

#### "su": Переключить пользователя

Команда `su` используется для запуска оболочки от имени другого пользователя (по умолчанию root) после предоставления пароля пользователя. Соответственно, все, что выполняется в этой оболочке, будет выполняться с привилегиями целевого пользователя.   
Чтобы вернуться к предыдущему пользователю, выполните команду `exit`.

`su - username` - переключает терминал на указанного пользователя. Будет запрошен пароль. `-` - переключает окружение на окружение нового пользователя. Пользователь "root" может переключаться на любого другого без ввода пароля цели.  
`su - -c "id -u; whoami"` - выполнение нескольких команд от имени root без переключения терминала.  

#### "sudo": Выполнить что-то с заменой пользователя (Substitute User Do)

Инструмент `sudo` используется для запуска команды от имени другого пользователя (по умолчанию root) после предоставления пароля. Вводится собственный пароль, а не пароль целевого пользователя. "sudo" может быть настроен на разрешение или запрет выполнения определенных команд и их аргументов.  
`sudo` предназначен для того, чтобы позволить определенным пользователям выполнять определенные команды (и только их, ничего больше!) от имени другого, часто привилегированного, пользователя.  

`sudo -l` - проверить, какие команды разрешены текущему пользователю  
`sudo [-u username] command args` - синтаксис sudo  

### Разрешения на доступ к файлам и директориям

`-rw-r--r--`  
1й символ - тип файла:  
* '-' для типичных файлов  
* 'd' для каталогов  
* 'l' для символических ссылок  
* Другие: s, p, c, b - для специальных целей  

`rwx  rwx  rwx`  
USER-GROUP-OTHER (Владелец-Группа-Другие)

rwx  
READ-WRITE-EXECUTE (Чтение-Запись-Выполнение)  

|Бит|Значение для файлов|Значение для директорий|
|-|-|-|
|r - read (чтение)|Файл может быть прочитан, например, с помощью cat, less, head, других инструментов.|Список содержимого каталога может быть прочитан. Если бит 'x' не установлен, могут быть прочитаны только имена объектов.|
|w - write (запись)|Содержимое файла может быть изменено. Но сам файл не может быть удален - см. 'w' для каталогов.|Любой элемент этого каталога может быть создан или удален. То есть, даже если вы не являетесь владельцем файла в этом каталоге, вы можете удалить его, установив 'w' для каталога. Это можно сделать только в том случае, если бит 'x' также установлен.|
|x - execute (выполнение)|Файл может быть выполнен. Фактически исполняемые файлы: двоичные файлы и скрипты|Вы можете войти в этот каталог (например, с помощью "cd") и получить доступ (чтение, запись, выполнение) ко всему его содержимому, если это разрешено их правами доступа. Если у вас нет 'x' для каталога, вы НЕ можете: <ul><li> переходить в подкаталоги</li> <li> создавать/удалять объекты (файлы, каталоги)</li> <li>читать информацию об объекте (разрешения, владелец, ...)</li></ul>|

#### Цифровое представление разрешений

* r' равно 4 (100)  
* 'w' равно 2 (010)  
* 'x' равно 1 (001)  
* '-' равно 0 (000)  

все их комбинации являются суммами этих чисел, например:  
* 'r-x' равно 5 (101)
* 'rw-' равно 6 (110)
* 'rwx' равно 7 (111)

#### Команды для изменения разрешений доступа к файлам и директориям

`chown` (ИЗМЕНИТЬ ВЛАДЕЛЬЦА): для установки нового владельца и/или группы для объекта  
`chgrp` (ИЗМЕНИТЬ ГРУППУ): то же самое, но только для группы  
`chmod` (ИЗМЕНИТЬ РЕЖИМ): установить новые разрешения доступа к файлу  

Команда "chown" имеет ряд ограничений для "обычных" пользователей, ее полная мощность доступна только пользователю root:  
* изменить только владельца объекта - может быть выполнена только пользователем root
* изменить только группу объекта - может быть выполнена обычным пользователем, но этот пользователь должен быть членом новой группы (иначе требуются привилегии root)
* изменить владельца и группу объекта сразу - только для root

Синтаксис:  

`chown [-R] [username]:[group] object`  
-R - команда применяется ко всей директории

`chgrp [-R] group object`

`chmod 751 ~/chmod.me.dir` - Установим "rwxr-x--x", т.е. 751, на указанную директорию  
`chmod g+w,o+r ~/chmod.me.dir` - Добавляем "w" для группы и "r"-бит для прочих (others)  
`chmod u=rwx,g+w,o-r ~/chmod.me.dir` - Разрешаем владельцу делать что угодно с директорией, добавляем права на запись группе, отбираем права на чтение у прочих (others)  
`chmod -R go-rwx ~/chmod.me.dir` - Меняем права доступа для всего каталога, отнимаем все права у группы и прочих (others)

#### Особые случаи

##### Символические ссылки
<hr>
**Символические ссылки** всегда имеют разрешения 777, но это ничего не значит, поскольку фактические разрешения доступа такие же, как у целевого объекта.
<hr>

##### Sticky bit

Может использоваться для директорий наряду с "обычными" битами доступа rwx. Если он установлен, **только владельцы могут удалять объекты**, независимо от разрешения других (например, 777 для /tmp). Sticky bit отображается как '**t**' в конце "слова" разрешения доступа: "drwxrwxrwt".  
sticky bit имеет цифровое значение 1: например, 1777.  

Он может быть установлен в цифровой или символьной форме:
`chmod +t /some/dir`  
`chmod 1777 /some/dir`  
<hr>

##### Биты SUID и SGID

Бит SUID (Set User ID) может использоваться для исполняемых файлов. Если он установлен, этот файл всегда будет **выполняться от имени владельца**. Бит SUID отображается как '**s**' вместо 'x' в блоке разрешений владельца:  
`-rws--x--x`  

Бит SGID - тоже самое для групп:
`-r-xr-sr-x`

Бит SUID имеет цифровое значение 4, а SGID - 2:  
`4755/-rwsr-xr-x`  
`2555/-r-xr-sr-x`

Эти специальные биты можно установить с помощью инструмента chmod:  
```
# SUID bit
chmod u+s /path/to/file
chmod 4xyz /path/to/file

# SGID bit
chmod g+s /path/to/file
chmod 2xyz /path/to/file
```
<hr>

### Настройка беспарольного доступа по SSH

1. На **сервере** в `/etc/ssh/sshd_config` нужно добавить (или раскомментировать) строки:  
   `PubkeyAuthentication yes`  
   `AuthorizedKeysFile     %h/.ssh/authorized_keys`

2. Применить изменения на **сервере**:  
   `sudo systemctl restart sshd`  
   или  
   `sudo service ssh restart`

3. Генерируем пару ключей:  
   `ssh-keygen -t rsa -b 4096 -C "gitlab-ci-deploy" -f ci_deploy_key -N ""`  
   `-f ci_deploy_key` — имя файла (создаст ci_deploy_key и ci_deploy_key.pub)  
   `-N ""` — пустая passphrase

4. Публичный ключ копируем в файл на **сервере** `~/.ssh/authorized_keys`  
   Нужно следить, чтобы у директории .ssh были права доступа 700, а у файла authorized_keys - 600

5. Приватный ключ прописываем в ssh агенте в терминале, с которого будем подключаться (на **клиенте**).  
   `eval "$(ssh-agent -s)"`  
   `ssh-add ~/.ssh/ci_deploy_key`  

   Возможно нужно будет сначала очистить файл от виндовского символа перевода каретки '\r', например, так:  
   `cat ci_deploy_key | tr -d '\r' > ~/.ssh/ci_deploy_key`

6. Подключаемся (с **клиента**):  
   `ssh username:host`

7. Посмотреть логи авторизаций (на **сервере**):  
   `sudo tail -n50 /var/log/auth.log`

## Исполняемые файлы, процессы и службы

**PATH** - это переменная оболочки (shell variable), которая содержит список каталогов для поиска исполняемых файлов.  
`echo $PATH`  

`env` - список переменных оболочки

"which” это команда для показа **расположения исполняемого файла** в каталогах PATH
`which uname`

Запуск исполняемого файла, не прописанного в PATH:  
`./executable_file`  
нужно указать директорию, в которой находится файл. `./` - текущая директория.

`&` - запуск команды, как **фоновой** задачи  
`sleep 2000 &`

Ctrl+Z - **приостановка** выполнения команды  
Ctrl+C - **остановка** выполнения команды  

`jobs` - показывает все задания оболочки с их идентификаторами и статусами

**Возобновить** выполнение задачи можно, вызвав команду "bg" (это также встроенная команда оболочки, ее название означает "background" - "фон") с %ID задачи, которую нужно возобновить. Указанная задача будет отправлена на фоновое выполнение.  
`bg %1` - возобновление задачи с ID 1 в фоне

Команды также могут быть переведены на **передний план** с помощью встроенной оболочки "fg".  
`fg %1`

Любая задача оболочки может быть завершена командой "kill".  
`kill %2`

"**Алиас**" (псевдоним) - это определенное пользователем имя существующей команды (и, возможно, ее опций). Если "b" является псевдонимом для "a --option1 --option2", то когда оболочке входа в систему предлагается выполнить "b --some-options arguments", на самом деле вместо этого будет выполнено "a --option1 --option2 --some-options arguments"  
`alias` - Просмотр существующих псевдонимов  

Пользователи могут определять свои собственные псевдонимы и переменные оболочки в файлах `~/.bashrc` и(или) `~/.bash_profile`  
Также псевдонимы можно определять «на ходу». В таком случае они будут действовать до завершения текущего сеанса оболочки.
`alias rm='echo You are trying to execute "rm" with the following arguments: '`

Если псевдоним более не нужен, можно "приказать" оболочке "забыть" о нем с помощью встроенной команды `unalias`

### Процессы и сигналы

**Процесс операционной системы (ОС)** — это экземпляр исполняемой программы, выполняемый системой в настоящее время. Это означает, что если программа заканчивает свою работу или завершается пользователем, то процесс также прекращает своё существование.  

Каждый процесс имеет несколько следующих основных атрибутов (их на самом деле намного больше, но обычно остальные используются только для низкоуровневого программирования и системного администрирования):

* PID - идентификатор процесса. Уникален для каждого выполняющегося процесса. То есть в каждый момент времени все процессы имеют различные идентификаторы PID. При повторном запуске той же программы соответствующие создаваемые процессы будут обладать новыми PID.
* PPID — родительский идентификатор (PID). Процессы не возникают сами по себе, они создаются другими процессами. Таким образом, PPID - это PID родительского процесса.
А кто запускает самый первый процесс? «Главный» системный процесс называется init или systemd и обладает PID = 1, PPID = 0. Он создаётся ядром операционной системы при её загрузке.
* Пользователь и группа, запустившие программу.
* Название.
* Аргументы командной строки.
* Управляющий терминал

**Демоны** — это особый вид процессов. По существу, демон — это процесс, работающий в фоновом режиме и не взаимодействующий с пользователями посредством терминала.  
Процесс-демон обладает следующими свойствами:
* PPID = 1
* Управляющий терминал отсутствует
* В большинстве случаев текущей рабочей директорией демона является "/"

#### Команда ps

Отображает список процессов, работающих в текущий момент времени, а затем завершает свою работу. Самые полезные ее опции следующие:
* `-e` для отображения всех процессов всех пользователей. По умолчанию показываются процессы только текущего пользователя.
* `-f` для вывода расширенных сведений о каждом процессе. По умолчанию отображается только ограниченный объём информации.
* `-u` username для отображения процессов, запущенных пользователем c данным именем (username).
* `-p PID` - для вывода сведений об процессе с данным PID.
* `-o поле1, поле2,...` - для вывода определённых сведений о процессах (см. подробное руководство с помощью команды man ps).
* `--forest` для отображения процессов в виде дерева.

#### Команда pgrep

Помогает быстро найти процесс (или процессы), используя логику, аналогичную инструменту "egrep". Ниже приведены ее основные параметры:
* `-f` для поиска в полной командной строке (т.е. как имена команд, так и аргументы). По умолчанию проверяются только имена команд.
* `-a` для вывода списка всей командной строки, а не только PID.

#### Псевдо-директория /proc

Это виртуальная файловая система, содержащая множество сведений о работающих процессах.  Её называют псевдо-файловой системой, так как в реальности на диске нет файлов, расположенных в директории /proc. Вместо этого ядро операционной системы отображает информацию в виде файлов и директорий в директории /proc.  
Все команды, относящиеся к процессам, такие как ps, pstree, pgrep, берут информацию из директории /proc.  
Можно получить информацию о ваших процессах напрямую из директории /proc.  
Чтобы узнать точный путь к исполняемому файлу и (или) текущую рабочую директорию, можно напрямую обратиться к директории /proc.  
Символьная ссылка `exe` указывает на соответствующий исполняемый файл, а `cwd` — на текущую рабочую директорию

#### Команда top

Команда top выводит в реальном времени сведения о работающих процессах и текущую нагрузку на систему (центральный процессор, память, задачи), а также позволяет отправлять процессам сигналы и завершать их работу. В отличие от ps, команда top работает, пока пользователь не остановит её, и показывает объём используемых системных ресурсов в реальном времени.
Она обновляет экран каждые несколько секунд.

Основные горячие клавиши для программы `top`:

* q - выход из программы (quit)
* 1 (один) — отображение или скрытие сведений о загрузке процессора.
* P — упорядочивание процессов согласно использованию ресурсов процессора (режим по умолчанию).
* M — упорядочивание процессов согласно использованию ресурсов памяти.
* E — отображение сведений об использовании памяти не в КБ, а в МБ (единичная E) или ГБ (нажмите E дважды).
* k — отправка сигнала процессу (нажмите Esc, если вы уже начали отправку сигнала, но затем передумали).

**us** и **sy** — время процессора, используемое процессами пользователей и процессами операционной системы соответственно. В сумме с "wa" (показано ниже) дает общую нагрузку на систему.
**id** — время простоя в %; 100 означает, что система полностью свободна, 0 означает, что система полностью занята.
wa — время ожидания процессором медленного ввода-вывода. Высокое значение wa означает проблемы с нагрузкой на диск или иногда проблемы с сетью.

#### Сигналы

Сигнал — это короткое сообщение, которое можно отправить процессу.  
Сигналы представляют самый простой вариант взаимодействия между процессами (inter-process communication — IPC).

Чтобы отправить сигнал ЧТО (например, TERM, KILL, STOP и т. д.) процессу с идентификатором PID:  
`kill [-ЧТО] PID`

`[-ЧТО]` означает номер или название сигнала, эта опция необязательна, по умолчанию отправляется сигнал `TERM`.  
Например, чтобы завершить процесс самым "жёстким" способом без возможности корректного завершения своей работы, можно использовать следующую команду:  
`kill -KILL PID`
или  
`kill -9 PID`

Для отправки одного и того же сигнала нескольким процессам с одинаковым названием удобно применять команду `killall`:  
`killall [-ЧТО] [другие опции] название_процесса`

Для отправки одного и того же сигнала нескольким процессам, названия которых отвечают некоторым условиям, используется команда `pkill`.  Она похожа на команду pgrep, но отправляет сигнал ЧТО процессам, названия которых (и аргументы, если указана опция -f) соответствуют шаблону
`pkill [-ЧТО][другие опции] название_процесса`

Важные замечания о сигналах:
* Обычные пользователи могут отправлять сигналы только своим процессам.
* root может отправлять сигналы всем.
* Следует помнить: команда kill НЕ просто завершает процессы! Она отправляет сигналы.

Самые полезные сигналы (используемые на месте ЧТО) с указанием их имен и номеров:

* `TERM (15)`, terminate — завершить: отправляется по умолчанию. Означает «мягкое» завершение работы процесса: вначале удаляются все временные файлы, закрываются все открытые файлы и т. д., а затем завершается работа.
* `KILL (9)`, kill — уничтожить: безусловное завершение работы процесса.
* `INT (2)`, interrupt — прервать: отправляется, когда пользователь нажимает клавиши Ctrl+C. В большинстве случаев завершает работу соответствующего процесса.
* `TSTP (20)`, terminal (TTY) stop — остановка посредством терминала: отправляется, когда пользователь нажимает клавиши Ctrl+Z. Предназначен для процессов, работающих в интерактивном режиме. Приостанавливает выполнение процесса.
* `STOP (19)`, stop — остановить: приостанавливает работу процесса аналогично TSTP, но может использоваться для любых процессов, включая демонов. Так же, как и сигнал KILL, не может быть проигноирован процессом.
* `CONT (18)`, continue — продолжить: отправляется, когда пользователь выполняет команду fg или bg с целью снова запустить работу процесса. Работу всех процессов, остановленных с помощью сигнала STOP, можно возобновить сигналом CONT.

### Службы

Служба Linux может быть представлена как "обертка" для лучшего управления приложениями. Когда приложение управляется как сервис, а не как список разрозненных процессов, гораздо проще запускать, останавливать, перезапускать, получать текущее состояние и настраивать его поведение в зависимости от событий ОС.
Проще говоря: когда пользователи запускают программу, они отвечают на вопрос "ЧТО должно быть выполнено". Сервис, построенный вокруг той же программы, отвечает на вопрос "КАК именно следует управлять этой программой", например:
* Должна ли она запускаться во время загрузки системы?
* Как запустить ее вручную при необходимости?
* Какие опции предоставляются программе при запуске?
* Как отслеживать ее состояние?
* Как аккуратно завершить ее работу?
* Нужно ли перезапускать ее в случае нештатного завершения?
* Какие другие службы должны быть запущены перед запуском этой конкретной?

#### systemd

* systemd — это большой комплект программного обеспечения (ПО), ответственный за инициализацию системы и управление службами.
* Systemd оперирует следующими объектами, называемыми "юнитами":
	* Службы (services) — обычно это серверное ПО, такое как веб-сервер Apache, серверы баз данных, почтовые серверы и т. д.
	* Цели (targets) — группы других юнитов (служб и т. д.), которые необходимо запускать совместно (например, в ходе запуска системы).
	* Другие (сокеты, таймеры…)

Службы в Linux реализованы в виде модулей (unit) systemd.

Для настройки и отслеживания служб можно использовать следующие инструменты:

1. Службы, добавленные к systemd вместе с их настройками (известными также как юнит-файлы), находятся в директории `/etc/systemd/system` и ее вложенных директориях. Обычно юнит-файлы представляют собой символьные ссылки на «настоящие» файлы, расположенные в директории `/usr/lib/systemd/system`.
2. Службы (service), уже «известные» systemd, а также их состояние можно просмотреть с помощью следующей команды. Она отображает информацию аналогично командам man и less:  
`systemctl list-units --type=service`
3. Чтобы посмотреть только службы, которые запущены (running) в настоящий момент, можно использовать дополнительную опцию:  
`systemctl list-units --type=service --state=running`
4. Чтобы увидеть, какие службы были запущены в ходе загрузки ОС, выполните команду, показанную ниже. «Включённые» (enabled) службы запускаются вместе с ОС. «Выключенные» (disabled) службы — не запускаются. «Статические» (static) службы запускаются без условий, их нельзя включить или выключить, как другие.  
`systemctl list-unit-files --type=service`
5. Чтобы увидеть только включенные службы, выполните следующее:  
`systemctl list-unit-files --type=service --state=enabled`
6. Проверка текущего состояния службы с названием название_службы:  
`systemctl status название_службы`
7. Узнать текущее состояние службы, относящейся к конкретному процессу. Это самый простой способ соотнести процесс, имеющий известный идентификатор PID, с соответствующей службой:  
`systemctl status PID_процесса`
8. Запуск (start), остановка (stop) и перезапуск (restart) службы:  
```
systemctl start название_службы
systemctl stop название_службы
systemctl restart название_службы
```
9. Включение и отключение автоматического запуска службы на этапе загрузки ОС. Опция --now используется, чтобы добавить службу в автозагрузку и одновременно запустить её или исключить из автозагрузки и одновременно остановить (в зависимости от состояния службы):  
`systemctl enable|disable [--now] название_службы`
10. Узнать настройки автоматического запуска конкретной службы:  
`systemctl is-enabled название_службы`

Важные замечания:

* Для выполнения пунктов 8 и 9 необходимы права root. Эти права можно также получить с помощью соответствующей настройки команды sudo (эта настройка уже выполнена на учебных серверах Mentorpiece).
* Юниты служб работают только как "обертки" для соответствующего ПО; само ПО можно запустить напрямую даже без помощи systemd. Но systemd предоставляет более удобные инструменты для управления службами.
* Юниты служб не являются серверными приложениями!
* Юниты (включая службы) — это сущности systemd, которыми можно управлять с помощью команд.
* Юнит-файлы — это файлы конфигурации служб (а НЕ файлы конфигурации серверных приложений), например:
	* Файлы конфигурации приложений содержат параметры, относящиеся непосредственно к приложению: номер сетевого порта для прослушивания; место, где необходимо сохранять данные; настройки взаимодействия (при необходимости) с другими приложениями и многие другие.
	* Файлы конфигурации служб содержат команды для запуска и останова этих служб, имена пользователей и названия групп, от имени которых необходимо запускать службы, зависимости от других служб (если таковые имеются) и т. д.
	
#### Journalctl: вывод журналов служб systemd

Файлы журналов служб systemd:
* обычно содержат меньше информации по сравнению с файлами журналов приложений (записываются только основные события);
* хранятся в едином двоичном формате;
* доступ к ним можно получить с помощью команды `journalctl`

1. Просмотр всех записанных в журнал событий для службы название_службы. Данные журнала показываются так же, как и в случае с командами less и man, поэтому доступны все те же функции: поиск по шаблонам и т. п.  
`journalctl -u service_name`
2. То же самое, но с переходом к последним строкам журнала:  
`journalctl  -e -u service_name`
3. Отслеживание событий службы в реальном времени и вывод их на терминал, наподобие команды tail -f (нажмите Ctrl+C для выхода):  
`journalctl -f -u service_name`
4. Просмотр событий от нескольких служб одновременно. Эту функцию можно сочетать с другими опциями, например -f:  
`journalctl -u service_name_1 -u service_name_2 ...`

## Информация о системе

Наиболее востребованная и запрашиваемая информация следующая:

1. Версия ядра операционной системы (ОС).
2. Название и версия дистрибутива Linux.
3. Имя компьютера, IP-адрес(а) и другие настройки сети.
4. (В некоторых случаях.) Запущенные процессы и службы.
5. (В некоторых случаях.) Сведения об аппаратном обеспечении: центральном процессоре (ЦП), памяти и жёстких дисках.
6. (В некоторых случаях.) Подключённые файловые системы, их полный и свободный объём.

`uname -a` - полная **информация о системе**

`uname -r` - **версия ядра**

`cat /etc/os-release` - **версия ОС**

`lscpu` - **информация о ЦП**  
`cat /proc/cpuinfo` - информация о ЦП

**Объём памяти** показывается командой `free` в килобайтах (по умолчанию). Опция "-m" — для отображения в МБ.  
`free -m` - в МБ  
`free -h` - человекочитаемый вид (ГБ, МБ, КБ)

* **дисковые устройства** (внутренние и внешние, такие как подключённые USB-устройства флэш-памяти) — используйте команду `lsblk`;
* **устройства PCI**, такие как сетевые интерфейсы, контроллеры Wi-Fi, видеокарты — используйте команду `lspci`;
* **периферийные устройства**, обычно подключаемые к порту USB — запустите команду `lsusb`.

`iptraf-ng` - загрузка сети

`uptime` - время работы системы. Средняя загрузка.   
The current time, how long the system has been running, how many users are currently logged on, and the system load averages for the past 1, 5, and 15 minutes.  
`-s, --since` - system up since.

## Файловые системы

Каждая файловая система ОС Linux подключена к определённому месту главного «дерева» иерархии файлов и директорий. Действие по подключению файловой системы к надлежащему месту дерева называется монтированием (mounting), это специальное место называется точкой монтирования (точкой подключения, mounting point).

С помощью команды `mount` (mount — англ., монтировать, устанавливать) можно посмотреть, как физические (и виртуальные) устройства подключены к своим **точкам монтирования** (каждая точка монтирования — это существующая директория).

`df` - показывает использование **дискового пространства** для всех подключённых файловых систем.  
`-m` - для использования мегабайтов  
`-h` - для удобного для человека формата вывода  

Если в файловой системе закончится место, то будет показано сообщение об ошибке: «No space left on device»  

Для каждого файла и директории в файловой системе есть специальная отдельная запись, называемая индексным дескриптором, или **inode** (index node), в которой хранятся настройки прав доступа, указан владелец-пользователь и группа-владелец и другая служебная информация, называемая метаданными и метаинформацией.  
Для каждого файла и каталога необходим свой дескриптор.  
Для каждого дескриптора требуется немного дискового пространства, поэтому в файловой системе может быть только ограниченное количество дескрипторов, устанавливаемое в момент создания файловой системы (создание файловой системы — это то же самое, что и форматирование диска в ОС Windows). Когда индексные дескрипторы заканчиваются, в файловой системе уже больше нельзя создавать новые объекты, и поэтому выводится сообщение об ошибке «No space left on device».

`df -i` - отображение дескрипторов inode, вместо дискового пространства

Команда `du` - подсчитывает **размер каталогов**.  

`du -sm`  
`-s` - суммарно  
`-m` - в МБ  
`-h` - ГБ, МБ, КБ

Этот инструмент может посчитать размер только тех каталогов, для которых у вас есть права на чтение и выполнение, остальные будут проигнорированы с выводом сообщения об ошибке «Permission denied» (в доступе отказано).

### Создание каталогов

`mkdir папка` - в текущей директории  
`mkdir Загрузки/папка` - по относительному пути  
`mkdir /home/имя_вашего_пользователя/папка` - по полному пути  

`mkdir {папка1,папка2,папка3}` - несколько папок  

`mkdir -p ~/Загрузки/папка/папка/папка/папка` - создание нескольких уровней папок  
`mkdir -p ~/Загрузки/папка/{папка1,папка2,папка3}`



### Удаление папок и файлов

`rm /home/user/file` - удалить файл  
`-f` - без подтверждения  
`-Rf` - удалить дирректорию с файлами

`rmdir` - удалить **пустую** дирректорию

`shred /home/user/file` - стереть содержимое файла (чтобы нельзя было восстановить)  
`-z` - затереть нулями  

### Поиск файлов (find)

`find [папка] [параметры] критерий шаблон [действие]`  
`Папка` - каталог в котором будем искать.  
`Параметры` - дополнительные параметры, например, глубина поиска, и т д.  
`Критерий` - по какому критерию будем искать: имя, дата создания, права, владелец и т д.  
`Шаблон` - непосредственно значение по которому будем отбирать файлы.

**Параметры**

`-P` - никогда не открывать символические ссылки.  
`-L` - получает информацию о файлах по символическим ссылкам. Важно для дальнейшей обработки, чтобы обрабатывалась не ссылка, а сам файл.  
`-maxdepth` - максимальная глубина поиска по подкаталогам, для поиска только в текущем каталоге установите 1.  
`-depth` - искать сначала в текущем каталоге, а потом в подкаталогах.  
`-mount` искать файлы только в этой файловой системе.  
`-version` - показать версию утилиты find.  
`-print` - выводить полные имена файлов.  
`-type f` - искать только файлы.  
`-type d` - поиск папки.

**Критерии**

`-name` - поиск файлов по имени.  
`-perm` - поиск файлов по режиму доступа.  
`-user` - поиск файлов по владельцу.  
`-group` - поиск по группе.  
`-mtime` - поиск по времени модификации файла.  
`-atime`- поиск файлов по дате последнего чтения.  
`-nogroup` - поиск файлов, не принадлежащих ни одной группе.  
`-nouser` - поиск файлов без владельцев.  
`-newer` - найти файлы новее чем указанный.  
`-size` - поиск файлов по их размеру.

`-iname` - не учитывать регистр при поиске по имени.

`-not` - инвертирование шаблона.

Можно искать по нескольким условиям, перечисляя их одно за другим (логическое "И"):  
`find . -name "test" -not -name "*.php"`  

Можно искать, используя логическое "ИЛИ":  
`find -name "*.html" -o -name "*.php"`

По умолчанию find ищет как каталоги, так и файлы.

Можно искать в нескольких каталогах, перечисляя их один за другим.

***Поиск по времени***  
`find / -mtime 50` - найти все файлы модифицированные 50 дней назад.  
`find / -mtime +50 -mtime -100` - найти все файлы, модифицированные между 50 и 100 дней назад.  
`find -cmin -600` - файлы, измененные за последние 600 минут

***Поиск файлов по размеру***
`find / -size 50M`  
`find / -size +50M -size -100M`

`find . -type f -exec ls -s {} \; | sort -n -r | head -5` - найти самые большие файлы

***Поиск пустых файлов и папок***  
`find /tmp -type f -empty`  
`find ~/ -type d -empty`

***Действия с найденными файлами***  
Для выполнения произвольных команд для найденных файлов используется опция `-exec`.  
Например, для того чтобы найти все пустые папки и файлы, а затем выполнить `ls` для получения подробной информации о каждом файле используйте:  
`find . -empty -exec ls -ld {} \;`

Удалить все текстовые файлы в tmp:  
`find /tmp -type f -name "*.txt" -exec rm -f {} \;`


## Архивы и сжатие

### gzip и bzip2

"gzip" и "bzip2" - это стандартные инструменты сжатия в Linux для уменьшения размера любого конкретного файла, подобно "zip" в Windows. Но в отличие от "zip", они не могут работать с несколькими файлами (в том числе директориями) одновременно. 

* gzip устанавливается везде, bzip2 является опциональным и может отсутствовать.
* Они могут сжимать и распаковывать ТОЛЬКО отдельные файлы (НЕ каталоги).
* Они могут читать ввод из stdin, т.е. действовать по принципу "что-то ... | gzip -9c > /some/where".
* Входные файлы удаляются по умолчанию, если не указана опция "-c".
* bzip2 сжимает лучше, чем gzip, но работает дольше.
* Оба инструмента однопоточны, т.е. могут использовать только одно ядро процессора, а не все сразу.

`-1...-9` - степень сжатия от 1 до 9, где 1 - минимальная, 9 - максимальная.
`-d` - распаковать файл. Коэффициент сжатия здесь не требуется.
`-с` - вывести результат на stdout. Входные файлы не удаляются при использовании "-с"

### tar

"tar" - это основной инструмент для создания архивов из нескольких файлов. То есть, имея на входе каталог, "tar" конкатенирует его содержимое в один файл.  
"tar" также может создавать сжатые архивы за один раз, подобно инструменту Windows "zip".

`-f /path/to/file.tar` - имя входного или выходного файла  
`-с` - создать архив  
`-t` - вывести список его содержимого  
`-x` - извлечь все объекты  
`-z` - сжать архив с помощью gzip во время создания  
`-j` - сжать архив с помощью bzip2 (если установлен) во время создания  

1. Создать архив директории можно следующим способом:  
`tar -c -f /путь/к/архиву.tar /некая/директория`

2. Отобразить содержимое архива, то есть вывести имена файлов и директорий в стандартный поток вывода stdout:  
`tar -t -f /путь/к/архиву.tar`

3. Извлечь содержимое архива в текущую директорию:  
`tar -x -f /путь/к/архиву.tar`

4. Извлечь содержимое архива и поместить в другое место, НЕ в текущую директорию:  
`tar -x -f /путь/к/архиву.tar -C /новое/место`  
Содержимое архива будет распаковано и помещено в /новое/место. Это место должно существовать перед выполнением “tar -xf” 

5. Архивировать каталог с помощью gzip:  
`tar -czf /путь/к/архиву.tar.gz некая_директория`

6. Архивировать каталог некий_каталог с помощью bzip2 (если bzip2 установлен):  
`tar -cjf /путь/к/архиву.tar.bz2 некая_директория`

7. Показать содержимое архива:  
`tar -tf /путь/к/архиву.tar.gz`

8. Распаковать архив в текущую директорию:  
`tar -xf /путь/к/архиву.tar.bz2`

"tar" также может работать с пайпами. Например, если вы хотите использовать экзотический инструмент сжатия, не поддерживаемый tar внутренне (например, 7z или lzma), вы можете использовать "tar" с опцией "-f -", что означает "работать с stdin или stdout вместо обычных файлов".  
```
# Архивирование директории с помощью gzip с использованием пайпов
tar -cf - /path/to/dir | gzip -9c > my-archive.tar.gz

# Архивирование директории с помощью bzip2 с использованием пайпов
tar -cf - /path/to/dir | bzip2 -9c > my-archive.tar.bz2

# Распаховка существующего архива с использованием пайпов
gzip -dc my-archive.tar.gz | tar -xf -
bzip2 -dc my-archive.tar.bz2 | tar -xf -
```

## Передача файлов между компьютерами с помощью протокола SCP

Для передачи файлов с (или на) Linux-машин по сети следует использовать протокол **SCP** (Secure CoPy, или SSH CoPy). Соответствующий инструмент командной строки под названием "scp" поставляется с Linux, macOS и современными версиями Windows; для предыдущих версий Windows необходимо отдельно установить программу WinSCP, а также PuTTY для SSH-соединений.

* SCP работает "поверх" SSH. Чтобы работать с удаленными машинами, необходимо иметь соответствующие учетные данные для входа в систему SSH. Логины и пароли такие же, как и для входа в SSH.
* SCP позволяет отправлять и получать как файлы, так и директории.
* SCP поддерживается всеми UNIX-подобными ОС, включая Linux и macOS, а также многими сетевыми устройствами, такими как Cisco.

1. Отправка (т. е. загрузка) файла на компьютер с именем host, который можно указать как в виде IP-адреса, так и в виде доменного имени. Для сессии SSH и, соответственно, для отправки файла будет использоваться учётная запись someone:  
`scp некий_файл someone@host:/путь`

В первую очередь, чтобы выполнить команду, необходимо ввести пароль для учётной записи someone. После выполнения команды этот файл появится на компьютере host в директории /путь (она обязана существовать). Название файла останется прежним (некий_файл).

2. То же самое, но этот файл будет скопирован на компьютере host как
"/путь/другой_файл":  
`scp некий_файл someone@host:/путь/другой_файл`

Если файл /путь/другой_файл уже существует, он будет  перезаписан содержимым файла некий_файл, так же, как и в случае с командой cp.

Перезапись целевого файла (если он существует на момент запуска команды) выполняется как при загрузке, так и при скачивании.
Важно: при перезаписи файлов никаких предупреждений не выводится. Для SCP нельзя задать поведение, аналогичное "cp -i".

3. Для копирования всей директории со всем содержимым нужна опция "-r", так же как и для команды cp:  
`scp -r someone@host:/path/to/target_dir ~/`

Это пример скачивания с использованием SCP.
В результате вы получите директорию “target_dir”, созданную в вашей домашней директории.

## Nano

`nano [опции] </путь/файл>`

`+номер` - указать строку в файле, с которой нужно начинать редактирование;  
`-B` - создавать резервную копию для файла при сохранении;  
`-С` - папка для резервной копии;  
`-D` - выводить текст жирным;  
`-E` - конвертировать табуляции в пробелы;  
`-F` - включить поддержку редактирования нескольких файлов;  
`-H` - сохранять историю поиска и замены;  
`-I` - не читать конфигурацию из файлов nanorc;  
`-P` - запоминать и восстанавливать позицию курсора во время последнего редактирования;  
`-T` - размер табуляции в пробелах;  
`-m` - включить поддержку мыши;  
`-v` - режим только для чтения, вы не можете сохранить файл.

`Ctrl+O` - сохранить файл  
`Ctrl+X` - выход  
`Ctrl+R` - вставить содержимое другого файла на позицию курсора  
`Ctrl+W` - поиск  
`Alt+R` - поиск и замена  
`Ctrl+V` - перемещение на страницу вниз  
`Ctrl+Y` - перемещение на страницу ввверх

`Alt+A` - выделить  
`Alt+6` - копировать
`Ctrl+U` - вставить
`Ctrl+K` - вырезать. Если ничего не выделено, вырезает целую строку

`Alt+U` - отменить  
`Alt+E` - повторить  
  
Можно открыть несколько файлов:  
`nano <файл1> <файл2>`  
переключение между файлами:  
`Alt+>` и `Alt+<`









