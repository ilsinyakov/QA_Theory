# Appium

## Appium Framework

**Appium** — это кросс-платформенный open source инструмент для автоматизации тестирования десктоп и мобильных приложений под Android и iOS. Архитектура Appium схожа с Selenium WebDriver, широко распространенным и ставшим стандартом в web-тестировании. Кроссплатформенность достигается за счет использования разных драйверов для разных платформ. Именно драйверы транслируют клиентский Appium-код в команды, непосредственно исполняемые на устройствах.

![Appium Framework](https://github.com/ilsinyakov/QA_Theory/blob/main/Pictures/appium.jpeg?raw=true)

**Стабильность**. Как видно из рисунка, Appium является довольно громоздкой оберткой. По сути он представляет собой целый HTTP-сервер на Node.JS, который создает и обрабатывает WebDriver-сессии, где и происходит общение с конечным драйвером команд на устройстве. Такое сложное устройство хоть и позволяет абстрагироваться от платформы, все же негативно сказывается как на скорости, так и на стабильности тестов. К сложным и громоздким механизмам, скрытым в драйверах, Appium добавляет собственный оверхэд.

**Универсальность**. Appium умеет абстрагироваться не только от платформы, но и от используемого драйвера. В случае Android он с помощью своих адаптеров может транслировать команды как в черный ящик UiAutomator, так с недавнего времени и в белый ящик Espresso. Адаптер к драйверу, который будет использоваться в тесте, указывается при конфигурации перед началом теста. Также есть возможность использовать сразу несколько адаптеров. Это позволит в пределах одного теста работать и с Espresso и с UiAutomator.

**Выразительный API**. Для написания тестов Appium предоставляет клиентские библиотеки с фиксированным фасадным API, очень похожим на WebDriver. Appium не предлагает никакой архитектуры для тестов, все отдается на откуп конечному разработчику.

**Гибкость**. Перед началом теста есть возможность задать конфигурацию, например, ОС на мобильном устройстве, ее версию, тип девайса (реальный или эмулятор), таймаут ожидания ответа от Appium-сервера, язык, ориентацию, указать экран приложения, с которого стартует тест. Также перед началом теста можно указать, какой драйвер будет использоваться. Однако гибкостью настроек и конфигурации все ограничивается — функциональность драйвера не может быть расширена.

**Логи**. Не предоставляет инструмента для логирования шагов, действий и проверок теста.

**Скриншоты**. Из коробки готовой функции нет, хотя ее несложно добавить самостоятельно.

**Доступ к adb**. Благодаря своей клиент-серверной архитектуре у Appium’а нет проблем с тем, чтобы посылать на девайс adb-команды. Это, бесспорно, является его плюсом.

**Итог**. Appium подкупает своей кроссплатформенностью. Он активно развивается — Espresso драйвер был добавлен не так давно. Однако сложная клиент-серверная архитектура как плата за кроссплатформенность не позволяет добиться высокой стабильности тестов, что вкупе со сложностью инициализации тестовых сессий сильно увеличивает длительность прохождения тест сьютов в сравнении с конкурентами.

Также стоит отметить, что Appium — это отдельная и зачастую чуждая Android-разработчикам технология. К тому же, если в вашем проекте используется Kotlin, в тестах придется вернуться к Java. Из-за этой чуждости Appium часто встречает неприятие со стороны разработчиков.

## Установка и настройка

Стек работы с Appium состоит из следующих инструментов:

- appium-сервер
- драйверы устройств
- Android Studio
- Appium Inspector
- ADB

### Appium сервер

Appium по своей сути представляет собой сервер, написанный на node.js. Сервер работает по клиент-серверной архитектуре. В соответствии с архитектурой клиент-сервер клиент подключается к серверу, чтобы воспользоваться любым сервисом, размещенным на сервере. Общение между клиентом и сервером происходит в виде запросов и ответов.

В Appium клиент отправляет запросы на автоматизацию на сервер Appium.

Appium запускает на устройстве «тестовый пример», который порождает сервер и слушает прокси-команды от главного сервера Appium. Тестировщик пишет свои тестовые сценарии, которые выполняются на устройстве или эмуляторе, отправляя их в виде запросов на сервер Appium. Каждый производитель, например iOS и Android, имеет свой способ и механизм запуска тестового сценария на устройстве. Таким образом, Appium как бы взламывает его и запускает тестовый пример после получения команд от сервера Appium.

Appium по-разному работает на iOS и Android. Поскольку Appium является «кроссплатформенным» инструментом, необходимо создать механизм, позволяющий различать сеансовые запросы для двух операционных систем. Эта задача также была решена с помощью JSON-объектов, называемых Desired Capabilities.

**Desired Capabilities** — это пары ключ-значение информации, которые отличают создание сессии для тестирования приложения для Android от сессии для приложения для iOS. С помощью таких аргументов, как

- `platformName`
- `deviceName`
- `appPackage`
- `ppActivity`

### UIAutomator и UIAutomation

#### Как Appium работает в Android

Appium передает команду тестовому сценарию UIAutomator, запущенному на устройстве.

**UIAutomator** — это встроенный в Android фреймворк автоматизации пользовательского интерфейса, который поддерживает запуск тестовых примеров JUnit непосредственно на устройстве из командной строки. В качестве языка программирования он использует Java, но Appium позволяет запускать его с любого из поддерживаемых WebDriver языков.

На устройстве запускается пакет bootstrap.jar, который представляет собой наш тестовый пример, скомпилированный на Java. При запуске он порождает TCP-сервер. Здесь TCP-сервер находится внутри устройства, а клиент — в процессе Appium.

![UIAutomator](https://github.com/ilsinyakov/QA_Theory/blob/main/Pictures/UIAutomator.webp?raw=true)

#### Как Appium работает в iOS

На iOS Appium передает команды скрипту **UIAutomation**, запущенному в среде Mac Instruments. Apple предоставляет приложение под названием «instruments», которое используется для выполнения различных действий, таких как профилирование, контроль и создание iOS-приложений, но в нем также есть компонент автоматизации, где мы можем написать некоторые команды на JavaScript, которые используют UIAutomation API для взаимодействия с пользовательским интерфейсом приложения. Appium использует эти же библиотеки для автоматизации iOS-приложений.

Если говорить о жизненном цикле команды, то он выглядит следующим образом: веб-драйвер Selenium выбирает команду из кода и отправляет ее в виде JSON через HTTP-запрос на сервер Appium. Appium-сервер знает контекст автоматизации, например iOS и Android, и отправляет эту команду на командный сервер Instruments, который будет ждать, пока командный клиент Instruments (написанный на node.js) подхватит ее и выполнит в **bootstrap.js** в среде инструментов iOS. После выполнения команды командный клиент отправляет сообщение обратно на сервер Appium, который фиксирует все, что связано с командой, в своей консоли. Этот цикл продолжается до тех пор, пока не будут выполнены все команды.

![UIAutomation](https://github.com/ilsinyakov/QA_Theory/blob/main/Pictures/UIAutomation.webp?raw=true)

### Espresso

С недавнего времени Appium также умеет работать с Espresso.

**Espresso** = это официальный фреймворк для UI-тестирования от Google, но тесты с его использованием работают уже по модели белого ящика (white-box). Espresso поддерживает Android API с 10 версии. Предоставляет рекордер для записи тестов.

Фактически Espresso является лидером и даже стандартом в индустрии. Такой успех может быть связан с тем, что он обеспечивает повышенную скорость и стабильность тестов в сравнении с конкурентами.

Espresso решает низкоуровневую задачу — найти необходимый элемент на экране по заданным параметрам (ViewMatcher), произвести с ним действия (ViewAction) или выполнить проверки (ViewAssertion).

