# Java Core

- [JVM / JRE / JDC](#jvm--jre--jdc)
  - [JVM](#jvm)
  - [JRE](#jre)
  - [JDK](#jdk)
- [Примитивы (Primitive Data Types)](#примитивы-primitive-data-types)
- [Ссылочные типы (Reference types)](#ссылочные-типы-reference-types)
- [Работа с памятью](#работа-с-памятью)
- [Модификаторы видимости (доступа)](#модификаторы-видимости-доступа)
  - [`public`](#public)
  - [`protected`](#protected)
  - [package-private (default, «без модификатора»)](#package-private-default-без-модификатора)
  - [`private`](#private)

## JVM / JRE / JDC

**JVM** — Java Virtual Machine (Виртуальная машина Java) - абстрактная/реализованная машина, которая выполняет байт-код Java.

**JRE** — Java Runtime Environment (Среда выполнения Java) - пакет, содержащий JVM + стандартные библиотеки и средства запуска — нужен, чтобы просто запустить Java-программу.

**JDK** — Java Development Kit (Набор средств разработки для Java) - включает JRE + набор инструментов разработки (компилятор javac, javadoc, jar, отладчики и т.д.) — нужен разработчику.

```text
JDK
 └─ содержит JRE
     └─ содержит JVM + runtime class libraries (java.*)
```

Пример рабочего цикла:

1. `javac Hello.java` → создаёт Hello.class (байт-код).  
2. `java Hello` → JVM внутри JRE/JDK загружает и выполняет байт-код.

### JVM

JVM — не «программа», а платформа/спецификация: когда вы говорите «JVM», вы можете иметь в виду либо спецификацию (описание поведения), либо конкретную реализацию (HotSpot, OpenJ9 и т.д.).  
Разные реализации JVM имеют разные сборщики мусора (G1, Shenandoah, ZGC и т.д.), разные JIT-алгоритмы.

Основные обязанности реализации JVM:

- **Загрузка классов (Class Loader)** — загружает `.class` (байт-код) в память.
- **Проверка байт-кода (Bytecode Verifier)** — проверяет безопасность/корректность загружаемого байт-кода.
- **Исполнение байт-кода — интерпретатор + JIT (Just-In-Time) компиляция** для ускорения «горячих» участков.
- **Управление памятью и сборка мусора - GC (Garbage Collection)** — распределяет объекты в heap и запускает GC по необходимости.
- **Механизмы многопоточности и синхронизации** — реализация Java Memory Model, управление потоками и блокировками.
- **Интеграция с нативным кодом (JNI)** — возможность вызывать нативные библиотеки.

### JRE

JRE — это «пакет для запуска». В него входят:

- реализация **JVM**;
- **стандартные class libraries** (например `rt.jar` в старых версиях или модули `java.base` и другие в модульной системе);
- **java launcher** (утилита `java`), инфраструктура запуска приложений.

### JDK

JDK = JRE + инструменты разработки.

Основные элементы JDK:

- Компилятор `javac` (переводит `.java` → `.class`);
- Запускатор `java` (входит в JRE);
- Инструменты: `javadoc`, `jar`, `jlink`, `jmap`, `jstack`, профайлеры, отладчики и др.;
- Исходные заголовочные файлы и API-документация.

JDK нужен разработчику, JRE — пользователю, но в современных релизах Oracle/дистрибуции это разграничение сдвинулось - с Java 11 Oracle перестал публиковать отдельные JRE/Server-JRE для скачивания — вместо этого рекомендуется поставлять JDK или собирать тонкую runtime-сборку с помощью `jlink`. Если собираете приложение для продакшена, часто включают встроенный runtime (custom runtime) — команда `jlink` позволяет собрать минимальную runtime-сборку.

## Примитивы (Primitive Data Types)

|Примитив|Размер в памяти|Диапазон значений|Точность|
|---|---|---|---|
|**byte**|8 бит|-128 … 127|-|
|**short**|16 бит|-32 768 … 32 767|-|
|**int**|32 бит|-2 147 483 648 … 2 147 483 647|-|
|**long**|64 бит|-9 223 372 036 854 775 808 … 9 223 372 036 854 775 807|-|
|**char**|16 бит|UTF-16 code unit. 0 … 65 535 ('\u0000' … '\uffff')|-|
|**float**|32 бит|≈1.4·10^-45 … ≈3.4·10^38|~6–7 значащих десятичных цифр|
|**double**|64 бит|≈4.9·10^-324 … ≈1.8·10^308|~15–16 значащих десятичных цифр|
|**boolean**|-|true и false|-|

## Ссылочные типы (Reference types)

В Java ссылочные типы — это все типы, кроме примитивов: объекты классов, массивы, интерфейсы, String, Enum и т.д. Переменная ссылочного типа хранит ссылку (указатель) на объект в куче (heap); сам объект (его поля и внутреннее состояние) хранится в куче.

```text
Stack (локальные переменные)
+-------------------------+
| localRef -> 0x7f9a3b20  |  ← переменная (ссылка)
+-------------------------+

Heap (объекты)
0x7f9a3b20: ObjectInstance {
    [object header: mark word][klass ptr]
    field1: 123
    field2: "hello"
}
```

## Работа с памятью

Как JVM выделяет и инициализирует объект:

1. Вызывается new SomeClass().
2. JVM резервирует место в heap.
3. Пишет object header (mark word, klass ptr) и нулит поля/инициализирует по дефолту.
4. Возвращает ссылку (адрес) — значение записывается в локальную переменную (на стеке) или поле другого объекта.

|Тип|Хранение|Изменяемость|Пример|
|---|---|---|---|
|Примитив|В стеке|✅ Mutable|int a = 5|
|String|В куче|❌ Immutable|"Hello"|
|Array|В куче|✅ Mutable|int[] a = {1,2}|
|Collection|В куче|✅ Mutable (обычно)|ArrayList<>|
|Map|В куче|✅ Mutable|HashMap<>|

## Модификаторы видимости (доступа)

Модификаторы доступа контролируют, какие классы/методы/поля/конструкторы видимы из каких мест в программе — это главный инструмент инкапсуляции.

В Java есть четыре «уровня» доступа (в порядке от наибольшего доступа к наименьшему):

- `public` — доступ везде;
- `protected` — доступ внутри пакета и для подклассов;
- *package-private* (*default*, без ключевого слова) — доступ только внутри того же пакета;
- `private` — доступ только внутри того же класса (для членов) или недоступен для топ-уровневого класса.

### `public`

- Что: открытый доступ **из любого места** (любого пакета, любого модуля, при наличии экспортов модулей).
- Где применим: топ-уровневые классы (только public или default), методы, поля, конструкторы, вложенные классы.
- Пример:

```java
// file: com/example/A.java
package com.example;
public class A {
    public int x;
    public void foo() {}
}
```

Другой класс в любом пакете может `new com.example.A()` и обратиться к `x` и `foo()`.

### `protected`

- `protected` даёт доступ **в пределах пакета** (как package-private) и — дополнительный — **для подклассов** вне пакета.
- Нюанс: когда подкласс находится в другом пакете, доступ к `protected`-члену разрешён только через объект, чего тип является подклассом (или внутри subclass-кода — обычно через `this`). Проще: подкласс может обращаться к `protected` членам своего суперкласса для себя/своих экземпляров, но не может произвольно взять экземпляр суперкласса (из другого пакета) и читать/писать его `protected` поле.

Пример (легальный):

```java
// package a
package a;
public class Super {
    protected int p = 42;
}

// package b
package b;
import a.Super;
public class Sub extends Super {
    void test() {
        System.out.println(this.p); // OK: доступ через "this"
    }
}
```

Пример (нелегальный — компилятор выдаст ошибку):

```java
// package b
package b;
import a.Super;
public class Friend {
    void test(Super s) {
        System.out.println(s.p); // ERROR если Friend не в том же пакете a и не является подклассом
    }
}
```

В пакете `a` любой другой класс (даже не являющийся подклассом) может обращаться к `p`, потому что package access включён. `protected` = package + subclass.

### package-private (default, «без модификатора»)

- Что: если нет ключевого слова `public/protected/private`, то доступ разрешён только **внутри того же пакета** (package-private). Часто называют «default access» или «package access».
- Где применим: топ-уровневые классы (может быть только package-private или public), члены класса.
- Пример:

```java
// в пакете com.example
class PackageOnly {       // package-private top-level class
    void doSomething() {} // package-private method
}
```

Классы/члены в других пакетах не увидят их. Это удобный способ скрыть реализацию в пакете.

### `private`

- Что: виден **только внутри того же класса** (для членов). Для вложенных (inner/static nested) классов `private` также ограничивает видимость в пределах внешнего класса / вложенного класса как обычного члена.
- Где применим: поля, методы, конструкторы, вложенные классы. Топ-уровневые классы не могут быть `private`.
- Пример:

```java
public class Secret {
    private int secretValue;
    private void hide() {}
    private static class Helper {} // допустимо
}
```

Ни один другой класс (даже в том же пакете) не может обратиться к `secretValue` или `hide()`.

## Исключения

С точки зрения Java все исключения - это классы, которые являются потомками класса `Throwable`. Иерархия исключений схематично представлена на рисунке:

![Иерархия исключений](https://github.com/ilsinyakov/QA_Theory/blob/main/Pictures/Иерархия_исключений.png?raw=true)

У класса `Throwable` имеются два непосредственных подкласса: `Exception` и `Error`.

Исключения типа `Error`  - это критические ошибки.  Например, `StackOverflowError` (переполнение стека вызовов) или `OutOfMemoryError` (нехватка памяти для создания новых объектов). Обрабатывать такие ошибки нет смысла. Программа должна быть остановлена, поэтому реакция на них в прикладной программе не предусматривается.

Исключения типа `Exception`  - это менее серьезные ошибки.  Они делятся на две группы: проверяемые (**checked**) и непроверяемые (**unchecked**).

Для **непроверяемых** исключений программист не обязан предусматривать обработку в программе (хотя может это сделать, если потребуется). К ним относятся, например, `ArrayIndexOutOfBoundsException` (выход за границы массива), `ArithmeticException` (арифметическая ошибка, например деление на ноль),  или `NumberFormatException` (неверное преобразование символьной строки в число).  Непроверяемые исключения являются подклассами `RuntimeException`. Этот класс находится в пакете `java.lang`, который импортируется по умолчанию во все программы на Java.

**Проверяемые** исключения – это такие исключения, на которые следует обязательно реагировать в программе (обрабатывать или перебрасывать "наверх"). Компилятор знает, в каких методах такое исключение может возникнуть, и потребует его обработки. Например, если идет запись в файл, то может возникнуть `IOException` (ошибка ввода-вывода). В некоторых методах, связанных с многопоточной обработкой, может возникнуть `InterruptedException`. Обращение к базе данных может вызвать  `SQLException`  и т.д.

Исключения могут наследоваться друг от друга. Например, у `IOException` есть подклассы `FileNotFoundException`, `SocketException`, `UnsupportedDataTypeException` и многие другие разновидности ошибок ввода-вывода.
