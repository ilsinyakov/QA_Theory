# Java

- [JVM / JRE / JDK](#jvm--jre--jdk)
  - [JVM](#jvm)
  - [JRE](#jre)
  - [JDK](#jdk)
- [Примитивы (Primitive Data Types)](#примитивы-primitive-data-types)
- [Ссылочные типы (Reference types)](#ссылочные-типы-reference-types)
- [Работа с памятью](#работа-с-памятью)
- [Модификаторы видимости (доступа)](#модификаторы-видимости-доступа)
  - [`public`](#public)
  - [`protected`](#protected)
  - [package-private (default, «без модификатора»)](#package-private-default-без-модификатора)
  - [`private`](#private)
- [Исключения](#исключения)
- [Логирование](#логирование)
  - [System.err.println](#systemerrprintln)
  - [Log4j](#log4j)
  - [JUL — java.util.logging](#jul--javautillogging)
  - [JCL — jakarta commons logging](#jcl--jakarta-commons-logging)
  - [Logback](#logback)
  - [SLF4J — simple logging facade for java](#slf4j--simple-logging-facade-for-java)
  - [Уровни логирования](#уровни-логирования)
  - [slf4j-log4j12](#slf4j-log4j12)
- [Spring](#spring)
  - [Spring Framework](#spring-framework)
  - [Преимущества и недостатки Spring](#преимущества-и-недостатки-spring)
    - [Преимущества](#преимущества)
    - [Недостатки](#недостатки)
  - [Основные понятия Spring](#основные-понятия-spring)
    - [DI/IoC](#diioc)
    - [Бины и контекст](#бины-и-контекст)
    - [Способы конфигурации приложения](#способы-конфигурации-приложения)
    - [Репозиторий](#репозиторий)
  - [Аннотации Spring](#аннотации-spring)
    - [`@Bean`](#bean)
  - [Spring Boot](#spring-boot)
    - [Контроллер в Spring Boot](#контроллер-в-spring-boot)
    - [ENVIRONMENT в Spring Boot](#environment-в-spring-boot)

## JVM / JRE / JDK

**JVM** — Java Virtual Machine (Виртуальная машина Java) - абстрактная/реализованная машина, которая выполняет байт-код Java.

**JRE** — Java Runtime Environment (Среда выполнения Java) - пакет, содержащий JVM + стандартные библиотеки и средства запуска — нужен, чтобы просто запустить Java-программу.

**JDK** — Java Development Kit (Набор средств разработки для Java) - включает JRE + набор инструментов разработки (компилятор javac, javadoc, jar, отладчики и т.д.) — нужен разработчику.

```text
JDK
 └─ содержит JRE
     └─ содержит JVM + runtime class libraries (java.*)
```

Пример рабочего цикла:

1. `javac Hello.java` → создаёт Hello.class (байт-код).  
2. `java Hello` → JVM внутри JRE/JDK загружает и выполняет байт-код.

### JVM

JVM — не «программа», а платформа/спецификация: когда вы говорите «JVM», вы можете иметь в виду либо спецификацию (описание поведения), либо конкретную реализацию (HotSpot, OpenJ9 и т.д.).  
Разные реализации JVM имеют разные сборщики мусора (G1, Shenandoah, ZGC и т.д.), разные JIT-алгоритмы.

Основные обязанности реализации JVM:

- **Загрузка классов (Class Loader)** — загружает `.class` (байт-код) в память.
- **Проверка байт-кода (Bytecode Verifier)** — проверяет безопасность/корректность загружаемого байт-кода.
- **Исполнение байт-кода — интерпретатор + JIT (Just-In-Time) компиляция** для ускорения «горячих» участков.
- **Управление памятью и сборка мусора - GC (Garbage Collection)** — распределяет объекты в heap и запускает GC по необходимости.
- **Механизмы многопоточности и синхронизации** — реализация Java Memory Model, управление потоками и блокировками.
- **Интеграция с нативным кодом (JNI)** — возможность вызывать нативные библиотеки.

### JRE

JRE — это «пакет для запуска». В него входят:

- реализация **JVM**;
- **стандартные class libraries** (например `rt.jar` в старых версиях или модули `java.base` и другие в модульной системе);
- **java launcher** (утилита `java`), инфраструктура запуска приложений.

### JDK

JDK = JRE + инструменты разработки.

Основные элементы JDK:

- Компилятор `javac` (переводит `.java` → `.class`);
- Запускатор `java` (входит в JRE);
- Инструменты: `javadoc`, `jar`, `jlink`, `jmap`, `jstack`, профайлеры, отладчики и др.;
- Исходные заголовочные файлы и API-документация.

JDK нужен разработчику, JRE — пользователю, но в современных релизах Oracle/дистрибуции это разграничение сдвинулось - с Java 11 Oracle перестал публиковать отдельные JRE/Server-JRE для скачивания — вместо этого рекомендуется поставлять JDK или собирать тонкую runtime-сборку с помощью `jlink`. Если собираете приложение для продакшена, часто включают встроенный runtime (custom runtime) — команда `jlink` позволяет собрать минимальную runtime-сборку.

## Примитивы (Primitive Data Types)

|Примитив|Размер в памяти|Диапазон значений|Точность|
|---|---|---|---|
|**byte**|8 бит|-128 … 127|-|
|**short**|16 бит|-32 768 … 32 767|-|
|**int**|32 бит|-2 147 483 648 … 2 147 483 647|-|
|**long**|64 бит|-9 223 372 036 854 775 808 … 9 223 372 036 854 775 807|-|
|**char**|16 бит|UTF-16 code unit. 0 … 65 535 ('\u0000' … '\uffff')|-|
|**float**|32 бит|≈1.4·10^-45 … ≈3.4·10^38|~6–7 значащих десятичных цифр|
|**double**|64 бит|≈4.9·10^-324 … ≈1.8·10^308|~15–16 значащих десятичных цифр|
|**boolean**|-|true и false|-|

## Ссылочные типы (Reference types)

В Java ссылочные типы — это все типы, кроме примитивов: объекты классов, массивы, интерфейсы, String, Enum и т.д. Переменная ссылочного типа хранит ссылку (указатель) на объект в куче (heap); сам объект (его поля и внутреннее состояние) хранится в куче.

```text
Stack (локальные переменные)
+-------------------------+
| localRef -> 0x7f9a3b20  |  ← переменная (ссылка)
+-------------------------+

Heap (объекты)
0x7f9a3b20: ObjectInstance {
    [object header: mark word][klass ptr]
    field1: 123
    field2: "hello"
}
```

## Работа с памятью

Как JVM выделяет и инициализирует объект:

1. Вызывается new SomeClass().
2. JVM резервирует место в heap.
3. Пишет object header (mark word, klass ptr) и нулит поля/инициализирует по дефолту.
4. Возвращает ссылку (адрес) — значение записывается в локальную переменную (на стеке) или поле другого объекта.

|Тип|Хранение|Изменяемость|Пример|
|---|---|---|---|
|Примитив|В стеке|✅ Mutable|int a = 5|
|String|В куче|❌ Immutable|"Hello"|
|Array|В куче|✅ Mutable|int[] a = {1,2}|
|Collection|В куче|✅ Mutable (обычно)|ArrayList<>|
|Map|В куче|✅ Mutable|HashMap<>|

## Модификаторы видимости (доступа)

Модификаторы доступа контролируют, какие классы/методы/поля/конструкторы видимы из каких мест в программе — это главный инструмент инкапсуляции.

В Java есть четыре «уровня» доступа (в порядке от наибольшего доступа к наименьшему):

- `public` — доступ везде;
- `protected` — доступ внутри пакета и для подклассов;
- *package-private* (*default*, без ключевого слова) — доступ только внутри того же пакета;
- `private` — доступ только внутри того же класса (для членов) или недоступен для топ-уровневого класса.

### `public`

- Что: открытый доступ **из любого места** (любого пакета, любого модуля, при наличии экспортов модулей).
- Где применим: топ-уровневые классы (только public или default), методы, поля, конструкторы, вложенные классы.
- Пример:

```java
// file: com/example/A.java
package com.example;
public class A {
    public int x;
    public void foo() {}
}
```

Другой класс в любом пакете может `new com.example.A()` и обратиться к `x` и `foo()`.

### `protected`

- `protected` даёт доступ **в пределах пакета** (как package-private) и — дополнительный — **для подклассов** вне пакета.
- Нюанс: когда подкласс находится в другом пакете, доступ к `protected`-члену разрешён только через объект, чего тип является подклассом (или внутри subclass-кода — обычно через `this`). Проще: подкласс может обращаться к `protected` членам своего суперкласса для себя/своих экземпляров, но не может произвольно взять экземпляр суперкласса (из другого пакета) и читать/писать его `protected` поле.

Пример (легальный):

```java
// package a
package a;
public class Super {
    protected int p = 42;
}

// package b
package b;
import a.Super;
public class Sub extends Super {
    void test() {
        System.out.println(this.p); // OK: доступ через "this"
    }
}
```

Пример (нелегальный — компилятор выдаст ошибку):

```java
// package b
package b;
import a.Super;
public class Friend {
    void test(Super s) {
        System.out.println(s.p); // ERROR если Friend не в том же пакете a и не является подклассом
    }
}
```

В пакете `a` любой другой класс (даже не являющийся подклассом) может обращаться к `p`, потому что package access включён. `protected` = package + subclass.

### package-private (default, «без модификатора»)

- Что: если нет ключевого слова `public/protected/private`, то доступ разрешён только **внутри того же пакета** (package-private). Часто называют «default access» или «package access».
- Где применим: топ-уровневые классы (может быть только package-private или public), члены класса.
- Пример:

```java
// в пакете com.example
class PackageOnly {       // package-private top-level class
    void doSomething() {} // package-private method
}
```

Классы/члены в других пакетах не увидят их. Это удобный способ скрыть реализацию в пакете.

### `private`

- Что: виден **только внутри того же класса** (для членов). Для вложенных (inner/static nested) классов `private` также ограничивает видимость в пределах внешнего класса / вложенного класса как обычного члена.
- Где применим: поля, методы, конструкторы, вложенные классы. Топ-уровневые классы не могут быть `private`.
- Пример:

```java
public class Secret {
    private int secretValue;
    private void hide() {}
    private static class Helper {} // допустимо
}
```

Ни один другой класс (даже в том же пакете) не может обратиться к `secretValue` или `hide()`.

## Исключения

С точки зрения Java все исключения - это классы, которые являются потомками класса `Throwable`. Иерархия исключений схематично представлена на рисунке:

![Иерархия исключений](https://github.com/ilsinyakov/QA_Theory/blob/main/Pictures/Иерархия_исключений.png?raw=true)

У класса `Throwable` имеются два непосредственных подкласса: `Exception` и `Error`.

Исключения типа `Error`  - это критические ошибки.  Например, `StackOverflowError` (переполнение стека вызовов) или `OutOfMemoryError` (нехватка памяти для создания новых объектов). Обрабатывать такие ошибки нет смысла. Программа должна быть остановлена, поэтому реакция на них в прикладной программе не предусматривается.

Исключения типа `Exception`  - это менее серьезные ошибки.  Они делятся на две группы: проверяемые (**checked**) и непроверяемые (**unchecked**).

Для **непроверяемых** исключений программист не обязан предусматривать обработку в программе (хотя может это сделать, если потребуется). К ним относятся, например, `ArrayIndexOutOfBoundsException` (выход за границы массива), `ArithmeticException` (арифметическая ошибка, например деление на ноль),  или `NumberFormatException` (неверное преобразование символьной строки в число).  Непроверяемые исключения являются подклассами `RuntimeException`. Этот класс находится в пакете `java.lang`, который импортируется по умолчанию во все программы на Java.

**Проверяемые** исключения – это такие исключения, на которые следует обязательно реагировать в программе (обрабатывать или перебрасывать "наверх"). Компилятор знает, в каких методах такое исключение может возникнуть, и потребует его обработки. Например, если идет запись в файл, то может возникнуть `IOException` (ошибка ввода-вывода). В некоторых методах, связанных с многопоточной обработкой, может возникнуть `InterruptedException`. Обращение к базе данных может вызвать  `SQLException`  и т.д.

Исключения могут наследоваться друг от друга. Например, у `IOException` есть подклассы `FileNotFoundException`, `SocketException`, `UnsupportedDataTypeException` и многие другие разновидности ошибок ввода-вывода.

## Логирование

Из известных решений по логированию в Java можно выделить:

- log4j
- JUL — java.util.logging
- JCL — jakarta commons logging
- Logback
- SLF4J — simple logging facade for java

### System.err.println

Первоначально был, разумеется, `System.err.println` (вывод записи в консоль). Его и сейчас используют для быстрого получения лога при дебаге. Конечно, говорить о каких-то настройках здесь не приходится.

### Log4j

Это уже было полноценное решение, которое создавалось из потребностей разработчиков. Получился действительно интересный инструмент, который можно использовать.

В силу разных обстоятельств это решение так и не попало в JDK, чем очень расстроило все комьюнити.

В log4j были возможности по конфигурации таким образом, чтобы можно было включить логирование в пакете `com.example.type` и выключить его в подпакете `com.example.type.generic`. Это позволяло быстро отсечь то, что нужно логировать, от того, что не нужно.

Здесь важно отметить, что есть две версии log4j: 1.2.х и 2.х.х, которые несовместимы друг с другом.

log4j добавил такое понятие как **appender**, то есть инструмент, с помощью которого записываются логи и **layout** — форматирование логов. Это позволяет записывать только то, что нужно и как нужно.

В настоящий момент log4j не поддерживается и в связке с SLF4J рекомендуется использовать форк - reload4j.

### JUL — java.util.logging

Одно из ключевых преимуществ это решения — JUL включен в JDK (Java development kit). К сожалению, при его разработке за основу взяли не популярный log4j, а решение от IBM, что и повлияло на его развитие. По факту на данный момент JUL есть, но им никто не пользуется.

Из “такого себе”: в JUL уровни логирования отличаются от того, что есть в Logback, Log4j, Slf4j, и это ухудшает понимание между ними.

### JCL — jakarta commons logging

Из-за того, что долгое время не было промышленного стандарта в логировании и был период, когда многие создавали свой кастомный логгер, решили выпустить JCL — общую обертку, которая  использовалась бы над другими.

Почему? Когда в проект добавлялись какие-то зависимости, они могли использовать логгер, отличный от логгера на проекте. Из-за этого они транзитивно добавлялись в проект, что создавало реальные проблемы при попытке все это собрать воедино.

К сожалению, обертка была очень бедна на функциональность и никаких дополнений не вносила.

Наверное, было бы удобно, если бы все использовали JCL для работы. Но на деле так не получалось, поэтому на данный момент применять JCL — не лучшая идея.

### Logback

Logback написал тот же разработчик, что и log4j, чтобы создать ему преемника. В основе была та же идея, что и в log4j.

Отличия были в том, что в logback:

- улучшена производительность;
- добавлена нативная поддержка slf4j;
- расширена опция фильтрации.

### SLF4J — simple logging facade for java

Где-то в 2006 году один из отцов-основателей log4j вышел из проекта и создал slf4j — Simple Logging Facade for Java — обертку вокруг log4j, JUL, common-logging и logback.

Как видим, прогресс дошел до того, что создали обертку над оберткой…

Причем она делится на две части: API, который используется в приложении и реализация, которая добавляется отдельными зависимостями для каждого вида логирования.

Например, `slf4j-log4j12.jar`, `slf4j-jdk14.jar`. Достаточно подключить правильную реализацию и все: весь проект будет работать с ней.

Slf4j поддерживает все новые функции, такие как форматирование строк для логирования.

### Уровни логирования

||FATAL|ERROR|WARN|INFO|DEBUG|TRACE|ALL|
|--|--|--|--|--|--|--|--|
|OFF||||||||
|FATAL|x|||||||
|ERROR|x|x||||||
|WARN|x|x|x|||||
|INFO|x|x|x|x||||
|DEBUG|x|x|x|x|x|||
|TRACE|x|x|x|x|x|x||
|ALL|x|x|x|x|x|x|x|

Для того, чтоб как-то ранжировать логи, нужно было дать определенные обозначения и разграничения. Для этого ввели уровни логирования.

Уровень задается в приложении. Если запись относится к уровню ниже обозначенного, она не вносится в лог.

Например, у нас есть логи, с помощью которых дебажат приложение. В нормальной работе на продакшене (когда приложение используют по назначению), такие логи не нужны. Поэтому уровень логирования будет выше, чем для дебага.

Давайте рассмотрим уровни на примере log4j. Остальные решения, кроме JUL, используют такие же уровни. Вот они в порядке уменьшения:

- **OFF**: никакие логи не записываются, все будут проигнорированы;
- **FATAL**: ошибка, после которой приложение уже не сможет работать и будет остановлено, например, JVM out of memory error;
- **ERROR**: уровень ошибок, когда есть проблемы, которые нужно решить. Ошибка не останавливает работу приложения в целом. Остальные запросы могут работать корректно;
- **WARN**: обозначаются логи, которые содержат предостережение. Произошло неожиданное действие, несмотря на это система устояла и выполнила запрос;
- **INFO**: лог, который записывает важные действия в приложении. Это не ошибки, это не предостережение, это ожидаемые действия системы;
- **DEBUG**: логи, необходимые для отладки приложения. Для уверенности в том, что система делает именно то, что от нее ожидают, или описания действия системы: “method1 начал работу”;
- **TRACE**: менее приоритетные логи для отладки, с наименьшим уровнем логирования;
- **ALL**: уровень, при котором будут записаны все логи из системы.

Получается, что если в приложении в каком-то месте включен уровень логирования INFO, будут логироваться все уровни, начиная с INFO и до FATAL. Если будет уровень логирования FATAL, будут записаны только логи с этим уровнем.

### slf4j-log4j12

Рассмотрим работу этой связки подробнее.

Для настройки логирования используется файл `src/main/resources/log4j.properties`

```ini
log4j.rootLogger=INFO, CONSOLE, FILE

log4j.appender.CONSOLE=org.apache.log4j.ConsoleAppender
log4j.appender.CONSOLE.Target=System.out
log4j.appender.CONSOLE.layout=org.apache.log4j.PatternLayout
log4j.appender.CONSOLE.layout.ConversionPattern=%d{yyyy-MM-dd HH:mm:ss} [%p] %c.%M - %m%n

log4j.appender.FILE=org.apache.log4j.RollingFileAppender
log4j.appender.FILE.File=logs/wo-telemetry.log
log4j.appender.FILE.MaxFileSize=1MB
log4j.appender.FILE.MaxBackupIndex=1
log4j.appender.FILE.layout=org.apache.log4j.PatternLayout
log4j.appender.FILE.layout.ConversionPattern=%d{yyyy-MM-dd HH:mm:ss} [%p] %c.%M - %m%n
```

`rootLogger` - указывает уровень логирования и используемые аппендеры.

`appender` - указывает, кда будет записываться лог.  
Бывают:

- FileAppender - в файл без ротации
- RollingFileAppender - в файл с ротацией
- ConsoleAppender - в консоль
- JDBCAppender - в БД
- TelnetAppender - по сети

`layout` - указывает, как будет форматироваться строка с логом.

Для инициализации логгера нужно определить его в соответствующем классе:

```java
private final Logger logger = LoggerFactory.getLogger(TelegramClient.class);
```

Есть два способа создать сам лог.

- **традиционный**:

    ```java
    logger.info("Hello World");
    logger.info("Hello {}", "World");
    ```

    нужно помнить о том, что прямая конкатенация строки будет вызвана в любом случае, независимо от установленного уровня логирования, что может приводить к существенному замедлению работы приложения. Для исключения этих лишних вызовов используется параметризованное сообщение с плейсхолдерами `{}`.

- **Fluent Logging API**:  
Свободный (или быстрый) API.

    ```java
    int newT = 15;
    int oldT = 16;

    // using fluent API, log message with arguments
    logger.atDebug().log("Temperature set to {}. Old value was {}.", newT, oldT);
   
    // using fluent API, add arguments one by one and then log message
    logger.atDebug().setMessage("Temperature set to {}. Old value was {}.")
            .addArgument(newT).addArgument(oldT).log();

    // using fluent API, add one argument with a Supplier and then log message with one more argument.
    // Assume the method t16() returns 16.
    logger.atDebug().setMessage("Temperature set to {}. Old value was {}.")
            .addArgument(() -> t16()).addArgument(oldT).log();

    // lambda in log()
    logger.atDebug().log(() -> "Telegram response:\n" + response.body());
    ```

    такая конструкция предотвращает ненужные вычисления, если соответствующий уровень логирования отключен.

    Можно также использовать перечисление пар ключ=значение напрямую:

    ```java
    int newT = 15;
    int oldT = 16;

    // using classical API
    logger.debug("oldT={} newT={} Temperature changed.", oldT, newT);

    // using fluent API 
    logger.atDebug().setMessage("Temperature changed.")
            .addKeyValue("oldT", oldT).addKeyValue("newT", newT).log();
    ```

## Spring

### Spring Framework

**Spring** — один из самых популярных фреймворков. Его применяют backend-разработчики, которые работают на Java, Kotlin и Groovy. С помощью Spring Framework можно создавать веб- и консольные приложения.

В спринге стараются по максимуму отойти от жесткой связности (когда ваши классы напрямую зависят от каких-то классов/интерфейсов из фреймворка), и используют для этой цели **аннотации**.

Фреймворк состоит из **модулей**, каждый из которых предлагает набор готовых инструментов. Например:

- **Spring Web**: позволяет предоставлять API для потребителя;
- **Spring Data**: работает с различными видами баз данных, как SQL, так и NoSQL;
- **Spring Test**: предоставляет инструментарий для написания юнит- и интеграционных тестов;
- **Spring Cloud**: отдельная экосистема внутри Спринга. Позволяет предоставлять конфигурации сервисам и работать в распределенных системах;
- **Spring Integration**: интегрирует приложения компании в единую систему.

Модули Spring можно использовать для работы над разными частями приложения. Их можно подключать вместе или по отдельности, все зависит от поставленной задачи.

![Spring Modules](https://github.com/ilsinyakov/QA_Theory/blob/main/Pictures/Spring_Framework.webp?raw=true)

### Преимущества и недостатки Spring

#### Преимущества

- **Универсальность**. Spring фреймворк предлагает готовые инструменты для решения самых разных задач, от работы с почтой до настроек безопасности.
- **Экономия времени**. Сокращает time-to-market время и ускоряет разработку.
- **Избавление от рутины**. Spring предлагает готовые решения для рутинных задач. Программистам больше не нужно тратить время на однотипные куски кода.
- **Открытый исходный код**. Его можно адаптировать и настроить под нужды проекта.
- **Популярность**. На рынке есть много вакансий для тех, кто работает на Spring Java. Этот фреймворк используют для большинства проектов.
- **Доступность**. Создать приложение на Spring можно абсолютно бесплатно.

#### Недостатки

- **Сложность**. Спринг тяжело настраивать, это инструмент для опытных разработчиков.
- **Вес кода**. Проекты на Spring Framework дольше загружаются и требуют оптимизации.
- **Непонятная работа некоторых модулей**. Например, Spring Data JPA, который генерирует неочевидные SQL-запросы.
- **Много неиспользуемых зависимостей**. В финальную сборку кода входит много ненужного материала.

### Основные понятия Spring

#### DI/IoC

**IoC (Inversion of Control)** — инверсия управления. При использовании библиотеки вы сами прописываете в своем коде, какой метод какого объекта вызвать, а в случает с фреймворками — чаще всего уже фреймворк будет вызывать в нужный ему момент тот код, который вы написали. То есть, тут уже не вы управляете процессом выполнения кода/программы, а фреймворк это делает за вас. Вы передали ему управление (инверсия управления).

Под **DI** понимают то **Dependency Inversion** (инверсию зависимостей, то есть попытки не делать жестких связей между вашими модулями/классами, где один класс напрямую завязан на другой), то **Dependency Injection** (внедрение зависимостей, это когда объекты котиков создаете не вы в main-е и потом передаете их в свои методы, а за вас их создает спринг, а вы ему просто говорите что-то типа "хочу сюда получить котика", и он вам его передает в ваш метод).

#### Бины и контекст

Одно из ключевых понятий в спринге — это **бин**. По сути, это просто объект какого-то класса.

Допустим, для нашей программы надо использовать 3 объекта: котика, собачку и попугайчика.

И у нас есть куча классов с кучей методов, где иногда нам нужен для метода котик, а для другого метода — собачка, а иногда у нас будут методы, где нужен котик и попугайчик (например метод для кормежки котика, хе-хе), а в каких-то методах — все три объекта понадобятся. Да, мы можем в main-е сначала создать эти три объекта, а потом их передавать в наши классы, а уже изнутри классов — в нужные нам методы... И так по всей программе. А если еще и представить, что периодически мы захотим менять список принимаемых параметров для наших методов (ну решили переписать что-то или добавить функциональности) — то нам придется делать довольно много правок по коду если надо будет что-то поменять. А теперь если представить, что таких объектов у нас не 3, а 300?

Как вариант, это собрать все наши такие объекты в какой-то один общий список объектов (`List<Object>`) и во все методы передавать его, а изнутри методов уже доставать тот или иной объект, который нам нужен. Но что если представить, что по ходу программы у нас в этот список может добавиться какой-то объект, или (что хуже) удалиться? Тогда во всех методах, где мы достаем объекты из списка по их индексу — все может поломаться.

Тогда мы решаем хранить не список, а мапу, где ключом будет имя нужного нам объекта, а значением — сам объект, и тогда мы сможем из него доставать нужные нам объекты просто по их имени: get("попугайчик") и в ответ получили объект попугайчика. Или например ключ — это класс объекта, а значение — сам объект, тогда мы сможем указать уже не имя объекта, а просто класс нужного нам объекта, тоже удобно. Или даже написать какую-то обертку над мапой, где сделать методы, чтобы в каких-то случаях доставать объекты по их имени, а в других случаях — по классу.

Вот это и получится у нас **application context** из спринга.

**Контекст** — это набор бинов (объектов). Обращаясь к контексту — мы можем получить нужный нам бин (объект) по его имени например, или по его типу, или еще как-то.

Кроме того, мы можем попросить спринг самого сходить поискать в своем контексте нужный нам бин и передать его в наш метод.

Например, если у нас был такой метод:

```java
public void doSomething(Cat cat) {
    ...
}
```

нам спринг когда вызывал этот метод — передавал в него объект нашего котика из своего контекста. Теперь мы решаем, что нашему методу кроме котика нужен еще и попугайчик. Используя спринг — для нас нет ничего проще!

Мы просто пишем:

```java
public void doSomething(Cat cat, Parrot parrot) {
    ...
}
```

и спринг, когда будет вызывать этот наш метод — сам поймет, что сюда надо передать котика и попугайчика, сходит к себе в контекст, достанет эти два объекта и передаст их в наш метод.

Передав спрингу бразды правления нашей программой — мы так же переложили на него ответственность за создание объектов и передачу их в наши методы, которые он будет вызывать.

#### Способы конфигурации приложения

Существует три основных способа конфигурации приложения (то-есть, указания спрингу какие именно объекты нам нужны для работы):

- при помощи xml файлов/конфигов;
- при помощи java-конфигов;
- автоматическая конфигурация.

Разработчики спринга выстраивают их в таком порядке приоритетности:

- наиболее приоритетный способ, которому стоит отдавать предпочтение — это автоматическая конфигурация;
- если при помощи автоматической конфигурации нет возможности правильно настроить все возможные бины — использовать джава-конфигурацию (создание объектов используя джава код);
- ну и самый низкоприоритетный способ — это по-старинке, используя xml конфиги.

Кроме того, спринг позволяет комбинировать эти способы. Например, все то, что может быть настроено автоматически — пусть спринг сделает сам, там где надо указать какие-то особые параметры — сделать при помощи джава-конфигов, и кроме того, можно подключить какие-то легаси конфиги в xml формате. В общем, достаточно гибко это все можно сделать. Но все же, если все можно сделать при помощи автоматической настройки — используйте ее.

Автоматическая конфигурация используется тогда, когда нужные нам для работы объекты — это объекты написанных нами классов.

Если для создания объекта нашего класса нужна какая-то очень специфическая логика, или если у нас нет возможность отметить какой-то класс нужной нам аннотацией, которую подхватила бы автоматическая конфигурация — это можно сделать в джава-конфигах.

#### Репозиторий

**Репозиторий** в Spring (обычно в контексте Spring Data JPA) — это абстракция над слоем доступа к данным, которая значительно упрощает работу с хранилищем данных (БД, NoSQL, REST API и т.д.). Это центральное понятие в экосистеме Spring Data.

Проще говоря, это прослойка между вашим бизнес-логическим кодом и базой данных, которая избавляет вас от написания boilerplate-кода (шаблонного кода для CRUD-операций).

Ключевые **характеристики и возможности**:

1. Абстракция над JPA EntityManager / JDBC: Прячет низкоуровневые детали работы с БД.
2. Сокращение кода: Позволяет выполнять стандартные операции без написания SQL/JPQL-запросов.
3. Декларативное создание запросов: Запросы можно создавать просто называя методы по соглашению или используя аннотацию `@Query`.
4. Интеграция со Spring: Легко внедряется (`@Autowired`) в компоненты Spring (сервисы, контроллеры).

**Основные типы репозиториев в Spring Data JPA**:

1. `CrudRepository<T, ID>` — базовый интерфейс.  
Предоставляет основные CRUD-операции: save(), findById(), findAll(), count(), delete() и т.д.
2. `JpaRepository<T, ID>` — наиболее часто используемый.  
Наследует `CrudRepository` и `PagingAndSortingRepository`.  
Добавляет JPA-специфичные методы: `flush()`, `saveAndFlush()`, `deleteInBatch()`.  
Возвращает List вместо Iterable в некоторых методах.  
По умолчанию включает поддержку пагинации и сортировки.
3. `PagingAndSortingRepository<T, ID>` — добавляет пагинацию и сортировку к `CrudRepository`.

Пример:

```java
//Создание сущности
@Entity
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String name;
    private String email;
    // геттеры, сеттеры, конструкторы...
}


//Создание репозитория
import org.springframework.data.jpa.repository.JpaRepository;
import java.util.List;

public interface UserRepository extends JpaRepository<User, Long> {
    
    // Spring Data САМ реализует этот метод!
    // Правило именования: findBy + ИмяПоля + (НеобязательныеУсловия)
    List<User> findByName(String name);
    
    // Более сложный запрос по соглашению
    List<User> findByEmailContainingIgnoreCase(String email);
    
    // Можно написать свой JPQL-запрос
    @Query("SELECT u FROM User u WHERE u.name LIKE %:name%")
    List<User> searchByName(@Param("name") String name);
    
    // Или нативным SQL
    @Query(value = "SELECT * FROM users WHERE email = ?1", nativeQuery = true)
    User findByEmailNative(String email);
}


// Использование в сервисе
@Service
public class UserService {
    
    @Autowired
    private UserRepository userRepository; // Внедряем репозиторий
    
    public User createUser(User user) {
        return userRepository.save(user); // Сохраняем без SQL!
    }
    
    public List<User> findUsersByName(String name) {
        return userRepository.findByName(name); // Используем декларативный метод
    }
    
    public Page<User> getUsersPage(int page, int size) {
        return userRepository.findAll(PageRequest.of(page, size)); // Пагинация "из коробки"
    }
}

```

**Итог**:  
Репозиторий в Spring — это интерфейс, который:

1. Расширяет один из базовых интерфейсов Spring Data (JpaRepository, CrudRepository).
2. Объявляет методы для доступа к данным.
3. Автоматически получает реализацию от Spring.
4. Позволяет взаимодействовать с БД на высоком уровне абстракции, минимизируя рутинный код.

### Аннотации Spring

#### `@Bean`

**Назначение**: объявляет в методе фабрику Spring-бина — возвращаемый объект регистрируется в `ApplicationContext`.

**Имя бина**: по-умолчанию — имя метода; можно задать `@Bean("myName")`

**Скоуп**: по-умолчанию `singleton`. Изменяют через `@Scope("prototype")` и т.п.

**Когда использовать**: для конфигурации бинов из сторонних библиотек или когда нужно создать бин программно (настройка, фабрика, сложная инициализация). Для простых Java-классов чаще используют `@Component/@Service/@Repository`.

### Spring Boot

**Spring Boot** — это дополнение к фреймворку Spring, которое облегчает и ускоряет работу. С его помощью можно:

- использовать различные стартеры, предоставляемые экосистемой Spring Boot’а;
- автоматически задавать конфигурации приложения;
- использовать встроенный веб-сервер (по умолчанию используется Tomcat, но можно изменить в настройках).

Последнее отличие самое важное. Изначально для работы со Спринг Джава нужно было собрать приложение и положить его в отдельную папку на сервере. Spring Boot имеет встроенный сервер внутри самого приложения. Это, во-первых, экономит время. Во-вторых, уменьшает стоимость содержания инфраструктуры.

Spring Boot предлагает разработчикам те же самые функции, что и обычный Спринг, но при этом работать с ним намного легче.

![Spring Boot](https://github.com/ilsinyakov/QA_Theory/blob/main/Pictures/Spring_Boot.png?raw=true)

#### Контроллер в Spring Boot

**Контроллер** — это компонент приложения, который принимает HTTP-запросы, обрабатывает их и возвращает ответ. В Spring Boot контроллеры реализованы поверх Spring MVC (DispatcherServlet) и служат "входной точкой" для веб-слоя.

**Аннотации**:

- `@Controller` — обычный MVC-контроллер (возвращает view или шаблон).
- `@RestController` — `@Controller` + `@ResponseBody`, возвращает тело ответа (обычно JSON) напрямую.
- Маршрутизация: `@RequestMapping`, `@GetMapping`, `@PostMapping`, `@PutMapping`, `@DeleteMapping` и т.п.

**Методы**: методы контроллера — это handler methods, принимают параметры из запроса (`@PathVariable`, `@RequestParam`, `@RequestBody`, `@RequestHeader` и т.д.) и возвращают данные (String, DTO, `ResponseEntity<T>`, ModelAndView и т.п.).

**Сериализация/десериализация**: Spring использует `HttpMessageConverter` (обычно Jackson) для преобразования JSON ↔ POJO

#### ENVIRONMENT в Spring Boot

**Переменные окружения** — это пара `NAME=VALUE`, которые предоставляет операционная система (или контейнер/оркестратор) процессу при его старте. Их используют для конфигурации приложений (путь к БД, порт, секреты и т.п.) без правки кода или артефактов.

Spring Boot собирает конфигурацию из множества источников (command-line, env vars, файл application.yml/properties, system properties и т.д.) и использует правило приоритета: значения сверху перечёркивают нижележащие. Это позволяет гибко переопределять настройки в среде.

Порядок приоритета (сверху — выше приоритет):

1. Аргументы командной строки (--server.port=8081)
2. `SPRING_APPLICATION_JSON` (JSON в env или system property)
3. ServletConfig / ServletContext init params (в веб-контейнере)
4. JNDI (если используется)
5. Java System properties (`-Dspring.profiles.active=prod`)
6. OS environment variables (переменные окружения)
7. `application.properties` / `application.yml` в внешнем `config/` или в той же папке, где jar
8. `application.properties` / `application.yml` в classpath (внутри jar)
9. `@PropertySource` и т.п.
10. Default properties (установленные программно через `SpringApplication.setDefaultProperties`)

Переменные окружения связываются с настройками Spring Boot через:

1. `@Value`

    ```java
    @Value("${MY_APP_TIMEOUT:30}") // если нет — 30 по умолчанию
    private int timeout;
    ```

    Spring сначала ищет свойство MY_APP_TIMEOUT в доступных источниках (включая env vars, если имя совпадает с ключом).

2. `@ConfigurationProperties` (рекомендуется для групп настроек)

    ```java
    @Component
    @ConfigurationProperties(prefix = "app")
    public class AppProperties {
        private String host;
        private int port;
        // getters/setters
    }
    ```

    Env var `APP_HOST` или `APP_HOST/APP_PORT` будет корректно привязан.

3. Через `Environment`

    ```java
    @Autowired
    private Environment env;

    String url = env.getProperty("spring.datasource.url");
    ```

**Сопоставление имен**:

- точка `.` ↔ подчеркивание `_` в env vars;
- kebab-case (`my-app-value`) ↔ UNDERSCORE (`MY_APP_VALUE`);
- регистр игнорируется.

Примеры:

- property `spring.datasource.url` → env var `SPRING_DATASOURCE_URL`
- property `app.somethingValue` → env var `APP_SOMETHING_VALUE`
