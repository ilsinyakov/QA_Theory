# Java

- [JVM / JRE / JDC](#jvm--jre--jdc)
  - [JVM](#jvm)
  - [JRE](#jre)
  - [JDK](#jdk)
- [Примитивы (Primitive Data Types)](#примитивы-primitive-data-types)
- [Ссылочные типы (Reference types)](#ссылочные-типы-reference-types)
- [Работа с памятью](#работа-с-памятью)
- [Модификаторы видимости (доступа)](#модификаторы-видимости-доступа)
  - [`public`](#public)
  - [`protected`](#protected)
  - [package-private (default, «без модификатора»)](#package-private-default-без-модификатора)
  - [`private`](#private)
- [Исключения](#исключения)
- [Логирование](#логирование)
  - [System.err.println](#systemerrprintln)
  - [Log4j](#log4j)
  - [JUL — java.util.logging](#jul--javautillogging)
  - [JCL — jakarta commons logging](#jcl--jakarta-commons-logging)
  - [Logback](#logback)
  - [SLF4J — simple logging facade for java](#slf4j--simple-logging-facade-for-java)
  - [Уровни логирования](#уровни-логирования)
  - [slf4j-log4j12](#slf4j-log4j12)

## JVM / JRE / JDC

**JVM** — Java Virtual Machine (Виртуальная машина Java) - абстрактная/реализованная машина, которая выполняет байт-код Java.

**JRE** — Java Runtime Environment (Среда выполнения Java) - пакет, содержащий JVM + стандартные библиотеки и средства запуска — нужен, чтобы просто запустить Java-программу.

**JDK** — Java Development Kit (Набор средств разработки для Java) - включает JRE + набор инструментов разработки (компилятор javac, javadoc, jar, отладчики и т.д.) — нужен разработчику.

```text
JDK
 └─ содержит JRE
     └─ содержит JVM + runtime class libraries (java.*)
```

Пример рабочего цикла:

1. `javac Hello.java` → создаёт Hello.class (байт-код).  
2. `java Hello` → JVM внутри JRE/JDK загружает и выполняет байт-код.

### JVM

JVM — не «программа», а платформа/спецификация: когда вы говорите «JVM», вы можете иметь в виду либо спецификацию (описание поведения), либо конкретную реализацию (HotSpot, OpenJ9 и т.д.).  
Разные реализации JVM имеют разные сборщики мусора (G1, Shenandoah, ZGC и т.д.), разные JIT-алгоритмы.

Основные обязанности реализации JVM:

- **Загрузка классов (Class Loader)** — загружает `.class` (байт-код) в память.
- **Проверка байт-кода (Bytecode Verifier)** — проверяет безопасность/корректность загружаемого байт-кода.
- **Исполнение байт-кода — интерпретатор + JIT (Just-In-Time) компиляция** для ускорения «горячих» участков.
- **Управление памятью и сборка мусора - GC (Garbage Collection)** — распределяет объекты в heap и запускает GC по необходимости.
- **Механизмы многопоточности и синхронизации** — реализация Java Memory Model, управление потоками и блокировками.
- **Интеграция с нативным кодом (JNI)** — возможность вызывать нативные библиотеки.

### JRE

JRE — это «пакет для запуска». В него входят:

- реализация **JVM**;
- **стандартные class libraries** (например `rt.jar` в старых версиях или модули `java.base` и другие в модульной системе);
- **java launcher** (утилита `java`), инфраструктура запуска приложений.

### JDK

JDK = JRE + инструменты разработки.

Основные элементы JDK:

- Компилятор `javac` (переводит `.java` → `.class`);
- Запускатор `java` (входит в JRE);
- Инструменты: `javadoc`, `jar`, `jlink`, `jmap`, `jstack`, профайлеры, отладчики и др.;
- Исходные заголовочные файлы и API-документация.

JDK нужен разработчику, JRE — пользователю, но в современных релизах Oracle/дистрибуции это разграничение сдвинулось - с Java 11 Oracle перестал публиковать отдельные JRE/Server-JRE для скачивания — вместо этого рекомендуется поставлять JDK или собирать тонкую runtime-сборку с помощью `jlink`. Если собираете приложение для продакшена, часто включают встроенный runtime (custom runtime) — команда `jlink` позволяет собрать минимальную runtime-сборку.

## Примитивы (Primitive Data Types)

|Примитив|Размер в памяти|Диапазон значений|Точность|
|---|---|---|---|
|**byte**|8 бит|-128 … 127|-|
|**short**|16 бит|-32 768 … 32 767|-|
|**int**|32 бит|-2 147 483 648 … 2 147 483 647|-|
|**long**|64 бит|-9 223 372 036 854 775 808 … 9 223 372 036 854 775 807|-|
|**char**|16 бит|UTF-16 code unit. 0 … 65 535 ('\u0000' … '\uffff')|-|
|**float**|32 бит|≈1.4·10^-45 … ≈3.4·10^38|~6–7 значащих десятичных цифр|
|**double**|64 бит|≈4.9·10^-324 … ≈1.8·10^308|~15–16 значащих десятичных цифр|
|**boolean**|-|true и false|-|

## Ссылочные типы (Reference types)

В Java ссылочные типы — это все типы, кроме примитивов: объекты классов, массивы, интерфейсы, String, Enum и т.д. Переменная ссылочного типа хранит ссылку (указатель) на объект в куче (heap); сам объект (его поля и внутреннее состояние) хранится в куче.

```text
Stack (локальные переменные)
+-------------------------+
| localRef -> 0x7f9a3b20  |  ← переменная (ссылка)
+-------------------------+

Heap (объекты)
0x7f9a3b20: ObjectInstance {
    [object header: mark word][klass ptr]
    field1: 123
    field2: "hello"
}
```

## Работа с памятью

Как JVM выделяет и инициализирует объект:

1. Вызывается new SomeClass().
2. JVM резервирует место в heap.
3. Пишет object header (mark word, klass ptr) и нулит поля/инициализирует по дефолту.
4. Возвращает ссылку (адрес) — значение записывается в локальную переменную (на стеке) или поле другого объекта.

|Тип|Хранение|Изменяемость|Пример|
|---|---|---|---|
|Примитив|В стеке|✅ Mutable|int a = 5|
|String|В куче|❌ Immutable|"Hello"|
|Array|В куче|✅ Mutable|int[] a = {1,2}|
|Collection|В куче|✅ Mutable (обычно)|ArrayList<>|
|Map|В куче|✅ Mutable|HashMap<>|

## Модификаторы видимости (доступа)

Модификаторы доступа контролируют, какие классы/методы/поля/конструкторы видимы из каких мест в программе — это главный инструмент инкапсуляции.

В Java есть четыре «уровня» доступа (в порядке от наибольшего доступа к наименьшему):

- `public` — доступ везде;
- `protected` — доступ внутри пакета и для подклассов;
- *package-private* (*default*, без ключевого слова) — доступ только внутри того же пакета;
- `private` — доступ только внутри того же класса (для членов) или недоступен для топ-уровневого класса.

### `public`

- Что: открытый доступ **из любого места** (любого пакета, любого модуля, при наличии экспортов модулей).
- Где применим: топ-уровневые классы (только public или default), методы, поля, конструкторы, вложенные классы.
- Пример:

```java
// file: com/example/A.java
package com.example;
public class A {
    public int x;
    public void foo() {}
}
```

Другой класс в любом пакете может `new com.example.A()` и обратиться к `x` и `foo()`.

### `protected`

- `protected` даёт доступ **в пределах пакета** (как package-private) и — дополнительный — **для подклассов** вне пакета.
- Нюанс: когда подкласс находится в другом пакете, доступ к `protected`-члену разрешён только через объект, чего тип является подклассом (или внутри subclass-кода — обычно через `this`). Проще: подкласс может обращаться к `protected` членам своего суперкласса для себя/своих экземпляров, но не может произвольно взять экземпляр суперкласса (из другого пакета) и читать/писать его `protected` поле.

Пример (легальный):

```java
// package a
package a;
public class Super {
    protected int p = 42;
}

// package b
package b;
import a.Super;
public class Sub extends Super {
    void test() {
        System.out.println(this.p); // OK: доступ через "this"
    }
}
```

Пример (нелегальный — компилятор выдаст ошибку):

```java
// package b
package b;
import a.Super;
public class Friend {
    void test(Super s) {
        System.out.println(s.p); // ERROR если Friend не в том же пакете a и не является подклассом
    }
}
```

В пакете `a` любой другой класс (даже не являющийся подклассом) может обращаться к `p`, потому что package access включён. `protected` = package + subclass.

### package-private (default, «без модификатора»)

- Что: если нет ключевого слова `public/protected/private`, то доступ разрешён только **внутри того же пакета** (package-private). Часто называют «default access» или «package access».
- Где применим: топ-уровневые классы (может быть только package-private или public), члены класса.
- Пример:

```java
// в пакете com.example
class PackageOnly {       // package-private top-level class
    void doSomething() {} // package-private method
}
```

Классы/члены в других пакетах не увидят их. Это удобный способ скрыть реализацию в пакете.

### `private`

- Что: виден **только внутри того же класса** (для членов). Для вложенных (inner/static nested) классов `private` также ограничивает видимость в пределах внешнего класса / вложенного класса как обычного члена.
- Где применим: поля, методы, конструкторы, вложенные классы. Топ-уровневые классы не могут быть `private`.
- Пример:

```java
public class Secret {
    private int secretValue;
    private void hide() {}
    private static class Helper {} // допустимо
}
```

Ни один другой класс (даже в том же пакете) не может обратиться к `secretValue` или `hide()`.

## Исключения

С точки зрения Java все исключения - это классы, которые являются потомками класса `Throwable`. Иерархия исключений схематично представлена на рисунке:

![Иерархия исключений](https://github.com/ilsinyakov/QA_Theory/blob/main/Pictures/Иерархия_исключений.png?raw=true)

У класса `Throwable` имеются два непосредственных подкласса: `Exception` и `Error`.

Исключения типа `Error`  - это критические ошибки.  Например, `StackOverflowError` (переполнение стека вызовов) или `OutOfMemoryError` (нехватка памяти для создания новых объектов). Обрабатывать такие ошибки нет смысла. Программа должна быть остановлена, поэтому реакция на них в прикладной программе не предусматривается.

Исключения типа `Exception`  - это менее серьезные ошибки.  Они делятся на две группы: проверяемые (**checked**) и непроверяемые (**unchecked**).

Для **непроверяемых** исключений программист не обязан предусматривать обработку в программе (хотя может это сделать, если потребуется). К ним относятся, например, `ArrayIndexOutOfBoundsException` (выход за границы массива), `ArithmeticException` (арифметическая ошибка, например деление на ноль),  или `NumberFormatException` (неверное преобразование символьной строки в число).  Непроверяемые исключения являются подклассами `RuntimeException`. Этот класс находится в пакете `java.lang`, который импортируется по умолчанию во все программы на Java.

**Проверяемые** исключения – это такие исключения, на которые следует обязательно реагировать в программе (обрабатывать или перебрасывать "наверх"). Компилятор знает, в каких методах такое исключение может возникнуть, и потребует его обработки. Например, если идет запись в файл, то может возникнуть `IOException` (ошибка ввода-вывода). В некоторых методах, связанных с многопоточной обработкой, может возникнуть `InterruptedException`. Обращение к базе данных может вызвать  `SQLException`  и т.д.

Исключения могут наследоваться друг от друга. Например, у `IOException` есть подклассы `FileNotFoundException`, `SocketException`, `UnsupportedDataTypeException` и многие другие разновидности ошибок ввода-вывода.

## Логирование

Из известных решений по логированию в Java можно выделить:

- log4j
- JUL — java.util.logging
- JCL — jakarta commons logging
- Logback
- SLF4J — simple logging facade for java

### System.err.println

Первоначально был, разумеется, `System.err.println` (вывод записи в консоль). Его и сейчас используют для быстрого получения лога при дебаге. Конечно, говорить о каких-то настройках здесь не приходится.

### Log4j

Это уже было полноценное решение, которое создавалось из потребностей разработчиков. Получился действительно интересный инструмент, который можно использовать.

В силу разных обстоятельств это решение так и не попало в JDK, чем очень расстроило все комьюнити.

В log4j были возможности по конфигурации таким образом, чтобы можно было включить логирование в пакете `com.example.type` и выключить его в подпакете `com.example.type.generic`. Это позволяло быстро отсечь то, что нужно логировать, от того, что не нужно.

Здесь важно отметить, что есть две версии log4j: 1.2.х и 2.х.х, которые несовместимы друг с другом.

log4j добавил такое понятие как **appender**, то есть инструмент, с помощью которого записываются логи и **layout** — форматирование логов. Это позволяет записывать только то, что нужно и как нужно.

В настоящий момент log4j не поддерживается и в связке с SLF4J рекомендуется использовать форк - reload4j.

### JUL — java.util.logging

Одно из ключевых преимуществ это решения — JUL включен в JDK (Java development kit). К сожалению, при его разработке за основу взяли не популярный log4j, а решение от IBM, что и повлияло на его развитие. По факту на данный момент JUL есть, но им никто не пользуется.

Из “такого себе”: в JUL уровни логирования отличаются от того, что есть в Logback, Log4j, Slf4j, и это ухудшает понимание между ними.

### JCL — jakarta commons logging

Из-за того, что долгое время не было промышленного стандарта в логировании и был период, когда многие создавали свой кастомный логгер, решили выпустить JCL — общую обертку, которая  использовалась бы над другими.

Почему? Когда в проект добавлялись какие-то зависимости, они могли использовать логгер, отличный от логгера на проекте. Из-за этого они транзитивно добавлялись в проект, что создавало реальные проблемы при попытке все это собрать воедино.

К сожалению, обертка была очень бедна на функциональность и никаких дополнений не вносила.

Наверное, было бы удобно, если бы все использовали JCL для работы. Но на деле так не получалось, поэтому на данный момент применять JCL — не лучшая идея.

### Logback

Logback написал тот же разработчик, что и log4j, чтобы создать ему преемника. В основе была та же идея, что и в log4j.

Отличия были в том, что в logback:

- улучшена производительность;
- добавлена нативная поддержка slf4j;
- расширена опция фильтрации.

### SLF4J — simple logging facade for java

Где-то в 2006 году один из отцов-основателей log4j вышел из проекта и создал slf4j — Simple Logging Facade for Java — обертку вокруг log4j, JUL, common-logging и logback.

Как видим, прогресс дошел до того, что создали обертку над оберткой…

Причем она делится на две части: API, который используется в приложении и реализация, которая добавляется отдельными зависимостями для каждого вида логирования.

Например, `slf4j-log4j12.jar`, `slf4j-jdk14.jar`. Достаточно подключить правильную реализацию и все: весь проект будет работать с ней.

Slf4j поддерживает все новые функции, такие как форматирование строк для логирования.

### Уровни логирования

||FATAL|ERROR|WARN|INFO|DEBUG|TRACE|ALL|
|--|--|--|--|--|--|--|--|
|OFF||||||||
|FATAL|x|||||||
|ERROR|x|x||||||
|WARN|x|x|x|||||
|INFO|x|x|x|x||||
|DEBUG|x|x|x|x|x|||
|TRACE|x|x|x|x|x|x||
|ALL|x|x|x|x|x|x|x|

Для того, чтоб как-то ранжировать логи, нужно было дать определенные обозначения и разграничения. Для этого ввели уровни логирования.

Уровень задается в приложении. Если запись относится к уровню ниже обозначенного, она не вносится в лог.

Например, у нас есть логи, с помощью которых дебажат приложение. В нормальной работе на продакшене (когда приложение используют по назначению), такие логи не нужны. Поэтому уровень логирования будет выше, чем для дебага.

Давайте рассмотрим уровни на примере log4j. Остальные решения, кроме JUL, используют такие же уровни. Вот они в порядке уменьшения:

- **OFF**: никакие логи не записываются, все будут проигнорированы;
- **FATAL**: ошибка, после которой приложение уже не сможет работать и будет остановлено, например, JVM out of memory error;
- **ERROR**: уровень ошибок, когда есть проблемы, которые нужно решить. Ошибка не останавливает работу приложения в целом. Остальные запросы могут работать корректно;
- **WARN**: обозначаются логи, которые содержат предостережение. Произошло неожиданное действие, несмотря на это система устояла и выполнила запрос;
- **INFO**: лог, который записывает важные действия в приложении. Это не ошибки, это не предостережение, это ожидаемые действия системы;
- **DEBUG**: логи, необходимые для отладки приложения. Для уверенности в том, что система делает именно то, что от нее ожидают, или описания действия системы: “method1 начал работу”;
- **TRACE**: менее приоритетные логи для отладки, с наименьшим уровнем логирования;
- **ALL**: уровень, при котором будут записаны все логи из системы.

Получается, что если в приложении в каком-то месте включен уровень логирования INFO, будут логироваться все уровни, начиная с INFO и до FATAL. Если будет уровень логирования FATAL, будут записаны только логи с этим уровнем.

### slf4j-log4j12

Рассмотрим работу этой связки подробнее.

Для настройки логирования используется файл `src/main/resources/log4j.properties`

```ini
log4j.rootLogger=INFO, CONSOLE, FILE

log4j.appender.CONSOLE=org.apache.log4j.ConsoleAppender
log4j.appender.CONSOLE.Target=System.out
log4j.appender.CONSOLE.layout=org.apache.log4j.PatternLayout
log4j.appender.CONSOLE.layout.ConversionPattern=%d{yyyy-MM-dd HH:mm:ss} [%p] %c.%M - %m%n

log4j.appender.FILE=org.apache.log4j.RollingFileAppender
log4j.appender.FILE.File=logs/wo-telemetry.log
log4j.appender.FILE.MaxFileSize=1MB
log4j.appender.FILE.MaxBackupIndex=1
log4j.appender.FILE.layout=org.apache.log4j.PatternLayout
log4j.appender.FILE.layout.ConversionPattern=%d{yyyy-MM-dd HH:mm:ss} [%p] %c.%M - %m%n
```

`rootLogger` - указывает уровень логирования и используемые аппендеры.

`appender` - указывает, кда будет записываться лог.  
Бывают:

- FileAppender - в файл без ротации
- RollingFileAppender - в файл с ротацией
- ConsoleAppender - в консоль
- JDBCAppender - в БД
- TelnetAppender - по сети

`layout` - указывает, как будет форматироваться строка с логом.

Для инициализации логгера нужно определить его в соответствующем классе:

```java
private final Logger logger = LoggerFactory.getLogger(TelegramClient.class);
```

Есть два способа создать сам лог.

- **традиционный**:

    ```java
    logger.info("Hello World");
    logger.info("Hello {}", "World");
    ```

    нужно помнить о том, что прямая конкатенация строки будет вызвана в любом случае, независимо от установленного уровня логирования, что может приводить к существенному замедлению работы приложения. Для исключения этих лишних вызовов используется параметризованное сообщение с плейсхолдерами `{}`.

- **Fluent Logging API**:  
Свободный (или быстрый) API.

    ```java
    int newT = 15;
    int oldT = 16;

    // using fluent API, log message with arguments
    logger.atDebug().log("Temperature set to {}. Old value was {}.", newT, oldT);
   
    // using fluent API, add arguments one by one and then log message
    logger.atDebug().setMessage("Temperature set to {}. Old value was {}.")
            .addArgument(newT).addArgument(oldT).log();

    // using fluent API, add one argument with a Supplier and then log message with one more argument.
    // Assume the method t16() returns 16.
    logger.atDebug().setMessage("Temperature set to {}. Old value was {}.")
            .addArgument(() -> t16()).addArgument(oldT).log();

    // lambda in log()
    logger.atDebug().log(() -> "Telegram response:\n" + response.body());
    ```

    такая конструкция предотвращает ненужные вычисления, если соответствующий уровень логирования отключен.

    Можно также использовать перечисление пар ключ=значение напрямую:

    ```java
    int newT = 15;
    int oldT = 16;

    // using classical API
    logger.debug("oldT={} newT={} Temperature changed.", oldT, newT);

    // using fluent API 
    logger.atDebug().setMessage("Temperature changed.")
            .addKeyValue("oldT", oldT).addKeyValue("newT", newT).log();
    ```
