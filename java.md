# Java

- [JVM / JRE / JDK](#jvm--jre--jdk)
  - [JVM](#jvm)
  - [JRE](#jre)
  - [JDK](#jdk)
- [Примитивы (Primitive Data Types)](#примитивы-primitive-data-types)
- [Ссылочные типы (Reference types)](#ссылочные-типы-reference-types)
- [Работа с памятью](#работа-с-памятью)
- [Модификаторы видимости (доступа)](#модификаторы-видимости-доступа)
  - [`public`](#public)
  - [`protected`](#protected)
  - [package-private (default, «без модификатора»)](#package-private-default-без-модификатора)
  - [`private`](#private)
- [Модификатор `final`](#модификатор-final)
  - [Final переменные](#final-переменные)
  - [Final методы](#final-методы)
  - [Final классы](#final-классы)
  - [Final параметры методов](#final-параметры-методов)
  - [Blank final переменные](#blank-final-переменные)
  - [Static final переменные (константы)](#static-final-переменные-константы)
- [Исключения](#исключения)
- [Методы `Object`](#методы-object)
  - [`public String toString()`](#public-string-tostring)
  - [`public boolean equals(Object obj)`](#public-boolean-equalsobject-obj)
  - [`public int hashCode()`](#public-int-hashcode)
  - [`public final Class<?> getClass()`](#public-final-class-getclass)
  - [`protected Object clone() throws CloneNotSupportedException`](#protected-object-clone-throws-clonenotsupportedexception)
  - [`protected void finalize() throws Throwable` (устаревший, начиная с Java 9)](#protected-void-finalize-throws-throwable-устаревший-начиная-с-java-9)
- [Абстрактные классы и интерфейсы](#абстрактные-классы-и-интерфейсы)
  - [Интерфейсы](#интерфейсы)
    - [Когда использовать интерфейсы](#когда-использовать-интерфейсы)
    - [Переопределение метода интерфейса](#переопределение-метода-интерфейса)
    - [Неизменяемые переменные](#неизменяемые-переменные)
    - [Default-методы](#default-методы)
  - [Абстрактные классы](#абстрактные-классы)
    - [Абстрактные методы в абстрактных классах](#абстрактные-методы-в-абстрактных-классах)
    - [Когда использовать абстрактные классы](#когда-использовать-абстрактные-классы)
  - [Различия между абстрактными классами и интерфейсами](#различия-между-абстрактными-классами-и-интерфейсами)
- [Логирование](#логирование)
  - [System.err.println](#systemerrprintln)
  - [Log4j](#log4j)
  - [JUL — java.util.logging](#jul--javautillogging)
  - [JCL — jakarta commons logging](#jcl--jakarta-commons-logging)
  - [Logback](#logback)
  - [SLF4J — simple logging facade for java](#slf4j--simple-logging-facade-for-java)
  - [Уровни логирования](#уровни-логирования)
  - [slf4j-log4j12](#slf4j-log4j12)
- [Spring](#spring)
  - [Spring Framework](#spring-framework)
  - [Преимущества и недостатки Spring](#преимущества-и-недостатки-spring)
    - [Преимущества](#преимущества)
    - [Недостатки](#недостатки)
  - [Основные понятия Spring](#основные-понятия-spring)
    - [DI/IoC](#diioc)
    - [Бины и контекст](#бины-и-контекст)
    - [Способы конфигурации приложения](#способы-конфигурации-приложения)
    - [Репозиторий](#репозиторий)
  - [Аннотации Spring](#аннотации-spring)
    - [`@Bean`](#bean)
  - [Spring Boot](#spring-boot)
    - [Контроллер в Spring Boot](#контроллер-в-spring-boot)
    - [ENVIRONMENT в Spring Boot](#environment-в-spring-boot)

## JVM / JRE / JDK

**JVM** — Java Virtual Machine (Виртуальная машина Java) - абстрактная/реализованная машина, которая выполняет байт-код Java.

**JRE** — Java Runtime Environment (Среда выполнения Java) - пакет, содержащий JVM + стандартные библиотеки и средства запуска — нужен, чтобы просто запустить Java-программу.

**JDK** — Java Development Kit (Набор средств разработки для Java) - включает JRE + набор инструментов разработки (компилятор javac, javadoc, jar, отладчики и т.д.) — нужен разработчику.

```text
JDK
 └─ содержит JRE
     └─ содержит JVM + runtime class libraries (java.*)
```

Пример рабочего цикла:

1. `javac Hello.java` → создаёт Hello.class (байт-код).  
2. `java Hello` → JVM внутри JRE/JDK загружает и выполняет байт-код.

### JVM

JVM — не «программа», а платформа/спецификация: когда вы говорите «JVM», вы можете иметь в виду либо спецификацию (описание поведения), либо конкретную реализацию (HotSpot, OpenJ9 и т.д.).  
Разные реализации JVM имеют разные сборщики мусора (G1, Shenandoah, ZGC и т.д.), разные JIT-алгоритмы.

Основные обязанности реализации JVM:

- **Загрузка классов (Class Loader)** — загружает `.class` (байт-код) в память.
- **Проверка байт-кода (Bytecode Verifier)** — проверяет безопасность/корректность загружаемого байт-кода.
- **Исполнение байт-кода — интерпретатор + JIT (Just-In-Time) компиляция** для ускорения «горячих» участков.
- **Управление памятью и сборка мусора - GC (Garbage Collection)** — распределяет объекты в heap и запускает GC по необходимости.
- **Механизмы многопоточности и синхронизации** — реализация Java Memory Model, управление потоками и блокировками.
- **Интеграция с нативным кодом (JNI)** — возможность вызывать нативные библиотеки.

### JRE

JRE — это «пакет для запуска». В него входят:

- реализация **JVM**;
- **стандартные class libraries** (например `rt.jar` в старых версиях или модули `java.base` и другие в модульной системе);
- **java launcher** (утилита `java`), инфраструктура запуска приложений.

### JDK

JDK = JRE + инструменты разработки.

Основные элементы JDK:

- Компилятор `javac` (переводит `.java` → `.class`);
- Запускатор `java` (входит в JRE);
- Инструменты: `javadoc`, `jar`, `jlink`, `jmap`, `jstack`, профайлеры, отладчики и др.;
- Исходные заголовочные файлы и API-документация.

JDK нужен разработчику, JRE — пользователю, но в современных релизах Oracle/дистрибуции это разграничение сдвинулось - с Java 11 Oracle перестал публиковать отдельные JRE/Server-JRE для скачивания — вместо этого рекомендуется поставлять JDK или собирать тонкую runtime-сборку с помощью `jlink`. Если собираете приложение для продакшена, часто включают встроенный runtime (custom runtime) — команда `jlink` позволяет собрать минимальную runtime-сборку.

## Примитивы (Primitive Data Types)

|Примитив|Размер в памяти|Диапазон значений|Точность|
|---|---|---|---|
|**byte**|8 бит|-128 … 127|-|
|**short**|16 бит|-32 768 … 32 767|-|
|**int**|32 бит|-2 147 483 648 … 2 147 483 647|-|
|**long**|64 бит|-9 223 372 036 854 775 808 … 9 223 372 036 854 775 807|-|
|**char**|16 бит|UTF-16 code unit. 0 … 65 535 ('\u0000' … '\uffff')|-|
|**float**|32 бит|≈1.4·10^-45 … ≈3.4·10^38|~6–7 значащих десятичных цифр|
|**double**|64 бит|≈4.9·10^-324 … ≈1.8·10^308|~15–16 значащих десятичных цифр|
|**boolean**|-|true и false|-|

## Ссылочные типы (Reference types)

В Java ссылочные типы — это все типы, кроме примитивов: объекты классов, массивы, интерфейсы, String, Enum и т.д. Переменная ссылочного типа хранит ссылку (указатель) на объект в куче (heap); сам объект (его поля и внутреннее состояние) хранится в куче.

```text
Stack (локальные переменные)
+-------------------------+
| localRef -> 0x7f9a3b20  |  ← переменная (ссылка)
+-------------------------+

Heap (объекты)
0x7f9a3b20: ObjectInstance {
    [object header: mark word][klass ptr]
    field1: 123
    field2: "hello"
}
```

## Работа с памятью

Как JVM выделяет и инициализирует объект:

1. Вызывается new SomeClass().
2. JVM резервирует место в heap.
3. Пишет object header (mark word, klass ptr) и нулит поля/инициализирует по дефолту.
4. Возвращает ссылку (адрес) — значение записывается в локальную переменную (на стеке) или поле другого объекта.

|Тип|Хранение|Изменяемость|Пример|
|---|---|---|---|
|Примитив|В стеке|✅ Mutable|int a = 5|
|String|В куче|❌ Immutable|"Hello"|
|Array|В куче|✅ Mutable|int[] a = {1,2}|
|Collection|В куче|✅ Mutable (обычно)|ArrayList<>|
|Map|В куче|✅ Mutable|HashMap<>|

## Модификаторы видимости (доступа)

Модификаторы доступа контролируют, какие классы/методы/поля/конструкторы видимы из каких мест в программе — это главный инструмент инкапсуляции.

В Java есть четыре «уровня» доступа (в порядке от наибольшего доступа к наименьшему):

- `public` — доступ везде;
- `protected` — доступ внутри пакета и для подклассов;
- *package-private* (*default*, без ключевого слова) — доступ только внутри того же пакета;
- `private` — доступ только внутри того же класса (для членов) или недоступен для топ-уровневого класса.

### `public`

- Что: открытый доступ **из любого места** (любого пакета, любого модуля, при наличии экспортов модулей).
- Где применим: топ-уровневые классы (только public или default), методы, поля, конструкторы, вложенные классы.
- Пример:

```java
// file: com/example/A.java
package com.example;
public class A {
    public int x;
    public void foo() {}
}
```

Другой класс в любом пакете может `new com.example.A()` и обратиться к `x` и `foo()`.

### `protected`

- `protected` даёт доступ **в пределах пакета** (как package-private) и — дополнительный — **для подклассов** вне пакета.
- Нюанс: когда подкласс находится в другом пакете, доступ к `protected`-члену разрешён только через объект, чего тип является подклассом (или внутри subclass-кода — обычно через `this`). Проще: подкласс может обращаться к `protected` членам своего суперкласса для себя/своих экземпляров, но не может произвольно взять экземпляр суперкласса (из другого пакета) и читать/писать его `protected` поле.

Пример (легальный):

```java
// package a
package a;
public class Super {
    protected int p = 42;
}

// package b
package b;
import a.Super;
public class Sub extends Super {
    void test() {
        System.out.println(this.p); // OK: доступ через "this"
    }
}
```

Пример (нелегальный — компилятор выдаст ошибку):

```java
// package b
package b;
import a.Super;
public class Friend {
    void test(Super s) {
        System.out.println(s.p); // ERROR если Friend не в том же пакете a и не является подклассом
    }
}
```

В пакете `a` любой другой класс (даже не являющийся подклассом) может обращаться к `p`, потому что package access включён. `protected` = package + subclass.

### package-private (default, «без модификатора»)

- Что: если нет ключевого слова `public/protected/private`, то доступ разрешён только **внутри того же пакета** (package-private). Часто называют «default access» или «package access».
- Где применим: топ-уровневые классы (может быть только package-private или public), члены класса.
- Пример:

```java
// в пакете com.example
class PackageOnly {       // package-private top-level class
    void doSomething() {} // package-private method
}
```

Классы/члены в других пакетах не увидят их. Это удобный способ скрыть реализацию в пакете.

### `private`

- Что: виден **только внутри того же класса** (для членов). Для вложенных (inner/static nested) классов `private` также ограничивает видимость в пределах внешнего класса / вложенного класса как обычного члена.
- Где применим: поля, методы, конструкторы, вложенные классы. Топ-уровневые классы не могут быть `private`.
- Пример:

```java
public class Secret {
    private int secretValue;
    private void hide() {}
    private static class Helper {} // допустимо
}
```

Ни один другой класс (даже в том же пакете) не может обратиться к `secretValue` или `hide()`.

## Модификатор `final`

Модификатор `final` в Java используется для ограничения изменяемости: он может применяться к переменным, методам, классам и параметрам.

### Final переменные

Переменная, объявленная с ключевым словом `final`, может быть инициализирована только один раз. После присвоения значения изменить его нельзя.

Для **примитивных** типов это означает, что значение не может быть изменено.  
Для **ссылочных** типов – сама ссылка не может указывать на другой объект, но состояние самого объекта можно менять (если объект изменяем).

```java
public class FinalVariableExample {
    public static void main(String[] args) {
        final int number = 10;
        // number = 20; // Ошибка компиляции

        final StringBuilder sb = new StringBuilder("Hello");
        sb.append(", World"); // OK – меняем состояние объекта
        // sb = new StringBuilder("New"); // Ошибка – нельзя переназначить ссылку
        System.out.println(sb); // Hello, World
    }
}
```

### Final методы

Метод, помеченный `final`, не может быть переопределён в подклассе. Это используется, когда реализация метода должна оставаться неизменной во всей иерархии наследования.

```java
class Parent {
    public final void show() {
        System.out.println("Это финальный метод");
    }
}

class Child extends Parent {
    // Ошибка компиляции: cannot override final method
    // public void show() { ... }
}
```

### Final классы

Класс, объявленный как `final`, не может иметь подклассов (нельзя наследоваться от него). Это применяется для создания неизменяемых (immutable) классов или классов, которые не предназначены для расширения (например, `String`, `Integer`).

```java
final class Constants {
    public static final double PI = 3.14159;
}

// Ошибка компиляции: cannot inherit from final Constants
// class SubClass extends Constants { }
```

### Final параметры методов

Параметры метода можно пометить `final`, чтобы запретить изменение значения параметра внутри метода (для примитивов) или переназначение ссылки (для объектов).

```java
public void process(final int value, final StringBuilder data) {
    // value = 5; // Ошибка – нельзя изменить значение параметра
    data.append(" дополнение"); // OK – объект можно менять
    // data = new StringBuilder(); // Ошибка – нельзя переназначить ссылку
}
```

### Blank final переменные

Это final-переменные, которые объявлены без инициализации. Они должны быть обязательно инициализированы в конструкторе (или в блоке инициализации для нестатических, или в статическом блоке для статических).

```java
public class Person {
    private final String name; // blank final

    public Person(String name) {
        this.name = name; // инициализация в конструкторе
    }

    public String getName() {
        return name;
    }
}
```

### Static final переменные (константы)

Часто используется комбинация `static final` для создания констант уровня класса. Такие переменные обычно именуются заглавными буквами с подчёркиванием.

```java
public class MathConstants {
    public static final double PI = 3.14159;
    public static final int MAX_VALUE = 100;
}
```

Обращение: `MathConstants.PI`

## Исключения

С точки зрения Java все исключения - это классы, которые являются потомками класса `Throwable`. Иерархия исключений схематично представлена на рисунке:

![Иерархия исключений](https://github.com/ilsinyakov/QA_Theory/blob/main/Pictures/Иерархия_исключений.png?raw=true)

У класса `Throwable` имеются два непосредственных подкласса: `Exception` и `Error`.

Исключения типа `Error`  - это критические ошибки.  Например, `StackOverflowError` (переполнение стека вызовов) или `OutOfMemoryError` (нехватка памяти для создания новых объектов). Обрабатывать такие ошибки нет смысла. Программа должна быть остановлена, поэтому реакция на них в прикладной программе не предусматривается.

Исключения типа `Exception`  - это менее серьезные ошибки.  Они делятся на две группы: проверяемые (**checked**) и непроверяемые (**unchecked**).

Для **непроверяемых** исключений программист не обязан предусматривать обработку в программе (хотя может это сделать, если потребуется). К ним относятся, например, `ArrayIndexOutOfBoundsException` (выход за границы массива), `ArithmeticException` (арифметическая ошибка, например деление на ноль),  или `NumberFormatException` (неверное преобразование символьной строки в число).  Непроверяемые исключения являются подклассами `RuntimeException`. Этот класс находится в пакете `java.lang`, который импортируется по умолчанию во все программы на Java.

**Проверяемые** исключения – это такие исключения, на которые следует обязательно реагировать в программе (обрабатывать или перебрасывать "наверх"). Компилятор знает, в каких методах такое исключение может возникнуть, и потребует его обработки. Например, если идет запись в файл, то может возникнуть `IOException` (ошибка ввода-вывода). В некоторых методах, связанных с многопоточной обработкой, может возникнуть `InterruptedException`. Обращение к базе данных может вызвать  `SQLException`  и т.д.

Исключения могут наследоваться друг от друга. Например, у `IOException` есть подклассы `FileNotFoundException`, `SocketException`, `UnsupportedDataTypeException` и многие другие разновидности ошибок ввода-вывода.

## Методы `Object`

Класс `Object` является корнем иерархии классов в Java. Все классы неявно наследуются от `Object`, поэтому его методы доступны в любом объекте.

### `public String toString()`

Возвращает строковое представление объекта.  
Реализация по умолчанию возвращает строку вида:  
`getClass().getName() + '@' + Integer.toHexString(hashCode())`

Обычно переопределяется для вывода содержательной информации о состоянии объекта.

### `public boolean equals(Object obj)`

Сравнивает текущий объект с переданным на эквивалентность.  
Реализация по умолчанию использует оператор == (сравнение ссылок).  
Переопределяется для логического сравнения по содержимому.  
При переопределении необходимо соблюдать контракт: рефлексивность, симметричность, транзитивность, согласованность и сравнение с `null` должно давать `false`.

Важно: при переопределении `equals` всегда переопределяйте `hashCode`.

### `public int hashCode()`

Возвращает целочисленный хеш-код объекта, используемый в хеш-структурах (`HashMap`, `HashSet` и т.д.).
Контракт:

- Если два объекта равны по `equals()`, их хеш-коды должны быть одинаковы.
- Если объекты не равны, хеш-коды не обязаны быть разными, но это желательно для производительности.
- При многократном вызове на неизменном объекте должен возвращать одно и то же число.

### `public final Class<?> getClass()`

Возвращает объект типа `Class`, представляющий класс данного объекта во время выполнения.  
Используется для рефлексии и получения метаинформации (имя класса, модификаторы, поля, методы и т.д.).

```java
Class<?> clazz = obj.getClass();
System.out.println(clazz.getName());
```

### `protected Object clone() throws CloneNotSupportedException`

Создаёт и возвращает копию объекта.
Реализация по умолчанию выполняет поверхностное копирование (shallow copy). Для возможности клонирования класс должен реализовать интерфейс-маркер `Cloneable`, иначе будет выброшено `CloneNotSupportedException`.  
Рекомендуется переопределять для глубокого копирования (deep copy) или использовать альтернативные способы (копирующие конструкторы, фабрики).

### `protected void finalize() throws Throwable` (устаревший, начиная с Java 9)

Вызывается сборщиком мусора перед уничтожением объекта. Предназначался для освобождения ресурсов (закрытие файлов, соединений).  
Надёжность метода крайне низкая, его использование не рекомендуется из-за непредсказуемости времени вызова и проблем с производительностью. Заменён на `try-with-resources`, `Cleaner` и `PhantomReference`.

## Абстрактные классы и интерфейсы

**Интерфейс** — это контракт, который должен быть реализован конкретным классом.

**Абстрактный класс** похож на обычный, но отличается тем, что может содержать абстрактные методы — методы без реализации, и нельзя создать экземпляр абстрактного класса.

### Интерфейсы

**Интерфейс** — это контракт, который реализуется в некотором классе. У интерфейса не может быть состояния, поэтому в нем нельзя использовать изменяемые поля экземпляра. В интерфейсе могут быть только неизменяемые final-поля.

#### Когда использовать интерфейсы

Интерфейсы очень полезны для уменьшения связанности (coupling) кода и реализации полиморфизма. Для примера давайте взглянем на интерфейс `List`:

```java
public interface List<E> extends Collection<E> {

    int size();
    boolean isEmpty();
    boolean add(E e);
    E remove(int index);
    void clear();
}
```

Здесь мы видим сигнатуры методов, которые будут реализованы в конкретном классе, реализующем этот интерфейс.

Контракт интерфейса `List` реализуется классами `ArrayList`, `Vector`, `LinkedList` и другими.

При использовании полиморфизма тип переменной объявляем как `List`, и присваиваем ей любую из доступных реализаций. Например:

```java
List list = new ArrayList();
List list = new LinkedList();
```

В этом случае в каждом классе присутствует своя реализация методов. И это отличный пример использования интерфейсов. Если вы заметили, что ряд ваших классов содержит одинаковые методы, но с разными реализациями, то стоит использовать интерфейс.

#### Переопределение метода интерфейса

Помните, что интерфейс — это контракт, который должен быть реализован конкретным классом. Методы интерфейса неявно **абстрактны** и обязаны быть реализованы в классе, реализующем этот интерфейс.
Обратите внимание еще раз, что методы интерфейса неявно абстрактны и их не нужно явно объявлять как `abstract`.

#### Неизменяемые переменные

Еще одно правило, которое следует помнить, заключается в том, что интерфейс может содержать только **неизменяемые переменные**. Следующий код вполне рабочий:

```java
public interface Challenger {
  
  int number = 7;
  String name = "Java Challenger";
}
```

Обратите внимание, что обе переменные неявно `final` и `static`. Это означает, что они являются константами, не зависят от экземпляра и не могут быть изменены.

При попытке изменить поля в интерфейсе Challenger, например, следующим образом:

```java
Challenger.number = 8;
Challenger.name = "Another Challenger";
```

будет ошибка компиляции.

#### Default-методы

У методов по умолчанию может быть реализация, а у абстрактных методов — нет. Методы по умолчанию — результат появления лямбда-выражений и Stream API

В качестве примера default-метода из JDK можно привести метод `forEach()` из интерфейса `Iterable`. Вместо копирования кода этого метода во все реализации `Iterable`, мы можем переиспользовать метод `forEach()`:

```java
default void forEach(Consumer<? super T> action) {
    ...
}
```

Любая реализация `Iterable` может использовать метод `forEach()` без необходимости реализации этого метода.

Важно отметить, что у default-метода должна быть реализация и default-метод не может быть статическим.

### Абстрактные классы

У абстрактных классов может быть **состояние** в виде изменяемых полей экземпляра его наследника. Например:

```java
public abstract class AbstractClassMutation {

  private String name = "challenger";

  public static void main(String[] args) {
    AbstractClassMutation abstractClassMutation = new AbstractClassImpl();
    abstractClassMutation.name = "mutated challenger";
    System.out.println(abstractClassMutation.name); //mutated challenger
  }
}

class AbstractClassImpl extends AbstractClassMutation { }
```

#### Абстрактные методы в абстрактных классах

Аналогично интерфейсам в абстрактных классах могут быть абстрактные методы.  
**Абстрактный метод** — это метод без тела (без реализации).  
Но в отличие от интерфейсов, абстрактные методы в абстрактных классах должны быть явно объявлены как абстрактные.

```java
public abstract class AbstractMethods {

  abstract void doSomething();
}
```

#### Когда использовать абстрактные классы

Рекомендуется использовать абстрактный класс, когда вам нужно **изменяемое состояние**. Если хранить состояние класса не нужно, обычно лучше использовать интерфейс.

### Различия между абстрактными классами и интерфейсами

С точки зрения объектно-ориентированного программирования основное различие между интерфейсом и абстрактным классом заключается в том, что интерфейс не может иметь состояния, тогда как абстрактный класс может (в виде полей экземпляра наследника).

Другое ключевое различие заключается в том, что классы могут реализовывать более одного интерфейса, но расширять только один абстрактный класс.

Еще одно различие состоит в том, что интерфейс может быть реализован классом или расширен другим интерфейсом, а класс может быть только расширен.

Также важно отметить, что лямбда-выражения могут использоваться только с функциональными интерфейсами (интерфейс только с одним методом), но не с абстрактными классами с одним абстрактным методом.

Сравнение интерфейсов и абстрактных классов:

<!-- markdownlint-disable MD033-->
|Интерфейсы|Абстрактные классы|
|--|--|
|Могут содержать только final static поля. Интерфейс никогда не может изменять свое состояние|Могут быть любые поля, в том числе статические, изменяемые и неизменяемые|
|Класс может реализовывать несколько интерфейсов|Класс может расширять только один абстрактный класс|
|Может быть реализован с помощью ключевого слова `implements`<br><br>Может расширять другой интерфейс с помощью `extends`|Может быть только расширен с помощью `extends`|
|Можно использовать только `static` `final` поля. Параметры и локальные переменные в методах|Могут быть изменяемые поля экземпляра. Параметры и локальные переменные в методах|
|В лямбда-выражениях могут использоваться только функциональные интерфейсы|Абстрактные классы с одним абстрактным методом не могут использоваться в лямбда-выражениях|
|Не может быть конструктора|Может содержать конструктор|
|Могут быть абстрактные методы<br><br>Могут быть `default` и `static` методы (c Java 8)<br><br>Могут быть `private` методы с реализацией (с Java 9)|Могут быть любые методы|
<!-- markdownlint-enable MD033-->

## Логирование

Из известных решений по логированию в Java можно выделить:

- log4j
- JUL — java.util.logging
- JCL — jakarta commons logging
- Logback
- SLF4J — simple logging facade for java

### System.err.println

Первоначально был, разумеется, `System.err.println` (вывод записи в консоль). Его и сейчас используют для быстрого получения лога при дебаге. Конечно, говорить о каких-то настройках здесь не приходится.

### Log4j

Это уже было полноценное решение, которое создавалось из потребностей разработчиков. Получился действительно интересный инструмент, который можно использовать.

В силу разных обстоятельств это решение так и не попало в JDK, чем очень расстроило все комьюнити.

В log4j были возможности по конфигурации таким образом, чтобы можно было включить логирование в пакете `com.example.type` и выключить его в подпакете `com.example.type.generic`. Это позволяло быстро отсечь то, что нужно логировать, от того, что не нужно.

Здесь важно отметить, что есть две версии log4j: 1.2.х и 2.х.х, которые несовместимы друг с другом.

log4j добавил такое понятие как **appender**, то есть инструмент, с помощью которого записываются логи и **layout** — форматирование логов. Это позволяет записывать только то, что нужно и как нужно.

В настоящий момент log4j не поддерживается и в связке с SLF4J рекомендуется использовать форк - reload4j.

### JUL — java.util.logging

Одно из ключевых преимуществ это решения — JUL включен в JDK (Java development kit). К сожалению, при его разработке за основу взяли не популярный log4j, а решение от IBM, что и повлияло на его развитие. По факту на данный момент JUL есть, но им никто не пользуется.

Из “такого себе”: в JUL уровни логирования отличаются от того, что есть в Logback, Log4j, Slf4j, и это ухудшает понимание между ними.

### JCL — jakarta commons logging

Из-за того, что долгое время не было промышленного стандарта в логировании и был период, когда многие создавали свой кастомный логгер, решили выпустить JCL — общую обертку, которая  использовалась бы над другими.

Почему? Когда в проект добавлялись какие-то зависимости, они могли использовать логгер, отличный от логгера на проекте. Из-за этого они транзитивно добавлялись в проект, что создавало реальные проблемы при попытке все это собрать воедино.

К сожалению, обертка была очень бедна на функциональность и никаких дополнений не вносила.

Наверное, было бы удобно, если бы все использовали JCL для работы. Но на деле так не получалось, поэтому на данный момент применять JCL — не лучшая идея.

### Logback

Logback написал тот же разработчик, что и log4j, чтобы создать ему преемника. В основе была та же идея, что и в log4j.

Отличия были в том, что в logback:

- улучшена производительность;
- добавлена нативная поддержка slf4j;
- расширена опция фильтрации.

### SLF4J — simple logging facade for java

Где-то в 2006 году один из отцов-основателей log4j вышел из проекта и создал slf4j — Simple Logging Facade for Java — обертку вокруг log4j, JUL, common-logging и logback.

Как видим, прогресс дошел до того, что создали обертку над оберткой…

Причем она делится на две части: API, который используется в приложении и реализация, которая добавляется отдельными зависимостями для каждого вида логирования.

Например, `slf4j-log4j12.jar`, `slf4j-jdk14.jar`. Достаточно подключить правильную реализацию и все: весь проект будет работать с ней.

Slf4j поддерживает все новые функции, такие как форматирование строк для логирования.

### Уровни логирования

||FATAL|ERROR|WARN|INFO|DEBUG|TRACE|ALL|
|--|--|--|--|--|--|--|--|
|OFF||||||||
|FATAL|x|||||||
|ERROR|x|x||||||
|WARN|x|x|x|||||
|INFO|x|x|x|x||||
|DEBUG|x|x|x|x|x|||
|TRACE|x|x|x|x|x|x||
|ALL|x|x|x|x|x|x|x|

Для того, чтоб как-то ранжировать логи, нужно было дать определенные обозначения и разграничения. Для этого ввели уровни логирования.

Уровень задается в приложении. Если запись относится к уровню ниже обозначенного, она не вносится в лог.

Например, у нас есть логи, с помощью которых дебажат приложение. В нормальной работе на продакшене (когда приложение используют по назначению), такие логи не нужны. Поэтому уровень логирования будет выше, чем для дебага.

Давайте рассмотрим уровни на примере log4j. Остальные решения, кроме JUL, используют такие же уровни. Вот они в порядке уменьшения:

- **OFF**: никакие логи не записываются, все будут проигнорированы;
- **FATAL**: ошибка, после которой приложение уже не сможет работать и будет остановлено, например, JVM out of memory error;
- **ERROR**: уровень ошибок, когда есть проблемы, которые нужно решить. Ошибка не останавливает работу приложения в целом. Остальные запросы могут работать корректно;
- **WARN**: обозначаются логи, которые содержат предостережение. Произошло неожиданное действие, несмотря на это система устояла и выполнила запрос;
- **INFO**: лог, который записывает важные действия в приложении. Это не ошибки, это не предостережение, это ожидаемые действия системы;
- **DEBUG**: логи, необходимые для отладки приложения. Для уверенности в том, что система делает именно то, что от нее ожидают, или описания действия системы: “method1 начал работу”;
- **TRACE**: менее приоритетные логи для отладки, с наименьшим уровнем логирования;
- **ALL**: уровень, при котором будут записаны все логи из системы.

Получается, что если в приложении в каком-то месте включен уровень логирования INFO, будут логироваться все уровни, начиная с INFO и до FATAL. Если будет уровень логирования FATAL, будут записаны только логи с этим уровнем.

### slf4j-log4j12

Рассмотрим работу этой связки подробнее.

Для настройки логирования используется файл `src/main/resources/log4j.properties`

```ini
log4j.rootLogger=INFO, CONSOLE, FILE

log4j.appender.CONSOLE=org.apache.log4j.ConsoleAppender
log4j.appender.CONSOLE.Target=System.out
log4j.appender.CONSOLE.layout=org.apache.log4j.PatternLayout
log4j.appender.CONSOLE.layout.ConversionPattern=%d{yyyy-MM-dd HH:mm:ss} [%p] %c.%M - %m%n

log4j.appender.FILE=org.apache.log4j.RollingFileAppender
log4j.appender.FILE.File=logs/wo-telemetry.log
log4j.appender.FILE.MaxFileSize=1MB
log4j.appender.FILE.MaxBackupIndex=1
log4j.appender.FILE.layout=org.apache.log4j.PatternLayout
log4j.appender.FILE.layout.ConversionPattern=%d{yyyy-MM-dd HH:mm:ss} [%p] %c.%M - %m%n
```

`rootLogger` - указывает уровень логирования и используемые аппендеры.

`appender` - указывает, кда будет записываться лог.  
Бывают:

- FileAppender - в файл без ротации
- RollingFileAppender - в файл с ротацией
- ConsoleAppender - в консоль
- JDBCAppender - в БД
- TelnetAppender - по сети

`layout` - указывает, как будет форматироваться строка с логом.

Для инициализации логгера нужно определить его в соответствующем классе:

```java
private final Logger logger = LoggerFactory.getLogger(TelegramClient.class);
```

Есть два способа создать сам лог.

- **традиционный**:

    ```java
    logger.info("Hello World");
    logger.info("Hello {}", "World");
    ```

    нужно помнить о том, что прямая конкатенация строки будет вызвана в любом случае, независимо от установленного уровня логирования, что может приводить к существенному замедлению работы приложения. Для исключения этих лишних вызовов используется параметризованное сообщение с плейсхолдерами `{}`.

- **Fluent Logging API**:  
Свободный (или быстрый) API.

    ```java
    int newT = 15;
    int oldT = 16;

    // using fluent API, log message with arguments
    logger.atDebug().log("Temperature set to {}. Old value was {}.", newT, oldT);
   
    // using fluent API, add arguments one by one and then log message
    logger.atDebug().setMessage("Temperature set to {}. Old value was {}.")
            .addArgument(newT).addArgument(oldT).log();

    // using fluent API, add one argument with a Supplier and then log message with one more argument.
    // Assume the method t16() returns 16.
    logger.atDebug().setMessage("Temperature set to {}. Old value was {}.")
            .addArgument(() -> t16()).addArgument(oldT).log();

    // lambda in log()
    logger.atDebug().log(() -> "Telegram response:\n" + response.body());
    ```

    такая конструкция предотвращает ненужные вычисления, если соответствующий уровень логирования отключен.

    Можно также использовать перечисление пар ключ=значение напрямую:

    ```java
    int newT = 15;
    int oldT = 16;

    // using classical API
    logger.debug("oldT={} newT={} Temperature changed.", oldT, newT);

    // using fluent API 
    logger.atDebug().setMessage("Temperature changed.")
            .addKeyValue("oldT", oldT).addKeyValue("newT", newT).log();
    ```

## Spring

### Spring Framework

**Spring** — один из самых популярных фреймворков. Его применяют backend-разработчики, которые работают на Java, Kotlin и Groovy. С помощью Spring Framework можно создавать веб- и консольные приложения.

В спринге стараются по максимуму отойти от жесткой связности (когда ваши классы напрямую зависят от каких-то классов/интерфейсов из фреймворка), и используют для этой цели **аннотации**.

Фреймворк состоит из **модулей**, каждый из которых предлагает набор готовых инструментов. Например:

- **Spring Web**: позволяет предоставлять API для потребителя;
- **Spring Data**: работает с различными видами баз данных, как SQL, так и NoSQL;
- **Spring Test**: предоставляет инструментарий для написания юнит- и интеграционных тестов;
- **Spring Cloud**: отдельная экосистема внутри Спринга. Позволяет предоставлять конфигурации сервисам и работать в распределенных системах;
- **Spring Integration**: интегрирует приложения компании в единую систему.

Модули Spring можно использовать для работы над разными частями приложения. Их можно подключать вместе или по отдельности, все зависит от поставленной задачи.

![Spring Modules](https://github.com/ilsinyakov/QA_Theory/blob/main/Pictures/Spring_Framework.webp?raw=true)

### Преимущества и недостатки Spring

#### Преимущества

- **Универсальность**. Spring фреймворк предлагает готовые инструменты для решения самых разных задач, от работы с почтой до настроек безопасности.
- **Экономия времени**. Сокращает time-to-market время и ускоряет разработку.
- **Избавление от рутины**. Spring предлагает готовые решения для рутинных задач. Программистам больше не нужно тратить время на однотипные куски кода.
- **Открытый исходный код**. Его можно адаптировать и настроить под нужды проекта.
- **Популярность**. На рынке есть много вакансий для тех, кто работает на Spring Java. Этот фреймворк используют для большинства проектов.
- **Доступность**. Создать приложение на Spring можно абсолютно бесплатно.

#### Недостатки

- **Сложность**. Спринг тяжело настраивать, это инструмент для опытных разработчиков.
- **Вес кода**. Проекты на Spring Framework дольше загружаются и требуют оптимизации.
- **Непонятная работа некоторых модулей**. Например, Spring Data JPA, который генерирует неочевидные SQL-запросы.
- **Много неиспользуемых зависимостей**. В финальную сборку кода входит много ненужного материала.

### Основные понятия Spring

#### DI/IoC

**IoC (Inversion of Control)** — инверсия управления. При использовании библиотеки вы сами прописываете в своем коде, какой метод какого объекта вызвать, а в случает с фреймворками — чаще всего уже фреймворк будет вызывать в нужный ему момент тот код, который вы написали. То есть, тут уже не вы управляете процессом выполнения кода/программы, а фреймворк это делает за вас. Вы передали ему управление (инверсия управления).

Под **DI** понимают то **Dependency Inversion** (инверсию зависимостей, то есть попытки не делать жестких связей между вашими модулями/классами, где один класс напрямую завязан на другой), то **Dependency Injection** (внедрение зависимостей, это когда объекты котиков создаете не вы в main-е и потом передаете их в свои методы, а за вас их создает спринг, а вы ему просто говорите что-то типа "хочу сюда получить котика", и он вам его передает в ваш метод).

#### Бины и контекст

Одно из ключевых понятий в спринге — это **бин**. По сути, это просто объект какого-то класса.

Допустим, для нашей программы надо использовать 3 объекта: котика, собачку и попугайчика.

И у нас есть куча классов с кучей методов, где иногда нам нужен для метода котик, а для другого метода — собачка, а иногда у нас будут методы, где нужен котик и попугайчик (например метод для кормежки котика, хе-хе), а в каких-то методах — все три объекта понадобятся. Да, мы можем в main-е сначала создать эти три объекта, а потом их передавать в наши классы, а уже изнутри классов — в нужные нам методы... И так по всей программе. А если еще и представить, что периодически мы захотим менять список принимаемых параметров для наших методов (ну решили переписать что-то или добавить функциональности) — то нам придется делать довольно много правок по коду если надо будет что-то поменять. А теперь если представить, что таких объектов у нас не 3, а 300?

Как вариант, это собрать все наши такие объекты в какой-то один общий список объектов (`List<Object>`) и во все методы передавать его, а изнутри методов уже доставать тот или иной объект, который нам нужен. Но что если представить, что по ходу программы у нас в этот список может добавиться какой-то объект, или (что хуже) удалиться? Тогда во всех методах, где мы достаем объекты из списка по их индексу — все может поломаться.

Тогда мы решаем хранить не список, а мапу, где ключом будет имя нужного нам объекта, а значением — сам объект, и тогда мы сможем из него доставать нужные нам объекты просто по их имени: get("попугайчик") и в ответ получили объект попугайчика. Или например ключ — это класс объекта, а значение — сам объект, тогда мы сможем указать уже не имя объекта, а просто класс нужного нам объекта, тоже удобно. Или даже написать какую-то обертку над мапой, где сделать методы, чтобы в каких-то случаях доставать объекты по их имени, а в других случаях — по классу.

Вот это и получится у нас **application context** из спринга.

**Контекст** — это набор бинов (объектов). Обращаясь к контексту — мы можем получить нужный нам бин (объект) по его имени например, или по его типу, или еще как-то.

Для получения объекта (бина) из контекста (ApplicationContext) есть несколько способов:

- Внедрение зависимости (`Autowired`):

    ```java
    @Component
    public class MyService {
        public void doSomething() { ... }
    }

    @Component
    public class MyComponent {
        @Autowired
        private MyService myService; // Spring сам подставит бин из контекста

        public void work() {
            myService.doSomething();
        }
    }
    ```

    Это работает для всех бинов, управляемых Spring (компоненты, сервисы, репозитории, контроллеры и т.д.).
- Получение ссылки на `ApplicationContext`:

    ```java
    @Component
    public class ContextHolder {
        @Autowired
        private ApplicationContext context;

        public void someMethod() {
            MyService bean = context.getBean(MyService.class);
            // или по имени:
            MyService beanByName = (MyService) context.getBean("myService");
        }
    }
    ```

Кроме того, мы можем попросить спринг самого сходить поискать в своем контексте нужный нам бин и передать его в наш метод.

Например, если у нас был такой метод:

```java
public void doSomething(Cat cat) {
    ...
}
```

нам спринг когда вызывал этот метод — передавал в него объект нашего котика из своего контекста. Теперь мы решаем, что нашему методу кроме котика нужен еще и попугайчик. Используя спринг — для нас нет ничего проще!

Мы просто пишем:

```java
public void doSomething(Cat cat, Parrot parrot) {
    ...
}
```

и спринг, когда будет вызывать этот наш метод — сам поймет, что сюда надо передать котика и попугайчика, сходит к себе в контекст, достанет эти два объекта и передаст их в наш метод.

Передав спрингу бразды правления нашей программой — мы так же переложили на него ответственность за создание объектов и передачу их в наши методы, которые он будет вызывать.

#### Способы конфигурации приложения

Существует три основных способа конфигурации приложения (то-есть, указания спрингу какие именно объекты нам нужны для работы):

- при помощи xml файлов/конфигов;
- при помощи java-конфигов;
- автоматическая конфигурация.

Разработчики спринга выстраивают их в таком порядке приоритетности:

- наиболее приоритетный способ, которому стоит отдавать предпочтение — это автоматическая конфигурация;
- если при помощи автоматической конфигурации нет возможности правильно настроить все возможные бины — использовать джава-конфигурацию (создание объектов используя джава код);
- ну и самый низкоприоритетный способ — это по-старинке, используя xml конфиги.

Кроме того, спринг позволяет комбинировать эти способы. Например, все то, что может быть настроено автоматически — пусть спринг сделает сам, там где надо указать какие-то особые параметры — сделать при помощи джава-конфигов, и кроме того, можно подключить какие-то легаси конфиги в xml формате. В общем, достаточно гибко это все можно сделать. Но все же, если все можно сделать при помощи автоматической настройки — используйте ее.

Автоматическая конфигурация используется тогда, когда нужные нам для работы объекты — это объекты написанных нами классов.

Если для создания объекта нашего класса нужна какая-то очень специфическая логика, или если у нас нет возможность отметить какой-то класс нужной нам аннотацией, которую подхватила бы автоматическая конфигурация — это можно сделать в джава-конфигах.

#### Репозиторий

**Репозиторий** в Spring (обычно в контексте Spring Data JPA) — это абстракция над слоем доступа к данным, которая значительно упрощает работу с хранилищем данных (БД, NoSQL, REST API и т.д.). Это центральное понятие в экосистеме Spring Data.

Проще говоря, это прослойка между вашим бизнес-логическим кодом и базой данных, которая избавляет вас от написания boilerplate-кода (шаблонного кода для CRUD-операций).

Ключевые **характеристики и возможности**:

1. Абстракция над JPA EntityManager / JDBC: Прячет низкоуровневые детали работы с БД.
2. Сокращение кода: Позволяет выполнять стандартные операции без написания SQL/JPQL-запросов.
3. Декларативное создание запросов: Запросы можно создавать просто называя методы по соглашению или используя аннотацию `@Query`.
4. Интеграция со Spring: Легко внедряется (`@Autowired`) в компоненты Spring (сервисы, контроллеры).

**Основные типы репозиториев в Spring Data JPA**:

1. `CrudRepository<T, ID>` — базовый интерфейс.  
Предоставляет основные CRUD-операции: save(), findById(), findAll(), count(), delete() и т.д.
2. `JpaRepository<T, ID>` — наиболее часто используемый.  
Наследует `CrudRepository` и `PagingAndSortingRepository`.  
Добавляет JPA-специфичные методы: `flush()`, `saveAndFlush()`, `deleteInBatch()`.  
Возвращает List вместо Iterable в некоторых методах.  
По умолчанию включает поддержку пагинации и сортировки.
3. `PagingAndSortingRepository<T, ID>` — добавляет пагинацию и сортировку к `CrudRepository`.

Пример:

```java
//Создание сущности
@Entity
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String name;
    private String email;
    // геттеры, сеттеры, конструкторы...
}


//Создание репозитория
import org.springframework.data.jpa.repository.JpaRepository;
import java.util.List;

public interface UserRepository extends JpaRepository<User, Long> {
    
    // Spring Data САМ реализует этот метод!
    // Правило именования: findBy + ИмяПоля + (НеобязательныеУсловия)
    List<User> findByName(String name);
    
    // Более сложный запрос по соглашению
    List<User> findByEmailContainingIgnoreCase(String email);
    
    // Можно написать свой JPQL-запрос
    @Query("SELECT u FROM User u WHERE u.name LIKE %:name%")
    List<User> searchByName(@Param("name") String name);
    
    // Или нативным SQL
    @Query(value = "SELECT * FROM users WHERE email = ?1", nativeQuery = true)
    User findByEmailNative(String email);
}


// Использование в сервисе
@Service
public class UserService {
    
    @Autowired
    private UserRepository userRepository; // Внедряем репозиторий
    
    public User createUser(User user) {
        return userRepository.save(user); // Сохраняем без SQL!
    }
    
    public List<User> findUsersByName(String name) {
        return userRepository.findByName(name); // Используем декларативный метод
    }
    
    public Page<User> getUsersPage(int page, int size) {
        return userRepository.findAll(PageRequest.of(page, size)); // Пагинация "из коробки"
    }
}

```

**Итог**:  
Репозиторий в Spring — это интерфейс, который:

1. Расширяет один из базовых интерфейсов Spring Data (JpaRepository, CrudRepository).
2. Объявляет методы для доступа к данным.
3. Автоматически получает реализацию от Spring.
4. Позволяет взаимодействовать с БД на высоком уровне абстракции, минимизируя рутинный код.

### Аннотации Spring

#### `@Bean`

**Назначение**: объявляет в методе фабрику Spring-бина — возвращаемый объект регистрируется в `ApplicationContext`.

**Имя бина**: по-умолчанию — имя метода; можно задать `@Bean("myName")`

**Скоуп**: по-умолчанию `singleton`. Изменяют через `@Scope("prototype")` и т.п.

**Когда использовать**: для конфигурации бинов из сторонних библиотек или когда нужно создать бин программно (настройка, фабрика, сложная инициализация). Для простых Java-классов чаще используют `@Component/@Service/@Repository`.

### Spring Boot

**Spring Boot** — это дополнение к фреймворку Spring, которое облегчает и ускоряет работу. С его помощью можно:

- использовать различные стартеры, предоставляемые экосистемой Spring Boot’а;
- автоматически задавать конфигурации приложения;
- использовать встроенный веб-сервер (по умолчанию используется Tomcat, но можно изменить в настройках).

Последнее отличие самое важное. Изначально для работы со Спринг Джава нужно было собрать приложение и положить его в отдельную папку на сервере. Spring Boot имеет встроенный сервер внутри самого приложения. Это, во-первых, экономит время. Во-вторых, уменьшает стоимость содержания инфраструктуры.

Spring Boot предлагает разработчикам те же самые функции, что и обычный Спринг, но при этом работать с ним намного легче.

![Spring Boot](https://github.com/ilsinyakov/QA_Theory/blob/main/Pictures/Spring_Boot.png?raw=true)

#### Контроллер в Spring Boot

**Контроллер** — это компонент приложения, который принимает HTTP-запросы, обрабатывает их и возвращает ответ. В Spring Boot контроллеры реализованы поверх Spring MVC (DispatcherServlet) и служат "входной точкой" для веб-слоя.

**Аннотации**:

- `@Controller` — обычный MVC-контроллер (возвращает view или шаблон).
- `@RestController` — `@Controller` + `@ResponseBody`, возвращает тело ответа (обычно JSON) напрямую.
- Маршрутизация: `@RequestMapping`, `@GetMapping`, `@PostMapping`, `@PutMapping`, `@DeleteMapping` и т.п.

**Методы**: методы контроллера — это handler methods, принимают параметры из запроса (`@PathVariable`, `@RequestParam`, `@RequestBody`, `@RequestHeader` и т.д.) и возвращают данные (String, DTO, `ResponseEntity<T>`, ModelAndView и т.п.).

```java
import org.springframework.web.bind.annotation.*;

@RestController //Указывает, что класс является контроллером, который обрабатывает HTTP-запросы и возвращает данные (например, JSON или текст) напрямую, без использования представлений
@RequestMapping("/api") //Определяет базовый URL-путь для всех методов в этом контроллере
public class HelloController {

    @GetMapping("/hello") //метод обрабатывает GET-запросы по адресу /api/hello
    public String sayHello() {
        return "Привет, мир!";
    }

    @PostMapping("/greet") //для обработки POST-запросов на /api/greet
    public String greet(@RequestParam String name) { //извлекает из запроса параметр name
        return "Здравствуй, " + name + "!";
    }
}
```

**Сериализация/десериализация**: Spring использует `HttpMessageConverter` (обычно Jackson) для преобразования JSON ↔ POJO

Для **запуска** приложения нужен основной класс с аннотацией `@SpringBootApplication` и методом `main`:

```java
@SpringBootApplication
public class DemoApplication {
    public static void main(String[] args) {
        SpringApplication.run(DemoApplication.class, args);
    }
}
```

- Spring Boot **автоматически** сканирует классы в текущем пакете и его подпакетах, находит контроллеры и регистрирует их.
- При запуске встроенный сервер (Tomcat) разворачивает приложение, и вы можете обращаться к эндпоинтам:
  - `GET /api/hello` → ответ: Привет, мир!
  - `POST /api/greet?name=Иван` → ответ: Здравствуй, Иван!

#### ENVIRONMENT в Spring Boot

**Переменные окружения** — это пара `NAME=VALUE`, которые предоставляет операционная система (или контейнер/оркестратор) процессу при его старте. Их используют для конфигурации приложений (путь к БД, порт, секреты и т.п.) без правки кода или артефактов.

Spring Boot собирает конфигурацию из множества источников (command-line, env vars, файл application.yml/properties, system properties и т.д.) и использует правило приоритета: значения сверху перечёркивают нижележащие. Это позволяет гибко переопределять настройки в среде.

Порядок приоритета (сверху — выше приоритет):

1. Аргументы командной строки (--server.port=8081)
2. `SPRING_APPLICATION_JSON` (JSON в env или system property)
3. ServletConfig / ServletContext init params (в веб-контейнере)
4. JNDI (если используется)
5. Java System properties (`-Dspring.profiles.active=prod`)
6. OS environment variables (переменные окружения)
7. `application.properties` / `application.yml` в внешнем `config/` или в той же папке, где jar
8. `application.properties` / `application.yml` в classpath (внутри jar)
9. `@PropertySource` и т.п.
10. Default properties (установленные программно через `SpringApplication.setDefaultProperties`)

Переменные окружения связываются с настройками Spring Boot через:

1. `@Value`

    ```java
    @Value("${MY_APP_TIMEOUT:30}") // если нет — 30 по умолчанию
    private int timeout;
    ```

    Spring сначала ищет свойство `MY_APP_TIMEOUT` в доступных источниках (включая переменные окружения, если имя совпадает с ключом).

2. `@ConfigurationProperties` (рекомендуется для групп настроек)

    ```java
    @Component
    @ConfigurationProperties(prefix = "app")
    public class AppProperties {
        private String host;
        private int port;
        
        // getters/setters
    }
    ```

    Переменные окружения `APP_HOST` и `APP_PORT` будут корректно привязаны.

3. Через `Environment`

    ```java
    @Autowired
    private Environment env;

    String url = env.getProperty("spring.datasource.url");
    ```

**Сопоставление имен**:

- точка `.` ↔ подчеркивание `_` в env vars;
- kebab-case (`my-app-value`) ↔ UNDERSCORE (`MY_APP_VALUE`);
- регистр игнорируется.

Примеры:

- property `spring.datasource.url` → env var `SPRING_DATASOURCE_URL`
- property `app.somethingValue` → env var `APP_SOMETHING_VALUE`
