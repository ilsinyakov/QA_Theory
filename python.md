# Python

## Типы данных

**Динамическая типизация** — Python автоматически определяет тип at runtime, без явного указания.

### Числовые типы (Numeric Types)

`int` – целые числа произвольной длины (включая отрицательные и положительные)

`float` – числа с плавающей точкой (десятичные), поддерживают экспоненциальную форму

`complex` – комплексные числа

### Логический тип (Boolean)

`bool` — значения `True` или `False`, представляет истину или ложь

В Python логические типы являются подтипом целых (`True == 1`, `False == 0`)

### Строки (Strings)

`str` — последовательность Unicode-символов, заключённая в одинарные или двойные кавычки

### Последовательности (Sequence Types)

`list` — упорядоченный изменяемый список объектов любого типа, поддерживает дублирование

`tuple` — упорядоченная неизменяемая коллекция, допускающая дублирование, быстрее и более компактна по памяти

### Множества (Sets)

`set` — неупорядоченный изменяемый набор уникальных элементов, без дубликатов

`frozenset` — неизменяемый аналог множества

### Словари (Dictionaries)

`dict` — коллекция пар «ключ: значение», с уникальными хэшируемыми ключами; с версии Python 3.7 упорядочены по вставке

### NoneType

`NoneType` — представляет отсутствие значения, аналог NULL в других языках, используется как `None`

## Изменяемость (Mutability)

**Изменяемые (mutable)**: `list`, `dict`, `set` - содержимое можно менять после создания

**Неизменяемые (immutable)**: `int`, `float`, `complex`, `str`, `tuple`, `bool`, `NoneType`, `frozenset` — после создания нельзя менять содержимое

## ООП

**Объектно-ориентированное программирование** — это парадигма, в которой всё моделируется как объекты с данными (атрибутами) и поведением (методами).

**Основные принципы** — инкапсуляция, абстракция, наследование и полиморфизм.

```python
class Dog:
    def __init__(self, name, breed):
        self.name = name
        self.breed = breed

    def speak(self):
        print(f"{self.name} говорит Гав!")
        
dog1 = Dog("Бобик", "Лабрадор")
dog1.speak()
```

Класс — шаблон (Dog), объект — экземпляр класса (dog1)

Метод `__init__()` вызывается при создании объекта.

`self` — ссылка на текущий экземпляр класса

### Основные принципы ООП

#### Инкапсуляция

Скрытие внутреннего состояния объекта.

```python
class Example:
    def __init__(self):
        self.__private_val = 42
```

Атрибут `__private_val` доступен только внутри класса.

#### Абстракция

Сокрытие внутренней реализации, предоставление только нужного интерфейса.

#### Наследование

```python
class Parent:
    def greet(self):
        print("Привет из Parent!")

class Child(Parent):
    pass

c = Child()
c.greet()
```

`Child` наследует методы от `Parent`

#### Полиморфизм

Разные классы реализуют один и тот же интерфейс.

```python
class Animal:
    def speak(self):
        raise NotImplementedError

class Dog(Animal):
    def speak(self):
        print("Гав!")

class Cat(Animal):
    def speak(self):
        print("Мяу!")

for a in [Dog(), Cat()]:
    a.speak()
```

То же имя метода, разная реализация.

### self

В Python `self` — это ссылка на текущий экземпляр класса, которая передаётся как первый параметр в методах экземпляра. Благодаря `self` метод "видит", какой именно объект используется.

Это не ключевое слово, а просто конвенция, её можно заменить, но по PEP‑8 принято именно `self`.

В `__init__` `self` позволяет сохранять переданные аргументы как атрибуты экземпляра:

```python
class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y
```

Все обычные методы класса должны принимать `self`, чтобы иметь доступ к атрибутам и другим методам этого экземпляра.

### Переменные (атрибуты) класса и экземпляра

```python
class Car:
    wheels = 4  # атрибут класса
    def __init__(self, make):
        self.make = make  # атрибут экземпляра
```

Все экземпляры разделяют `wheels`, но каждый имеет своё `make`.

### classmethod (метод класса)

Декорируется `@classmethod` и принимает первым аргументом `cls`, то есть сам класс, а не экземпляр.

Может получать и изменять атрибуты класса, но не экземпляра:

```python
class Car:
    wheels = 4

    @classmethod
    def set_wheels(cls, n):
        cls.wheels = n

```

Часто используется как "фабричные методы" — конструкторы с альтернативными путями создания экземпляров:

```python
from datetime import date

class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    @classmethod
    def from_birth_year(cls, name, year):
        return cls(name, date.today().year - year)

p = Person.from_birth_year("Ivan", 1990)
```

Здесь `from_birth_year` возвращает новый объект Person с рассчитанным возрастом.

### staticmethod (статический метод)

Декорируется `@staticmethod` и не получает ни `self`, ни `cls` автоматически.

Это обычная функция, просто размещённая внутри класса по смыслу, но не связана ни с классом, ни с экземпляром:

```python
class Math:
    @staticmethod
    def add(x, y):
        return x + y
```

Используется для утилитарных функций, логически относящихся к классу, но не работающих с его состоянием.

