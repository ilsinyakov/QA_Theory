# Архитектура серверного ПО

## Содержание

* [Основные понятия](#основные-понятия)
* [Обособленные серверные приложения](#обособленные-серверные-приложения)
	* [Возможные проблемы](#возможные-проблемы)
		* [Операционная система](#операционная-система)
		* [Сеть](сеть)
		* [Проблемы на стороне клиента](#проблемы-на-стороне-клиента)
* [Двузвенные приложения](#двузвенные-приложения)
	* [Возможные проблемы](#возможные-проблемы-1)
		* [Сеть: подключение верхнего звена к уровню данных](#сеть-подключение-верхнего-звена-к-уровню-данных)
		* [Уровень данных](#уровень-данных)
* [Трёхзвенные приложения](#трёхзвенные-приложения)
	* [Тонкий и толстый клиенты](#тонкий-и-толстый-клиенты)
	* [Бэкэнд и фронтэнд](#бэкэнд-и-фронтэнд)
	* [Трёхзвенная архитектура программного обеспечения](#трёхзвенная-архитектура-программного-обеспечения)
	* [Возможные проблемы](#возможные-проблемы-2)
* [Принципы локализации дефектов](#принципы-локализации-дефектов)
	* [Алгоритм локализации дефектов](#алгоритм-локализации-дефектов)
		* [Декомпозиция](#декомпозиция)
		* [Гипотезы](#гипотезы)
		* [Инструменты и методики](#инструменты-и-методики)
	* [Поиск неисправностей на практике](#поиск-неисправностей-на-практике)
	



## Основные понятия

Большая часть современного ПО поддерживает работу с сетями и может работать как клиент или сервер, а порой выполнять и обе роли.

С точки зрения ОС серверные приложения работают со следующими объектами:
1. Файлы: хранение настроек, чтение / запись данных по запросу от пользователей, и т.п.
2. Сокеты: для открытия серверных портов на прослушивание с целью приема запросов от пользователей
3. Процессы: процесс-родитель может запустить дочерние процессы для обработки пользовательских запросов.

С точки зрения сети, серверные приложения общаются с клиентами с помощью:
1. Протоколов прикладного уровня, например HTTP, SMTP, POP3
2. Протоколов транспортного уровня типа TCP или UDP

С точки зрения пользователя, нужно знать следующее:
1. Адрес сервера, порт и транспортный протокол. Например, веб-серверы могут прослушивать порт 443/TCP по умолчанию, однако другие порты могут настраиваться администраторами.
2. Прикладной протокол для общения с сервером. Например, сегодня веб-серверы, как правило, используют HTTPS, но некоторые всё ещё поддерживают HTTP.
3. Имя и пароль (или такие учётные данные, как сертификат), когда для работы с системой требуется вход и проверка подлинности.

## Обособленные серверные приложения

Обособленное серверное приложение взаимодействует только с:
* Операционной системой
* Клиентами, подключающимися по сети

У обособленных приложений может быть очень сложная внутренняя логика, но схема работы с данными у них относительно проста, поэтому им не нужна отдельная база данных для хранения информации, с которой они работают.

Следующие серверные приложения являются обособленными:

1. Файловые серверы: например, когда вы предоставляете доступ по сети к какой-либо папке на своем Windows-компьютере, ваш компьютер выступает в роли файлового сервера.
2. FTP-серверы. Похожи на файловые, но работают по другому прикладному протоколу.
3. Службы удаленного управления, например SSH и Remote Desktop.
4. Серверы баз данных (такие, как MySQL) также можно считать обособленными приложениями в простых случаях. Однако в более сложных конфигурациях, например с репликацией с ведущими и ведомыми серверами или распределённым хранилищем, базы данных не могут считаться самостоятельными приложениями.

### Возможные проблемы

#### Операционная система

ОС и ее настройки - наиболее частые причины возникновения проблем в обособленных серверных приложениях.

1. Отсутствующие объекты файловой системы: файлы, каталоги, символьные ссылки…  
Если кто-нибудь переместит или удалит их или отключит файловую систему, содержащую необходимые объекты, то приложение может даже не запуститься.
2. Некорректные настройки прав доступа к файлам, директориям и другим объектам операционной системы или приложения.  
Если прав недостаточно, то приложение не сможет получить доступ к этим объектам.  
Если же для конфиденциальных файлов (например, содержащих учётные данные) или директорий настроены слишком широкие права, то качественно спроектированное приложение остановит работу, обнаружив такие права при запуске.
3. (Аналогично предыдущему пункту.) Некорректно настроенные права пользователя для запуска приложения.  
Например: некоторые приложения не допускают запуск со стороны администратора (root), другие же, наоборот, для запуска требуют права администратора или участие в определённой группе.
4. Ошибочная настройка самого приложения, например: неверный формат файла настройки, указана неподдерживаемая или конфликтующая опция настройки, и т.п.
5. Конфликты, связанные с портами.  
Если нужный порт уже используется другим процессом, то приложение не сможет запуститься.
6. Недостаточное дисковое пространство для размещения временных файлов или файлов, запрошенных пользователем.
7. Нехватка памяти: в случае перегрузки сервера и исчерпания оперативной памяти операционная система может завершить работу некоторых приложений или по крайней мере отказаться выделить запрошенную приложением память.
8. Новые нестабильные компоненты либо конфликтующие компоненты, появившиеся в окружении, например обновления ОС, либо программные компоненты, внезапно установленные разработчиками.
9. Что-либо иное, например временные файлы, оставшиеся от предыдущего аварийного завершения работы прилижения.
10. Высокая загрузка центрального процессора или системы ввода-вывода (диски, сеть) не может в большинстве случаев привести к остановке приложения, но наверняка замедлит его работу.

#### Сеть

На уровне сети может случиться следующее, что может помешать доступу пользователя к серверному приложению:

1. Проблемы с маршрутизацией, когда сообщения клиента не достигают сервера.
2. Проблемы, связанные с системой DNS, когда пользователь обращается к серверу посредством полного доменного имени.
3. Межсетевой экран, блокирующий прохождение пакетов. Может быть настроен на любом узле: клиент, сервер, маршрутизатор между ними.
4. Перегруженные сегменты сети на стороне клиента или сервера.

#### Проблемы на стороне клиента

Что плохого может произойти на стороне клиента:

1. Неподдерживаемый тип или версия клиентского приложения.  
Например, веб-сайт, разработанный для Chrome, Firefox и Safari, может некорректно работать с Edge.
2. Неподдерживаемое или некорректное действие пользователя.
3. Некоторое ПО, обеспечивающее безопасность, препятствует работе пользователя с сервером.
4. Какие-либо настройки клиентского ПО мешают работе конкретно с этим сервером.
5. Если на сервере необходимо залогиниться, пользователь может ввести неверное имя учетной записи или пароль.
6. Пользователю запрещено что-либо делать на этом сервере.

## Двузвенные приложения

Если объём и разнообразие данных достаточно велики, то может потребоваться усложнить архитектуру программного обеспечения.  
Таким образом, приложение становится 2-звенным:
* Нижний уровень, называемый Data Tier (уровень данных), отвечает за хранение данных и доступ к ним. Чаще всего он реализован как серверное ПО баз данных. Примеры такого ПО: MySQL, PostgreSQL, Oracle, MS SQL.
* Верхний уровень для обработки запросов пользователей, также иногда отвечает за отображение информации пользователям. Он должен иметь подходящую логику и (при необходимости) обеспечивать пользовательский интерфейс. Это звено является отдельным приложением, написанным на PHP, Java, Python, Node.js или другом языке.

Главные различия между самостоятельными и двузвенными приложениями следующие:

1. Теперь у нас ДВА серверных приложения вместо одного.  
Стоит заметить, что с прикладной точки зрения эта пара всё равно зовётся «приложение», поскольку она работает как единое целое для удовлетворения прикладных и пользовательских потребностей.
2. Эти серверные приложения можно развернуть на двух отдельных узлах, связанных через сеть (общедоступную или закрытую).  
При необходимости их можно установить на один компьютер — это распространённый вариант для небольших веб-порталов.
3. Каждое звено рассматривается как отдельное приложение, для которого возможны соответствующие причины отказа.
4. У баз данных (БД) могут быть свои собственные точки отказа.
5. Верхнее звено подключается к системе БД и проходит проверку подлинности, используя своё имя пользователя и пароль (или сертификат), указанные в файлах конфигурации, — то есть оно действует как клиент БД.
6. Поэтому оно одновременно исполняет роль и сервера, и приложения.  
Пользователи видят сервер, обрабатывающий их запросы, но БД видит в нём клиента, отправляющего запросы ей.
7. Непосредственно БД недоступна для конечного пользователя, поскольку, во-первых, в этом нет необходимости, а во-вторых, в БД могут содержаться конфиденциальные данные других пользователей, и для таких данных нужна максимально возможная защита.  
По этой причине с БД должно работать только приложение верхнего уровня. Кстати, атаки типа «внедрение кода SQL» нацелены на получение посторонними лицами непосредственного доступа к БД.

Следующее ПО может быть примером 2-звенных серверных приложений:
1. Большинство интернет-форумов и CMS типа WordPress. Для небольших веб-сайтов оба компонента часто устанавливают на одном хосте.
2. Многие онлайн-игры: игровой клиент отвечает за UI-часть, а сервер производит анализ данных, вычисления, защиту от ботов, а также взаимодействует с СУБД.
3. Сложные серверы электронной почты.

### Возможные проблемы

Так как у нас теперь два приложения, каждое из них может столкнуться с проблемами, характерными для обособленных приложений. В то же время усложнение архитектуры несёт новые аспекты

#### Сеть: подключение верхнего звена к уровню данных

1. Неправильная конфигурация элементов верхнего уровня (например, IP-адрес или полное доменное имя сервера БД), некорректные учётные данные для подключения к БД, неверное название БД и т. д.
2. Так же как и в случае с обособленными приложениями, связь между этими двумя компонентами может нарушиться из-за проблем с маршрутизацией, DNS, межсетевыми экранами.
3. Однако чаще всего они устанавливаются на одном узле или находятся в одной локальной сети, что намного ближе по сравнению с внешними пользователями.

#### Уровень данных

Базы данных - достаточно сложные приложения, проблемы с которыми возможны в первую очередь из-за появляения отдельных учетных записей СУБД.

1. Учётные записи СУБД, применяемые вышестоящим уровнем, могут быть заблокированы.
2. Их пароли могут быть изменены без соответствующей перенастройки приложения верхнего уровня.
3. Права пользователей в отношении приложения верхнего уровня могут быть изменены или аннулированы, и необходимые данные тогда станут недоступны для чтения и (или) записи.
4. Согласованность данных может быть нарушена, например, когда соответствующие таблицы или записи изменяются другими средствами (представьте, что администратор БД допустил ошибку).

## Трёхзвенные приложения

### Тонкий и толстый клиенты

Клиентское ПО может быть реализовано в виде:

1. **Тонкого клиента** (например, браузера): чаще всего это сравнительно простое ПО, сильно зависящее от серверных компонент в т.ч. в плане интерфейса (т.е. сервер должен "нарисовать" еще и интерфейс, который будет показан клиенту). Также такие приложения чаще всего не умеют работать в оффлайн-режиме. С другой стороны, "тонкие клиенты" гораздо проще в реализации, что дает возможность сравнительно легко поддержать множество видов клиентских устройств и операционных систем.  
В двух словах: задача "тонкого клиента" - отобразить интерфейс, полученный от сервера, и дать пользователю возможность что-то туда ввести. "Тонкий клиент" должен быть максимально простым.
2. **Толстого клиента**, т.е. приложения с богатой функциональностью - гораздо большей, чем может быть реализовано в "тонком клиенте". Такое приложение не является универсальным (как браузер) и умеет работать только с определенной серверной частью, всего по одному или нескольким прикладным протоколам. Классические примеры:  клиенты онлайн-игр, почтовые клиенты (MS Outlook, Mozilla Thunderbird). Что касается последних: доступ к почте чаще всего можно получить и через браузер (применив "тонкий клиент") или с помощью Outlook / Thunderbird ("толстый клиент").

На самом деле, очень многие сложные сетевые приложения с "толстыми клиентами" по сути являются 2-звенными. Однако, если необходимо поддержать также "тонкие клиенты", приходится задуматься о дополнительном интерфейсе на стороне сервера, представлении данных и безопасности. В таком случае архитектура серверной части должна быть 3-звенная.

Представьте ситуацию, когда приложение должно работать под управлением Windows, MacOS, Linux, iOS, Android, QNX и FreeBSD. Разработка "толстого клиента" под каждую ОС займет существенное время. Однако, под каждую из них существует, например, браузер Firefox. Если к клиентскому приложению нет специфических требований (скажем, по быстродействию как для игр), то можно реализовать серверное приложение как 3-звенное веб-приложение с поддержкой браузеров как "тонких клиентов". Такой подход экономит компаниям-разработчикам много времени, сил и денег.

### Бэкэнд и фронтэнд

В зависимости от архитектуры и клиентского, и серверного ПО, эти два термина могут иметь различное значение:
**Фронтэнд или "фронт"** - приложение, отвечающее за пользовательский интерфейс (UI). "Толстые клиенты" реализуют эту функциональность самостоятельно, однако "тонкие клиенты" требуют наличия серверного Фронтэнд-компонента.

**Бэкэнд или "бэк** - часто этим словом называют ВСЮ серверную часть (независимо от количества звеньев). Однако для 3-звенной архитектуры этот термин имеет специальное более узкое значение.

### Трёхзвенная архитектура программного обеспечения

1. *Верхний уровень - Фронтэнд*, отвечает за пользовательский интерфейс и взаимодействие с пользователей. Он должно обеспечивать понятный и удобный UI с хорошим дизайном, настраиваемым видом и другими свойствами, которые необходимы пользователям. Если говорить о технической стороне, то он принимает входные данные и управляющие сигналы (зачастую проверяя их на безопасность) от пользователей и показывает выдачу сервера. Его можно разработать с помощью почти любого языка программирования, и оно часто создаётся самими компаниями, разрабатывающими какую-либо программную систему.
2. *Средний уровень - Бэкэнд*, невидимый пользователям, но крайне важный для работы приложения. Ему не нужно нравиться пользователям. Вместо этого он должен быть разработан (также зачастую собственными силами компании и с помощью различных языков) так, чтобы качественно выполнять следующее:
Обрабатывать сформированные фронтэндом (то есть сгенерированные машинной, а не человеком) запросы. Бэкэнд и фронтенд обмениваются данными с помощью специальных протоколов, выбираемых разработчиками; часто применяются различные производные от HTTP (например, протоколы WebSocket, SOAP, а также протоколы в рамках стиля REST).
Отправлять запросы в БД для чтения-записи необходимой информации
Делать всё остальное на основе запросов пользователей: выполнять сравнения и расчеты, анализировать логические условия, составлять отчеты, и многое другое.
3. *Нижний уровень - всё тот же Data tier*, как и в случае 2-звенных приложений. Нет необходимости в реализации своих средств управления базами данных, поскольку можно с успехом использовать хорошо известные существующие решения, такие как MySQL, PostgreSQL, Oracle, MS SQL и т. д.

По сравнению с 2-звенными приложениями, эта архитектура предоставляет следующие преимущества:
* Поддержка "тонких клиентов", как следствие - проще поддерживать весь спектр клиентских устройств 
* Более простая поддержка серверных частей приложения. Когда нужно лишь немного поправить интерфейс пользователя, то это не затрагивает остальные компоненты. Вспомните стек протоколов TCP/IP, где на каждом уровне можно заменить протокол, не меняя (или минимально корректируя) настоящий и нижележащий уровни. В этом случае то же самое: когда нужно полностью перепроектировать интерфейс пользователя или даже переписать на другом языке программирования, на другие компоненты это не влияет.
* Большая масштабируемость. По мере роста компании можно добавлять новые серверы на каждом звене, особенно когда применяется балансировка нагрузки.
* Большая защищенность. Фронтэнд-компоненты могут дополнительно фильтровать данные от пользователя, не пропуская SQL-инъекции и прочие злонамеренные действия.

Следующие приложения можно назвать 3-звенными:
* Многое ПО для e-commerce, включая банковские веб-приложения. 

### Возможные проблемы

С точки зрения поиска и устранения неисправностей разница между дву- и трёхзвенными приложениями намного меньше по сравнению с разницей между самостоятельными и двухзвенными. Более того, дву- и трёхзвенные приложения выглядят практически одинаково.

## Принципы локализации дефектов

**Первопричина (Root cause)** - точная причина, которая привела к возникновению ошибки. Точное определение первопричины — непростая задача, поскольку она может считаться выполненной, только когда дефект полностью исправлен. Если дефект больше не проявляется, значит, первопричина определена верно. Поэтому в большинстве случаев у тестировщика нет возможности найти первопричину, и вместо этого выполняется локализация дефекта.

**Локализация (Localization)** - процесс поиска возможной первопричины. Верно выполненная локализация кардинально сокращает время, затрачиваемое на устранение дефекта, поскольку: а) устранение дефекта поручается именно той команде разработчиков, которая и должна заниматься этим типом дефектов; б) команда получает нужную информацию и поэтому знает, что нужно сделать. Поэтому локализацию необходимо проводить при каждом обнаружении дефекта, иначе дефекты, проявляющиеся в интерфейсе пользователя, всегда будут назначаться команде разработчиков этого интерфейса, даже если причина находится в некорректной реализации бэкенда, а это, в свою очередь, приводит к дополнительной нагрузке на разработчиков, возможному «отфутболиванию» дефектов и, как результат, напряжённым отношениям между командами.

**Поиск неисправностей  (Troubleshooting)** - конкретные методики локализации дефектов.

### Алгоритм локализации дефектов

1. Декомпозируйте приложения на самые маленькие кусочки, какие только возможно.
2. Предложите гипотезы о первопричинах для каждого кусочка: "Что могло пойти не так и почему?"
3. Подберите надлежащие инструменты и методики для проверки каждой гипотезы.
4. Примените эти инструменты для каждой гипотезы, чтобы отклонить или подтвердить ее. Подтверждённые гипотезы показывают возможные первопричины. Таким образом, локализация будет выполнена успешно.

#### Декомпозиция

Если приложение представлено в виде чёрного ящика, то системный подход к локализации дефектов почти невозможен. Приложение можно исследовать только случайным образом с помощью перечисления множества идей, которые не применимы в полной мере к этому случаю.

Разберем случай, когда приложение-клиент пытается получить доступ к файлу, который хранится на файловом сервере, но что-то идёт не так и получить файл не удаётся. 

Для начала, любое клиент-серверное приложение можно разделить на три крупных компонента:
* Узел клиента
* Узел сервера
* Сеть между ними

После этого мы можем декомпозировать каждый крупный компонент на более мелкие части. Каждая из частей может либо сама работать некорректно, указывая на присутствие дефекта, либо дать нам подсказку (как журналы, например), где может скрываться неполадка. Продолжайте декомпозицию, пока не будут выявлены все важные части программного обеспечения.

Итак, что и кто может помочь нам в декомпозиции (в порядке убывания):
1. Документация продукта.
2. Если документация отсутствует или устарела, то следует обратиться к аналитикам, разработчикам, DevOps-инженерам, администраторам и другим лицам, хорошо знающим ПО.
3. Если они недоступны (на больничном, разные часовые пояса, сильная занятость, не позволяющая помочь в текущий момент): общий здравый смысл, ваши технические навыки и опыт.

*Компонент сети* можно разделить на несколько следующих частей:
* Сегмент на стороне клиента, в т.ч. интернет-провайдер.
* Сегмент на стороне сервера, в т.ч. каким образом сервер подключён к Интернету.
* Промежуточный сегмент - сеть между клиентом и сервером

#### Гипотезы

**Гипотезы для стороны клиента**

Давайте представим, что были сделаны следующие гипотезы (они выделены подчёркиванием):

* Какие события зафиксированы в журналах приложения?  
Это общий вопрос, но чрезвычайно полезно проверить его в первую очередь.
* Что делают пользователи? Может, они отправили неверный или неподдерживаемый запрос.
* Какое клиентское ПО используется? Оно может быть неподдерживаемым.
* Как сконфигурировано клиентское ПО? Его настройки могут конфликтовать с серверным приложением (например, это может случиться, если версии протокола прикладного уровня или режимы шифрования на стороне сервера и на стороне клиента не совпадают).
* Какая используется операционная система на стороне клиента? Она также может оказаться неподдерживаемой.
* Какая учётная запись пользователя используется для подключения? Может быть, что-то не так с этой учётной записью, например пароль с истёкшим сроком действия или недостаточно прав для доступа к этому файлу.
* Что насчёт свободного дискового пространства?  
Может быть, файл слишком большой для сохранения, и клиентское ПО не может записать его на диск или даже не пытается скачать его.
* Может быть, какое-либо системное ПО препятствует этой операции? Нередко ПО, предназначенное для защиты, например антивирус, блокирует обычные операции.
* Узел клиента перегружен. В некоторых случаях проблемы, связанные с производительностью, могут нарушить работу ПО такими образом, что это будет выглядеть как сбой самого приложения (например, когда соединения закрываются по истечении времени ожидания из-за перегрузки одной из сторон).

**Гипотезы для сети**

* Сервер недостижим со стороны клиента, хотя обе стороны подключены к сети.
* FQDN (доменное имя) сервера некорректно преобразуется в IP-адрес.
* Серверное приложение скрыто за межсетевым экраном.
* На стороне узла клиента и (или) узла сервера возникли проблемы с сетевыми интерфейсами (неподсоединённые кабели, слишком слабый сигнал Wi-Fi, неисправные устройства, сбой драйверов).
* Узел клиента и (или) узел сервера отключены от Интернета из-за неоплаты.
* Интернет-провайдер клиента, или сервера, или единственный связывающий элемент между ними потеряли соединение из-за обрыва кабеля или другой аварийной ситуации.
* В случае доступности серверного ПО, но при слишком медленной реакции или низкой скорости передачи: некий сегмент сети перегружен.

**Гипотезы для стороны сервера**

* Сам сервер как узел целиком (физический, виртуальный - неважно) мог выключиться из-за нарушения питания.
* Серверное ПО остановлено по какой-либо причине, например некорректного автоматического обновления, неожиданной перезагрузки сервера или ошибочного вмешательства системных администраторов.
* Серверное ПО попыталось запуститься, но потерпело неудачу из-за проблем с окружением, например следующих:
	* Конфликты, связанные с портами, когда кто-то другой уже занял нужный порт.
	* Временные файлы (особенно так называемые файлы блокировки) препятствуют запуску.
	* Другие проблемы, связанные, возможно, с нештатным завершением работы приложения.
* Серверное ПО работает нормально, но его настройки не позволяют этому пользователю получить доступ к запрашиваемому файлу.
* Серверное ПО работает нормально, но не может получить доступ к запрашиваемому файлу из-за некорректно настроенных прав доступа к файлу, например, когда чтение разрешено только пользователю root, а другим пользователям операционной системы запрещено.
* Некоторое ПО, обеспечивающее безопасность, которое установлено на сервере, нарушает нормальную работу.
* Запрашиваемый файл отсутствует, но либо клиентское, либо серверное ПО не может обработать эту ситуацию и не сообщает об этом пользователю.

#### Инструменты и методики

**Проверки стороны клиента**

* Какие события зафиксированы в журналах приложения?  
Это общий вопрос, но чрезвычайно полезно проверить его первым делом.
* Может, пользователь отправил неверный или неподдерживаемый запрос.
	* Изучите описание дефекта.
	* Спросите пользователя, что именно было сделано.
	* Изучите журналы приложения, если они достаточно подробны.
	* Выполните сбор сетевого трафика, чтобы изучить запросы и ответы.
* Какое клиентское ПО используется? Оно может быть неподдерживаемым.  
Определите точную версию клиентского ПО и сравните её с описанным в документации продукта.
* Настройки клиента могут конфликтовать с серверным приложением.
	* Изучите настройки клиентского приложения и сравните их с настройками сервера.
	* Если они недоступны, попытайтесь выполнить сбор сетевых пакетов и поискать конфликты, связанные с протоколами прикладного уровня.
* Какая операционная система используется на стороне клиента? Она также может оказаться неподдерживаемой.
	* То же, что и пункт выше.
* Какая учётная запись пользователя используется для подключения? Может быть, что-то не так с этой учётной записью, например пароль с истёкшим сроком действия или недостаточно прав для доступа к этому файлу.
	* Узнайте имя пользователя и (если возможно) пароль.
	* Если это возможно, проверьте их корректность на стороне сервера или выясните другими способами, была ли попытка входа в систему успешна.
	* Если это возможно, проверьте права доступа, назначенные этой учётной записи, на стороне сервера.
* Что насчёт свободного дискового пространства? Может быть, файл слишком большой для сохранения, и клиентское ПО не может записать его на диск или даже не пытается скачать его.
	* Проверьте наличие свободного дискового пространства на стороне клиента: команда df на ОС Linux и macOS, и проводник в ОС Windows.
* Может быть, какое-либо системное ПО препятствует этой операции?  
Нередко ПО, предназначенное для защиты, например антивирус, блокирует обычные операции.
	* Получите список приложений, установленных на компьютере клиента.
* Узел клиента перегружен. Далее мы не будем рассматривать это предположение, поскольку наша проблема не выглядит как связанная с производительностью (так как запрашиваемый файл вообще не получается извлечь ни с какой скоростью). В некоторых случаях проблемы, связанные с производительностью, могут нарушить работу ПО такими образом, что это будет выглядеть как сбой самого приложения (например, когда соединения закрываются по истечении времени ожидания из-за перегрузки одной из сторон), но мы оставим такие ситуации за рамками нашего примера.
	* Измерьте загрузку системы (процессор, оперативная память, система ввода-вывода), используя программы top и iostat.
	
**Проверки сети**

* FQDN сервера преобразовано некорректно:
	* Используйте программы dig, host или nslookup (в зависимости от ОС клиента) для преобразования доменного имени в IP-адрес.
	* Если «резолверы» DNS недоступны, проверьте настройки системы DNS у клиента.
	* Если некоторые «резолверы» DNS присутствуют в настройках, но не отвечают, то запустите «traceroute -U -p 53» и (или) «nmap -sU -p53», чтобы проверить их доступность и возможное присутствие межсетевого экрана. Если построение маршрута прерывается до сервера назначения, это может означать слишком строгие правила межсетевого экрана, препятствующие доступу клиента к «резолверу» DNS.
* Сервер недостижим со стороны клиента, хотя обе стороны находятся в сети:
	* Этот шаг можно полностью пропустить в пользу следующего пункта — «Серверное приложение скрыто за межсетевым экраном».
	* Самый быстрый способ проверки — программа ping, но она может ничего не показать, если протокол ICMP запрещён межсетевым экраном.
	* Второй способ: программа traceroute, которая может показать возможные проблемы с маршрутизацией, например проблемы с домашним маршрутизатором или провайдером.
* Серверное приложение скрыто за межсетевым экраном — можно применить несколько инструментов:
	* Для приложений, использующих протокол TCP: nc -vz адрес_сервера номер_порта, или nmap, или traceroute.
	* Для приложений, использующих протокол UDP: nmap или traceroute.
	* В случае блокировки межсетевым экраном на основе страны: попытайтесь получить доступ к серверу из другой страны с помощью сервиса VPN.
* На стороне узла клиента и (или) узла сервера возникли проблемы с сетевыми интерфейсами (неподсоединённые кабели, слишком слабый сигнал Wi-Fi, неисправные устройства, сбой драйверов):
	* С помощью программы ping проверьте доступность соседей по сети, например шлюза, используемого по умолчанию.
	* Проверьте сигнал (для проводного или беспроводного канала, в зависимости от используемой технологии).
* Узел клиента и (или) узел сервера отключены от Интернета из-за неоплаты:
	* Проверьте доступность общеизвестного ресурса в Интернете, такого как сервер 8.8.8.8.
	* Проверьте остаток средств на счету.
* Интернет-провайдер клиента, провайдер сервера или единственный связывающий элемент между ними потеряли соединение из-за обрыва кабели или другой аварийной ситуации:
	* Это можно проверить аналогично п. 3, показанному выше, используя программу traceroute.
	* Также может помочь смена интернет-провайдера, например с помощью переключения с домашнего Интернета на мобильный.
* В случае доступности серверного ПО, но при слишком медленной реакции или низкой скорости передачи: некий сегмент сети перегружен.  Мы не будем далее рассматривать эту ситуацию, поскольку наша проблема не выглядит, как связанная с производительностью, так как запрашиваемый файл вообще не получается извлечь ни с какой скоростью:
	* `iptraf-ng` — чтобы определить уровень использования пропускной способности.

**Проверки со стороны сервера**

В случае с многозвенными приложениями каждый компонент можно рассмотреть, как самостоятельное приложение. 

* Весь сервер может выключиться, например, из-за нарушения питания:
	* Для физических серверов: проверьте состояние аппаратного обеспечения, подаётся ли на него питание.
	* Для виртуальных серверов: проверьте состояние соответствующего физического сервера, гипервизора и виртуальной машины.
* Серверное приложение остановлено по каким-либо причинам:
	* Проверьте состояние приложения: команды ps или systemctl.
	* Некорректное автоматическое обновление: изучите файлы журналов приложения.
	* Неожиданная перезагрузка сервера: изучите файлы журналов операционной системы (команды `upitme`, `last` и `dmesg`, соответствующие файлы в каталоге /var/log).
	* Ошибочное вмешательство системных администраторов. Проверьте файлы журналов как операционной системы, так и приложения.
* Серверное ПО попыталось запуститься, но потерпело неудачу из-за конфликтов, связанных с портами, когда кто-то другой уже занял нужный порт:
	* Проверить журналы серверного ПО
	* Программа ss или netstat для проверки состояния портов сервера.
* Сервер работает нормально, но его настройки не позволяют этому пользователю получить доступ к запрашиваемому файлу.
	* Сравните настройки сервера с действиями пользователя.
* Сервер работает нормально, но не может получить доступ к запрашиваемому файлу из-за некорректно настроенных права доступа к файлу, например когда чтение разрешено только пользователю root, а другим пользователям операционной системы запрещено.
	* Проверьте права доступа к запрашиваемому файлу. Может ли серверное приложение прочитать его?
* Некоторое ПО, обеспечивающее безопасность, которое установлено на сервере, нарушает нормальную работу:
	* Получите список дополнительного ПО в системе (например, антивирусов) и проанализируйте их возможное влияние на рассматриваемую операцию.
* Запрашиваемый файл отсутствует, но либо клиентское, либо серверное ПО не может обработать эту ситуацию и не сообщает об этом пользователю:
	* Проверьте существование файла на сервере.

### Поиск неисправностей на практике

Первая подтверждённая гипотезы не всегда ведёт к первопричине. При некоторых обстоятельствах, например если у вас есть время, или если критичность дефекта очень высокая (и поэтому ему необходимо особое внимание), есть смысл проверить все выявленные гипотезы.

**Методы оптимизации**:
|Подход|Условия применения|Польза|
|-|-|-|
|Сначала самые простые: Все применимые проверки располагаются от самых простых (например, журналы) до самых сложных (например, анализаторы сетевых пакетов), а затем выполняются в этом порядке|У вас есть достаточный опыт в применении нужных инструментов и методик, чтобы заранее оценить их сложность|Потенциальная экономия времени.  Метод может быть полезен, если продвинутые способы проверки или инструменты недоступны. Этот метод проще других объяснить лицам, не связанным с IT|
|Сначала самые вероятные: Расположите предположения так, чтобы вначале шли наиболее вероятные предположения, а затем проверьте их в этом порядке|Вы хорошо знакомы с этим приложением или у вас есть достаточный опыт с аналогичными приложениями|Потенциальная экономия большого количества времени; методика также может быть полезна, если некоторые проверки недоступны|
|Сверху вниз: «Классический» алгоритм, описанный в предыдущем разделе. Все проверки проводятся, начиная со стороны клиента, шаг за шагом продвигаясь по направлению к внутренним элементам сервера|Вы не знакомы ни с приложением, ни с подходящими инструментами проверки|В любом случае это НАМНОГО лучше хаотичного перебора проверок. Кроме того, углублённые проверки (например, для внутренних элементов бэкенда) не всегда доступны, в таком случае их явно стоит отложить.|





