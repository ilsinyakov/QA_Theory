# CI / CD

- [Основные понятия](#основные-понятия)
- [Функции CI / CD](#функции-ci--cd)
- [Как работает CI/CD](#как-работает-cicd)
  - [Jenkins](#jenkins)
    - [Установка плагинов](#установка-плагинов)
    - [Добавление SSH-ключей в Credentials](#добавление-ssh-ключей-в-credentials)
    - [Создание пайплайна](#создание-пайплайна)
    - [Настройка WebHook в репозитории](#настройка-webhook-в-репозитории)
  - [GitLab CI](#gitlab-ci)
    - [Структура GitLab CI](#структура-gitlab-ci)
    - [Встроенные переменные и секреты](#встроенные-переменные-и-секреты)
    - [Артефакты и кэширование](#артефакты-и-кэширование)
    - [`.gitlab-ci.yml`](#gitlab-ciyml)

## Основные понятия

**CI/CD** — это способ разработки, в котором тестирование и развёртывание кода происходит автоматически. Основная цель — ускорить выпуск обновлений и повысить качество ПО за счёт регулярного тестирования.

**Continuous Integration (CI, непрерывная интеграция)** — автоматическая интеграция кода в репозиторий проекта. Цель CI — упростить объединение кода от разных разработчиков и быстро выявлять ошибки. Когда программист отправляет код в репозиторий, система запускает тесты. Если в проекте найдутся ошибки, то разработчику придётся забрать код на доработку.

**Continuous Delivery (CD, непрерывная доставка)** — это автоматическая подготовка кода к выпуску. Представьте команду, которая разрабатывает веб-приложение. При каждом изменении кода CD-система автоматически тестирует работоспособность, собирает нужные файлы и разворачивает приложение в тестовой среде. Когда менеджер проекта принимает решение о выпуске новой версии, он активирует публикацию одним нажатием — и подготовленный код разворачивается на рабочем сервере.

**Continuous Deployment (CD, непрерывное развёртывание)** — автоматическая доставка кода пользователям без участия разработчиков. Каждое изменение в коде, прошедшее тесты, сразу уходит на основной сервер.

![CI/CD](https://github.com/ilsinyakov/QA_Theory/blob/main/Pictures/cicd.png?raw=true)

Непрерывная интеграция в CI/CD — ***обязательный*** этап, а доставка и развёртывание — ***опциональные***. Доставка подходит командам, которые хотят контролировать, когда и какие обновления будут получать пользователи, а развёртывание — тем, кому важно, чтобы изменения моментально появлялись на продакшене.

## Функции CI / CD

Основные функции CI:

- **Статический анализ**. Линтеры для разных языков программирования анализируют код, проверяют синтаксис, стиль и ищут ошибки. Это позволяет ещё до запуска программы найти проблемы с производительностью и отправить код на доработку.
- **Тестирование кода**. На этом этапе система проверяет, не ломает ли обновление уже те функции, которые есть в программе, и насколько новый код работоспособен. Если автоматические тесты выявляют ошибку, то обновление возвращают программистам на доработку.
- **Проверка качества**. В каждой команде используют свои архитектурные решения, стандарты безопасности и требования к оформлению кода. На этом этапе проверяют, соблюдаются ли все эти правила.

Основные функции CD:

- **Сборка кода**. Проект обычно представляет собой набор файлов с кодом, которые надо связать между собой, создать исполняемый файл, упаковать всё в Docker-контейнер или архив.
- **Публикация релиза**. Собранный проект надо доставить пользователям в виде обновления или загрузить на сервер, откуда его можно будет скачать.
- **Управление сертификатами**. Разработчики используют множество сертификатов шифрования, которые обеспечивают безопасное взаимодействие приложения с сервером. Процесс обновления сертификатов автоматизируют, чтобы не забывать делать это вручную.

## Как работает CI/CD

### Jenkins

#### Установка плагинов

- **Git Plugin**. Позволяет Jenkins’у работать с Git-репозиториями.
- **GitHub Plugin / GitHub Integration Plugin**. Обеспечивает интеграцию с GitHub и позволяет принимать уведомления от GitHub.

#### Добавление SSH-ключей в Credentials

- Настройка_Jenkins / Security / Credentials / System / Global_credentials
- Жмем *Add Credentials*
- В поле *Kind* выберите *SSH Username with private key*
- Заполняем поля:
  - *Scope*: обычно оставляют *Global*
  - *Username*: имя пользователя на вашем удалённом сервере
  - *Private Key*: если у вас уже готов открытый/закрытый ключ, выберите Enter directly и вставьте содержимое вашего приватного ключа
  - *ID* (необязательно): по умолчанию Jenkins присвоит автоматически UUID, но вы можете явно прописать, например, REMOTE_SSH_CRED
  - *Description* - описание
- *ОК*

#### Создание пайплайна

- Создаем `Item` типа `Pipeline`
- В настройках в Triggers ставим галочку: *GitHub hook trigger for GITScm polling* - чтобы Jenkins слушал события на эндпоинте github-webhook

#### Настройка WebHook в репозитории

- В репозитории GitHub → Settings → Webhooks → Add webhook
- *Payload URL*:  
`https://<JENKINS_URL>/github-webhook/`
- *Content type*:  
`application/json`
- *Which events*: выберите Just the push event
- *Add webhook*

### GitLab CI

**GitLab CI** — это встроенная и неотъемлемая часть GitLab как DevOps-платформы.

В GitLab нет разделения на условный «GitLab» и «GitLab CI» — это один цельный продукт. CI/CD здесь изначально задуман как базовая функциональность, а не как дополнительный модуль.

#### Структура GitLab CI

Схематично это выглядит так:

```text
Pipeline (весь процесс)
├── Stage: Test
│   ├── Job: unit-tests
│   ├── Job: integration-tests
│   └── Job: lint
├── Stage: Build
│   ├── Job: compile
│   └── Job: package
└── Stage: Deploy
    └── Job: deploy-to-production
```

**Jobs** внутри одного stage выполняются **параллельно** (если хватает runner’ов и ресурсов).  
**Stages** же выполняются **последовательно** — следующий stage не начнётся, пока полностью не завершится предыдущий.

Если хотя бы один job внутри stage завершится с ошибкой, следующий stage не запустится, если только для этого job’а явно не указано `allow_failure: true`.

#### Встроенные переменные и секреты

GitLab предоставляет большой набор встроенных CI-переменных, которые автоматически доступны в каждом job’е: `CI_COMMIT_SHA`, `CI_PROJECT_ID`, `CI_PIPELINE_ID`, `CI_MERGE_REQUEST_ID` и многие другие.

Их действительно много, и в ряде случаев они покрывают большинство типовых сценариев без необходимости что-либо настраивать вручную.

Для секретов и чувствительных данных используется раздел
**Settings** → **CI/CD** → **Variables** в интерфейсе GitLab.

Там вы можете:

- Создавать переменные окружения.
- Помечать их как `protected` (доступны только для protected-веток и тегов).
- Помечать как `masked` (значения не выводятся в логах).

Это стандартный и безопасный способ хранения токенов, ключей и паролей.

#### Артефакты и кэширование

GitLab чётко разделяет два понятия: артефакты и кэш — и это одно из его сильных мест.

**Артефакты** — это результаты работы job’ов, которые нужны дальше: собранные бинарники, отчёты, файлы сборки. Они сохраняются в GitLab и доступны через UI или для последующих job’ов.

**Кэш** — это временные данные для ускорения повторных запусков (например, зависимости). Кэш обычно хранится на стороне runner’а и не считается результатом сборки.

Такое разделение снижает путаницу и делает пайплайны более прозрачными: вы точно понимаете, какие файлы являются результатом работы, а какие — всего лишь оптимизацией.

#### `.gitlab-ci.yml`

Вся конфигурация CI/CD по умолчанию описывается в одном файле — .gitlab-ci.yml, который лежит в корне репозитория.

Это единственный обязательный файл, в котором описывается вся логика CI/CD для проекта.

Никаких дополнительных «включений» CI/CD делать не нужно — если файл существует, CI считается активным.

Пример:

```yaml
stages:
  - hello

hello_world:
  stage: hello
  tags:
    - shell-185
  script:
    - echo "Hello from GitLab CI!"
```

- `stages` — список этапов пайплайна. Даже если этап всего один, его всё равно нужно объявить явно.
- `hello_world` — имя job’а (может быть любым).
- `stage: hello` — указывает, к какому stage относится job.
- `tags` — критически важный момент: job будет выполнен только тем runner’ом, у которого есть все указанные tags. Если ни один runner не подходит — job зависнет в статусе pending.
- `script` — набор команд, которые будут выполнены runner’ом. В данном случае — обычный `echo`.

**Синтаксис**:

- Отступы имеют значение. Используются только пробелы, табуляции недопустимы.
- После двоеточия всегда идёт пробел — это обязательное требование синтаксиса.

Пример:

```yaml
# 1. Глобальные переменные (опционально)
variables:
  LOG_LEVEL: info

# 2. Условия запуска всего pipeline (опционально)
workflow:
  rules:
    - if: '$CI_PIPELINE_SOURCE  "merge_request_event"'
    - if: '$CI_COMMIT_BRANCH  "main"'

# 3. Этапы pipeline (почти всегда используется)
stages:
  - build
  - test
  - deploy

# 4. Значения по умолчанию для всех jobs (опционально)
default:
  image: python:3.9
  timeout: 1h

# 5. Сами job'ы (обязательно)
test_job:
  stage: test
  script:
    - echo "Testing... Log level is $LOG_LEVEL"

build_job:
  stage: build
  script:
    - echo "Building..."

deploy_job:
  stage: deploy
  script:
    - echo "Deploying..."
```

- `variables` — глобальные переменные окружения, доступные во всех job’ах.
- `workflow` — правила, определяющие, когда вообще создаётся pipeline.
- `stages` — последовательность этапов выполнения.
- `default` — значения по умолчанию для всех job’ов (чтобы не дублировать одно и то же).
- job’ы — конкретные задачи, которые выполняет CI/CD.

Пример:

```yaml
# Глобальные переменные
variables:
  DOCKER_IMAGE: "myapp:latest"
  CACHE_DIR: ".cache"

# Условия запуска pipeline
workflow:
  rules:
    - if: '$CI_PIPELINE_SOURCE  "merge_request_event"'
    - if: '$CI_COMMIT_BRANCH  "main"'
    - if: '$CI_COMMIT_TAG'

# Этапы pipeline
stages:
  - build
  - test
  - deploy

# Значения по умолчанию
default:
  image: python:3.11
  timeout: 1h
  cache:
    key: "$CI_COMMIT_REF_SLUG"
    paths:
      - .cache/pip

# Job'ы
install_dependencies:
  stage: build
  script:
    - pip install -r requirements.txt
  artifacts:
    paths:
      - .venv/
    expire_in: 1 day

run_tests:
  stage: test
  script:
    - pip install -r requirements.txt
    - pytest tests/
  needs:
    - install_dependencies

run_linter:
  stage: test
  script:
    - pip install -r requirements.txt
    - pylint src/
  needs:
    - install_dependencies

deploy_to_production:
  stage: deploy
  image: alpine:latest
  script:
    - echo "Deploying to production..."
    - ./scripts/deploy.sh
  only:
    - main
  when: manual  # Запускается вручную
```

1. Stage build — запускается job install_dependencies. Он устанавливает зависимости и сохраняет их как артефакты, чтобы следующие job’ы могли их использовать.
2. Stage test — job’ы run_tests и run_linter запускаются параллельно. Оба зависят от install_dependencies (needs), поэтому стартуют сразу после него и получают доступ к его артефактам.
3. Stage deploy — после успешного завершения test становится доступен job deploy_to_production. Он:
   - Выполняется только для ветки main.
   - Не запускается автоматически, а требует ручного подтверждения (when: manual).
