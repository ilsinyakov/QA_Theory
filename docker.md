# Docker

## Content

## О контейнеризации

Контейнеризация - важная особенность современных операционных систем, позволяющая создавать изолированные среды внутри одного сервера. 

В случае Linux контейнеры основаны на технологии "cgroups" (control groups) и работают следующим образом: специальная программа запускает новый изолированный процесс внутри существующего дерева процессов и вызывает из него прикладные процессы.

Приложения внутри контейнеров имеют общий доступ к ресурсам с родительской операционной системой (он может быть ограничен настройками контейнера), но не имеют доступа к ресурсам вне контейнера (например, они не могут читать данные вне каталогов, которые были привязаны к контейнеру, и не имеют доступа к памяти приложений родительской операционной системы).

Существует несколько типов контейнеров для Linux, но наиболее распространенным из них является Docker. Основные возможности контейнеров Docker:
* В отличие от виртуализации контейнерам не требуются дополнительные ресурсы для запуска полной копии операционной системы - ведь контейнеры используют ядро родительской ОС.
* В отличие от виртуализации, не нужно резервировать дополнительные ресурсы, которые могут быть не использованы. Это позволяет сэкономить большое количество вычислительных ресурсов.
* Обычно в один контейнер входит только одно приложение. Например, если в вашем проекте есть frontend и backend, то лучше поместить их в отдельные контейнеры.
* Контейнеры запускаются со специальных образов дисков, которые обычно предварительно сконфигурированы, поэтому для получения рабочей копии приложения достаточно запустить его.
* Обычно контейнеры Docker имеют короткий жизненный цикл: их можно приостановить и удалить, когда они становятся ненужными, а затем снова запустить из образа. Такой подход называется "stateless", и именно поэтому не следует хранить в контейнерах критически важные данные.

## Как работает Doker

Существуют три основных компонента контейнеризации Docker:
1. **Ядро Linux** с включенной поддержкой cgroups, поставляемое по умолчанию со всеми современными дистрибутивами Linux.
2. **Containerd** - специальный сервис Linux, управляющий контейнерами Docker.
3. **Docker-CLI** (интерфейс командной строки) - специальный инструмент, передающий команды пользователя из терминала в Containerd.

Перед началом работы необходимо ознакомиться с терминологией Docker:
* **Образ (Image)**: специальный архивный файл, содержащий все дисковые данные будущих контейнеров.
* **Тег (Tag)**: специальная метка, указывающая на какой-либо параметр образа (например, версию). По умолчанию используется метка "latest", означающая последнюю версию.
* **Реестр (Registry)**: специальный удаленный сервер, на котором хранятся образы Docker.
* **Контейнер (Container)**: копия исполняемого или готового образа.

`sudo docker images` - получить список локальных образов

`sudo docker pull busybox` - получить образ из удаленного реестра

`sudo docker inspect busybox` - информация об образе

`sudo docker run --name exampleuser-2 busybox` - запустить контейнер  
`--name` - имя контейнера

`sudo docker ps` - активные контейнеры  
`-a` - все запуски

`sudo docker run --name testuser-3 -d busybox sleep 600`  
`-d` - отсоединить контейнер от терминала  
`sleep 600` - команда выполняемая в контейнере после запуска

`sudo docker exec -it testuser-3 /bin/sh` - запустить процесс терминала внутри контейнера  
`it` - интерактивный режим

`sudo docker start testuser-3` - повтороный запуск ранее запущенного контейнера

`sudo docker stop exampleuser-4` - остановить контейнер

## Работа по сети

По умолчанию Docker использует мосты и NAT для соединения контейнеров с внешней сетью. 

NAT - это механизм, позволяющий пересылать пакеты одного хоста через другой. И да, в данном случае родительский хост работает как шлюз для контейнеров Docker. Еще один важный момент в сетевом взаимодействии между контейнерами и родительским хостом - мосты, позволяющие соединить несколько интерфейсов в один. В случае Docker все интерфейсы контейнеров (с именем "veth..." на родительском хосте) объединяются в мост, который обычно называется "docker0".

`sudo docker run --name exampleuser-5 -d -P nginx`    
`P` - опубликовать все открытые порты контейнера

`sudo docker port exampleuser-5` - получить сопоставление внутреннего и внешнего портов

## Расширенные функции

**Торт**

Самый простой аналог дисковой системы Docker - это торт из нескольких слоев. Процесс сборки образа Docker всегда делится на шаги (один или несколько), где каждый шаг является результатом некоторой операции: например, копирования файлов (или каталогов) в образ или выполнения некоторых команд.

Результатом каждого шага является слой файловой системы. Порядок шагов очень важен, так как каждый следующий слой монтируется поверх предыдущего и может заменять данные из него. Готовый образ состоит из одного или нескольких слоев. 

Например, можно прокрутить страницу до момента извлечения образа nginx и увидеть несколько строк "Pull complete" - каждая строка является результатом извлечения одного слоя образа, поэтому образ nginx состоит из шести слоев. Другой способ узнать количество слоев - найти раздел "RootFS" в выводе команды `docker image inspect`.

Далее, при запуске контейнера Docker, containerd монтирует все слои выбранного образа один поверх другого с помощью специального драйвера файловой системы "overlay", а затем монтирует последний слой, который является хранилищем данных контейнера. Все слои образа монтируются в режиме "только чтение", но слой данных контейнера монтируется в режиме "чтение-запись", поэтому вы можете записывать новые данные или модифицировать существующие файлы: все изменения будут записаны в последний слой без модификации нижних слоев.

![Docker Layer](https://github.com/ilsinyakov/QA_Theory/blob/main/Pictures/docker_layer.jpg)

Кроме того, существует еще одна возможность поместить что-либо внутрь контейнера: смонтировать его с помощью флага `-v local_path:container_path`, передаваемого команде `docker run`. Этот флаг обычно используется для размещения внутри контейнера каких-либо важных данных (например, каталога данных приложения).

## Создание собственного образа

Для этого необходимо написать специальный файл с именем "Dockerfile", который будет описывать наш образ. Познакомимся с некоторыми полезными операторами этого файла:

* `FROM <имя_образа>` . Если вы хотите использовать другой образ в качестве базового - это можно сделать с помощью этого оператора. Например, можно использовать образ "debian", если вы хотите получить полный набор инструментов Debian, или "nginx", если вам нужен nginx в вашем образе. Этот оператор можно использовать несколько раз.
* `RUN <команда>`. Если вам необходимо изменить внутреннее устройство образа путём выполнения некоторой команды - вы можете сделать это с помощью данного оператора.
* `COPY <src> <dst>`. Позволяет копировать в образ файлы и каталоги из локальной файловой системы. Путь к источнику должен относиться к текущему каталогу, использовать абсолютный путь здесь нельзя.
* `ADD <src> <dst>`. Этот оператор очень похож на COPY, но добавляет некоторую магию: например, с помощью ADD можно использовать URL в качестве источника или он автоматически извлечет tar-архив, если вы поместите его в качестве источника.
* `WORKDIR <path>`. Поможет, если необходимо изменить удаленный текущий каталог в процессе сборки образа (например, для выполнения команд или использования "." в качестве пути назначения).
* `EXPOSE <port/protocol>`. Если необходимо сделать некоторые порты доступными снаружи образа - это можно сделать с помощью EXPOSE.

В одном из предыдущих примеров мы практиковались с образом nginx. Теперь создадим на его основе образ со статической веб-страницей. Сначала создайте каталог "docker_image" внутри домашнего каталога, войдите в него и запишите какой-нибудь текст в файл "<ваше_имя_пользователя>.html" (при желании можно использовать там HTML-теги).

Далее создайте Dockerfile со следующим содержимым (замените шаблоны на свои):

```
FROM nginx
WORKDIR /usr/share/nginx/html/
COPY <your_username>.html .
RUN echo “Hello, world!” > index.html
```

Здесь мы выполним следующие действия:

1. Возьмем за основу образ "nginx".
2. Сменим текущий каталог на /usr/share/nginx/html/ (каталог данных из конфигурационного файла nginx).
3. Скопируем <your_username>.html в /usr/share/nginx/html/<your_username>.html
4. Напишем “Hello, world!” to the /usr/share/nginx/html/index.html с помощью команды "echo".

`sudo docker build -t exampleuser .` - собрать образ

Проверить работу:
```
$ docker port exampleuser-7
80/tcp -> 0.0.0.0:32770
80/tcp -> [::]:32770
$ curl localhost:32770
“Hello, world!”
$ curl localhost:32770/exampleuser.html
Your text here
```

Можно получить доступ к поднятому сайту по внешнему IP и порту докера.  
http://78.245.93.245:32769/







