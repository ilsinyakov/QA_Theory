# Архитектура программного обеспечения

## Содержание

## Основные понятия

**Архитектура системы** - общий план проектируемого или действующего программного обеспечения, упрощенное представление, в котором определяются основные части программы, и как они будут взаимодействовать или взаимодействуют друг с другом и с внешним миром. 

**Архитектура ПО (разработка архитектуры ПО)** - это искусство и наука строить и проектировать программное обеспечение таким образом, чтобы оно удовлетворяло всем заявленным к нему требованиям, а также обеспечивало максимальную простоту доработки, развертывания и масштабирования приложения.

## Многослойная архитектура (монолит)

Этот подход работает по принципу разделения ответственностей. ПО разделено на слои, лежащие друг на друге, и каждый из них выполняет определенную обязанность.

Архитектура делит ПО на следующие слои:

* **Слой представления** (Presentation Layer) содержит пользовательский интерфейс и отвечает за обеспечение хорошего пользовательского опыта.
* **Слой бизнес-логики** (Business Logic Layer), как следует из названия, содержит бизнес-логику приложения. Он отделяет UI/UX от вычислений, связанных с бизнесом. Это позволяет с легкостью изменять логику в зависимости от постоянно меняющихся бизнес-требований, никак не влияя на другие слои.
* **Слой передачи данных** (Data Link Layer) отвечает за взаимодействие с постоянными хранилищами, такими как базы данных, и прочую обработку информации, которая не связана с бизнесом.

Данные и элементы управления проходят через каждый слой и передаются от одного к другому. Эта система также повышает уровень абстракции и в некоторой степени даже стабильность ПО.

![multi-layered architecture](https://github.com/ilsinyakov/QA_Theory/blob/main/Pictures/multi-layered-architecture.webp)

**Преимущества**
* Более простая реализация по сравнению с другими подходами.
* Предлагает абстракцию благодаря разделению ответственностей между уровнями.
* Изолирование защищает одни слои от изменений других.
* Повышает управляемость программного обеспечения за счет слабой связанности.
* Легко и быстро разворачивается

**Недостатки**
* Не предлагает большой масштабируемости.
* ПО, созданное с таким подходом, будет иметь монолитную структуру, усложняющую внесение модификаций, особенно при работе большой командой.
* Данные должны проходить по каждому слою, даже если нет необходимости передавать их с определенных слоев.
* Любой сбой влияет на всю систему, поэтому требует очень тщательного тестирования, что замедляет процесс разработки

## Многоуровневая архитектура (клиент-сервер)

Этот архитектурный подход разделяет комплекс ПО на уровни по принципу взаимодействия “клиент-сервер”. Архитектура может иметь один, два и больше уровней, разделяющих ответственности между поставщиком данных и потребителем.

Этот подход использует шаблон Request-Response для связи между уровнями. В отличие от многослойной архитектуры, он предлагает масштабируемость, которая может быть как горизонтальной (масштабирование сети с помощью добавления узлов), так и вертикальной (масштабирование узла путем повышения его производительности).

### Двухуровневая система

![Двухуровневая система](https://github.com/ilsinyakov/QA_Theory/blob/main/Pictures/two-layer.png)

Эта система состоит из двух физических или виртуальных машин в качестве сервера и клиента. Она обеспечивает изоляцию операций управления данными, обработки данных и операций представления.

* **Клиент** содержит слои презентации и передачи данных.  
* **Сервер** включает слои бизнес-логики, хранилища, базы данных и тоже передачи данных.

### Трехуровневая и n-уровневая системы

![Трехуровневая система](https://github.com/ilsinyakov/QA_Theory/blob/main/Pictures/n-layer.webp)

Такие архитектуры обладают высокой масштабируемостью как по горизонтали, так и по вертикали. Реализация n-уровневой системы, как правило, обходится дороже, но обеспечивает высокую производительность. Поэтому она обычно применяется в крупных и комплексных программных решениях.

Этот подход можно сочетать с современной сервис-ориентированной архитектурой, чтобы создавать сложнейшие модели. Поскольку реализация может оказаться дорогостоящей с точки зрения времени и ресурсов, рекомендуется использовать его для сложных ПО, требующих производительности и масштабируемости.

## Сервис-ориентированная архитектура (SOA)

Эта архитектурная модель состоит из компонентов и приложений, которые связываются друг с другом с помощью четко определенных сервисов.

**Сервис-ориентированная архитектура (service-oriented architecture, SOA)** - по сути, SOA можно свести к нескольким идеям, причём архитектура не диктует способы их реализации:

* Сочетаемость приложений, ориентированных на пользователей.
* Многократное использование бизнес-сервисов.
* Независимость от набора технологий.
* Автономность (независимые эволюция, масштабируемость и развёртываемость).

SOA может быть реализована различными способами.  
Один из примеров реализации - система, состоящая из 5 элементов:
* сервисы (Services);
* сервисная шина (Service Bus);
* сервисный репозиторий (Service Repository catalogue of services);
* безопасность SOA (SOA Security);
* управление SOA (SOA Governance).

![SOA](https://github.com/ilsinyakov/QA_Theory/blob/main/Pictures/soa.webp)

Клиент отправляет запрос с использованием стандартного протокола и формата данных по сети. Этот запрос обрабатывается ESB (enterprise service bus — сервисная шина предприятия), которая считается сердцем сервис-ориентированной архитектуры и отвечает за оркестровку и маршрутизацию. С помощью сервисного репозитория ESB направляет запрос в специальный сервис, который может взаимодействовать с другими сервисами и базами данных, чтобы составить полезную нагрузку (данные) ответа.

Полный вызов ответа на запрос согласуется с правилами управления и безопасности SOA для выполнения безопасной и корректной транзакции.

## Mикросервисная архитектура

Во многих классификациях рассматривается как разновидность SOA или как развитие SOA. 

При таком подходе приложение разрабатывается как набор небольших сервисов, каждый из которых работает в собственном процессе.  
Микросервисная архитектура создавалась в контексте быстро и постоянно меняющихся бизнесов, которые (в основном) с нуля создают собственные облачные приложения.

Микросервисы основываются на бизнес-возможностях и могут развертываться независимо друг от друга с помощью полностью автоматизированного механизма.  

Централизованное управление между сервисами минимально. Они могут быть написаны на разных языках, использовать разные технологии хранения данных.

Архитектура работает по принципу компонентизации сервисов. Она разделяет программное обеспечение на различные изолированные компоненты (сервисы), каждый из которых несет единую ответственность. Изменения в одной сервисе не должны затрагивать другие.

Ещё остались элементы, пронизывающие всю экосистему микросервисов. Но у них гораздо меньше задач по сравнению с ESB. К примеру, для асинхронной связи между микросервисами до сих пор применяется очередь сообщений, но это лишь канал для передачи сообщений, не более того. Или можно вспомнить шлюз экосистемы микросервисов, через который проходит весь внешний обмен данными.


Восемь принципов микросервисной архитектуры:

* **Проектирование сервисов вокруг бизнес-доменов**  
Это может дать нам стабильные интерфейсы, высокосвязные и мало зависящие друг от друга модули кода, а также чётко определённые разграниченные контексты.
* **Культура автоматизации**  
Это даст нам гораздо больше свободы, мы сможем развернуть больше модулей.
* **Скрытие подробностей реализации** 
Это позволяет сервисам развиваться независимо друг от друга.
* **Полная децентрализация**  
Децентрализуйте принятие решений и архитектурные концепции, предоставьте командам автономность, чтобы компания сама превратилась в сложную адаптивную систему, способную быстро приспосабливаться к переменам.
* **Независимое развёртывание**  
Можно развёртывать новую версию сервиса, не меняя ничего другого.
* **Сначала потребитель**  
Сервис должен быть простым в использовании, в том числе другими сервисами.
* **Изолирование сбоев**  
Если один сервис падает, другие продолжают работать, это делает всю систему устойчивой к сбоям.
* **Удобство мониторинга**  
В системе много компонентов, поэтому трудно уследить за всем, что в ней происходит. Нам нужны сложные инструменты мониторинга, позволяющие заглянуть в каждый уголок системы и отследить любую цепочку событий.

