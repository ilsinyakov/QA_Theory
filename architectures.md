# Архитектура программного обеспечения

## Содержание

## Основные понятия

**Архитектура системы** - общий план проектируемого или действующего программного обеспечения, упрощенное представление, в котором определяются основные части программы, и как они будут взаимодействовать или взаимодействуют друг с другом и с внешним миром. 

**Архитектура ПО (разработка архитектуры ПО)** - это искусство и наука строить и проектировать программное обеспечение таким образом, чтобы оно удовлетворяло всем заявленным к нему требованиям, а также обеспечивало максимальную простоту доработки, развертывания и масштабирования приложения.

## Многослойная архитектура (монолит)

Этот подход работает по принципу разделения ответственностей. ПО разделено на слои, лежащие друг на друге, и каждый из них выполняет определенную обязанность.

Архитектура делит ПО на следующие слои:

* **Слой представления** (Presentation Layer) содержит пользовательский интерфейс и отвечает за обеспечение хорошего пользовательского опыта.
* **Слой бизнес-логики** (Business Logic Layer), как следует из названия, содержит бизнес-логику приложения. Он отделяет UI/UX от вычислений, связанных с бизнесом. Это позволяет с легкостью изменять логику в зависимости от постоянно меняющихся бизнес-требований, никак не влияя на другие слои.
* **Слой передачи данных** (Data Link Layer) отвечает за взаимодействие с постоянными хранилищами, такими как базы данных, и прочую обработку информации, которая не связана с бизнесом.

Данные и элементы управления проходят через каждый слой и передаются от одного к другому. Эта система также повышает уровень абстракции и в некоторой степени даже стабильность ПО.

![multi-layered architecture](https://github.com/ilsinyakov/QA_Theory/blob/main/Pictures/multi-layered-architecture.webp)

**Преимущества**
* Более простая реализация по сравнению с другими подходами.
* Предлагает абстракцию благодаря разделению ответственностей между уровнями.
* Изолирование защищает одни слои от изменений других.
* Повышает управляемость программного обеспечения за счет слабой связанности.
* Легко и быстро разворачивается

**Недостатки**
* Не предлагает большой масштабируемости.
* ПО, созданное с таким подходом, будет иметь монолитную структуру, усложняющую внесение модификаций, особенно при работе большой командой.
* Данные должны проходить по каждому слою, даже если нет необходимости передавать их с определенных слоев.
* Любой сбой влияет на всю систему, поэтому требует очень тщательного тестирования, что замедляет процесс разработки

## Многоуровневая архитектура (клиент-сервер)

Этот архитектурный подход разделяет комплекс ПО на уровни по принципу взаимодействия “клиент-сервер”. Архитектура может иметь один, два и больше уровней, разделяющих ответственности между поставщиком данных и потребителем.

Этот подход использует шаблон Request-Response для связи между уровнями. В отличие от многослойной архитектуры, он предлагает масштабируемость, которая может быть как горизонтальной (масштабирование сети с помощью добавления узлов), так и вертикальной (масштабирование узла путем повышения его производительности).

### Двухуровневая система

![Двухуровневая система](https://github.com/ilsinyakov/QA_Theory/blob/main/Pictures/two-layer.png)

Эта система состоит из двух физических или виртуальных машин в качестве сервера и клиента. Она обеспечивает изоляцию операций управления данными, обработки данных и операций представления.

* **Клиент** содержит слои презентации и передачи данных.  
* **Сервер** включает слои бизнес-логики, хранилища, базы данных и тоже передачи данных.

### Трехуровневая и n-уровневая системы

![Трехуровневая система](https://github.com/ilsinyakov/QA_Theory/blob/main/Pictures/n-layer.webp)

Такие архитектуры обладают высокой масштабируемостью как по горизонтали, так и по вертикали. Реализация n-уровневой системы, как правило, обходится дороже, но обеспечивает высокую производительность. Поэтому она обычно применяется в крупных и комплексных программных решениях.

Этот подход можно сочетать с современной сервис-ориентированной архитектурой, чтобы создавать сложнейшие модели. Поскольку реализация может оказаться дорогостоящей с точки зрения времени и ресурсов, рекомендуется использовать его для сложных ПО, требующих производительности и масштабируемости.

## Сервис-ориентированная архитектура (SOA)

Эта архитектурная модель состоит из компонентов и приложений, которые связываются друг с другом с помощью четко определенных сервисов.

**Сервис-ориентированная архитектура (service-oriented architecture, SOA)** - по сути, SOA можно свести к нескольким идеям, причём архитектура не диктует способы их реализации:

* Сочетаемость приложений, ориентированных на пользователей.
* Многократное использование бизнес-сервисов.
* Независимость от набора технологий.
* Автономность (независимые эволюция, масштабируемость и развёртываемость).

SOA может быть реализована различными способами.  
Один из примеров реализации - система, состоящая из 5 элементов:
* сервисы (Services);
* сервисная шина (Service Bus);
* сервисный репозиторий (Service Repository catalogue of services);
* безопасность SOA (SOA Security);
* управление SOA (SOA Governance).

![SOA]()