# SQL

## Содержание
* [Основные понятия](#основные-понятия)
* [Команды SQL](#команды-sql)
* [Ограничения](#ограничения)
* [Целостность данных](#целостность-данных)
* [Нормализация БД](#нормализация-бд)
  * [Первая нормальная форма](#первая-нормальная-форма)
  * [Вторая нормальная форма](#вторая-нормальная-форма)
  * [Третья нормальная форма](#третья-нормальная-форма)
* [Синтаксис SQL](#синтаксис-sql)
* [Типы данных](#типы-данных)
* [Операторы](#операторы)
* [Выражения](#выражения)
  * [Логические](#логические)
  * [Числовые](#числовые)
  * [Агрегирующие вычисления](#агрегирующие-вычисления)
  * [Работа со строками](#работа-со-строками)
  * [Работа с числами](#работа-с-числами)
  * [Работа с датами](#работа-с-датами)
* [Создание БД](#создание-бд)
* [Удаление БД](#удаление-бд)
* [Выбор БД](#выбор-бд)
* [Создание таблицы](#создание-таблицы)
* [Удаление таблицы](#удаление-таблицы)
* [Добавление записей (строк)](#добавление-записей-строк)
* [Выборка полей](#выборка-полей)
* [Предложение WHERE](#предложение-where)
* [Обновление полей](#обновление-полей)
* [Удаление записей](#удаление-записей)
* [Предложения LIKE и REGEXP](#предложения-like-и-regexp)
  * [LIKE](#like)
  * [REGEXP](#regexp)
* [Предложение TOP / LIMIT / ROWNUM](#предложение-top--limit--rownum)
  * [TOP](#top)
  * [LIMIT](#limit)
  * [ROWNUM](#rownum)
* [Предложения ORDER BY и GROUP BY](#предложения-order-by-и-group-by)
  * [ORDER BY](#order-by)
  * [GROUP BY](#group-by)
* [Ключевое слово DISTINCT](#ключевое-слово-distinct)
* [Соединения](#соединения)
* [Предложение UNION](#предложение-union)
* [Предложение UNION ALL](#предложение-union-all)
* [Синонимы (алиасы)](#синонимы-алиасы)
* [Индексы](#индексы)
  * [Создание индексов](#создание-индексов)
  * [Удаление индексов](#удаление-индексов)
* [Обновление таблицы](#обновление-таблицы)
* [Очистка таблицы](#очистка-таблицы)
* [Представления](#представления)
  * [Создание представления](#создание-представления)
  * [WITH CHECK OPTION](#with-check-option)
  * [Обновление представления](#обновление-представления)
  * [Удаление представления](#удаление-представления)
* [Транзакции](#транзакции)
  * [Свойства транзакции](#свойства-транзакции)
  * [Управление транзакцией](#управление-транзакцией)
* [Подзапросы](#подзапросы)
* [Последовательности](#последовательности)

## Основные понятия

**SQL** (Structured Query Language) — это язык структурированных запросов, позволяющий сохранять, манипулировать и извлекать данные из реляционных баз данных.

**Реляционная база данных** — база данных, основанная на реляционной модели данных.  
Понятие «реляционный» основано на англ. *relation* («отношение»).

**Отношение** состоит из заголовка (схемы) и тела. ***Заголовок*** представляет собой множество атрибутов, а ***тело*** — множество кортежей, соответствующих заголовку.  
Отношение обычно имеет простую графическую интерпретацию в виде таблицы, столбцы которой соответствуют атрибутам, а строки — кортежам, а в «ячейках» находятся значения атрибутов в кортежах.

![Отношение](https://github.com/ilsinyakov/QA_Theory/blob/main/Pictures/Relational_database_terms.svg)

В контексте реляционных баз данных:  
**Отношение** — это двумерная таблица с уникальным именем. Она состоит из строк (записей) и столбцов (атрибутов, полей).

Каждая **строка** таблицы представляет некоторый объект реального мира (экземпляр сущности) или соотношения между объектами.

**Столбцы** — это атрибуты сущности, для сущности каждого типа они свои.

**Реляционная БД** — это ограниченный набор особых таблиц с данными. Эти таблицы называются отношениями. Отношения используются для представления сущностей, а также связей между ними.

**Нулевое значение (NULL)** — это значение поля, которое является пустым, т.е. нулевое значение — это значение поля, не имеющего значения. Важно понимать, что нулевое значение отличается от значения 0 и от значения поля, содержащего пробелы. Поле с нулевым значением - это такое поля, которое осталось пустым при создании записи.

## Команды SQL

Стандартными командами для взаимодействия с РБД являются `CREATE`, `SELECT`, `INSERT`, `UPDATE`, `DELETE` и `DROP`. Эти команды могут быть классифицированы следующим образом:

<!-- markdownlint-disable MD033 -->
<br>

* **DDL** — язык определения данных (Data Definition Language)

|N|Команда|Описание|
|--|--|--|
|1|`CREATE`|Создает новую таблицу, представление таблицы или другой объект в БД|
|2|`ALTER`|Модифицирует существующий в БД объект, такой как таблица|
|3|`DROP`|Удаляет существующую таблицу, представление таблицы или другой объект в БД|

<br>

* **DML** — язык изменения данных (Data Manipulation Language)

|N|Команда|Описание|
|--|--|--|
|1|`SELECT`|Извлекает записи из одной или нескольких таблиц|
|2|`INSERT`|Создает записи|
|3|`UPDATE`|Модифицирует записи|
|4|`DELETE`|Удаляет записи|

<br>

* **DCL** — язык управления данными (Data Control Language)

|N|Команда|Описание|
|--|--|--|
|1|`GRANT`|Наделяет пользователя правами|
|2|`REVOKE`|Отменяет права пользователя|

## Ограничения

**Ограничения** (constraints) — это правила, применяемые к данным. Они используются для ограничения данных, которые могут быть записаны в таблицу. Это обеспечивает точность и достоверность данных в БД.

Ограничения могут устанавливаться как на уровне колонки, так и на уровне таблицы.

Среди наиболее распространенных ограничений можно назвать следующие:

* `NOT NULL` — колонка не может иметь нулевое значение
* `DEFAULT` — значение колонки по умолчанию
* `UNIQUE` — все значения колонки должны быть уникальными
* `PRIMARY KEY` — первичный или основной ключ, уникальный идентификатор записи в текущей таблице
* `FOREIGN KEY` — внешний ключ, уникальный идентификатор записи в другой таблице (таблице, связанной с текущей)
* `CHECK` — все значения в колонке должны удовлетворять определенному условию
* `INDEX` — быстрая запись и извлечение данных

Любое ограничение может быть удалено с помощью команды `ALTER TABLE` и `DROP CONSTRAINT + название ограничения`.

## Целостность данных

В каждой СУБД существуют следующие категории целостности данных:
* целостность **объекта** (Entity Integrity) — в таблице не должно быть дубликатов (двух и более строк с одинаковыми значениями)
* целостность **домена** (Domain Integrity) — фильтрация значений по типу, формату или диапазону
* целостность **ссылок** (Referential integrity) — строки, используемые другими записями (строки, на которые в других записях имеются ссылки), не могут быть удалены
* целостность, определенная **пользователем** (User-Defined Integrity) — дополнительные правила

## Нормализация БД

**Нормализация** — это процесс эффективной организации данных в БД. Существует две главных причины, обуславливающих необходимость нормализации:

* предотвращение записи в БД лишних данных, например, хранения одинаковых данных в разных таблицах
* обеспечение "оправданной" связи между данными

Нормализация предполагает соблюдение нескольких форм. Форма — это формат структурирования БД. 

По правилам нормализации есть семь нормальных форм баз данных:
*	первая,
*	вторая,
*	третья,
*	нормальная форма Бойса-Кодда,
*	четвёртая,
*	пятая,
*	шестая.

Приводить данные к нормальным формам можно только последовательно. То есть в базе данных второй нормальной формы данные по умолчанию уже должны быть нормализованы по правилам первой нормальной формы и так далее. В итоге база данных в шестой нормальной форме — идеально нормализованная. 

В некоторых случаях попытка нормализовать данные до «идеального» состояния может привести к созданию множества таблиц, ключей и связей. Это усложнит работу с базой и снизит производительность СУБД. Поэтому обычно данные нормализуют до ***третьей нормальной формы***. 

### Первая нормальная форма
В базе данных не должно быть дубликатов и составных данных.

Элементы составных данных лучше разнести по разным полям, иначе в процессе работы с данными могут появиться ошибки и аномалии.

### Вторая нормальная форма
Если упростить: у каждой записи в базе данных должен быть первичный ключ. Первичный ключ — это элемент записи, который не повторяется в других записях.

### Третья нормальная форма
В записи не должно быть столбцов с неключевыми значениями, которые зависят от других неключевых значений.

Данные не во всех случаях преобразовывают до третьей формы. Иногда для этого придётся создать много небольших таблиц, что усложнит базу и задачу разработчикам.

## Синтаксис SQL

```sql
-- выборка
SELECT col1, col2, ...colN
FROM tableName;

SELECT DISTINCT col1, col2, ...colN
FROM tableName;

SELECT col1, col2, ...colN
FROM tableName
WHERE condition;

SELECT col1, col2, ...colN
FROM tableName
WHERE condition1 AND|OR condition2;

SELECT col2, col2, ...colN
FROM tableName
WHERE colName IN (val1, val2, ...valN);

SELECT col1, col2, ...colN
FROM tableName
WHERE colName BETWEEN val1 AND val2;

SELECT col1, col2, ...colN
FROM tableName
WHERE colName LIKE pattern;

SELECT col1, col2, ...colN
FROM tableName
WHERE condition
ORDER BY colName [ASC|DESC];

SELECT SUM(colName)
FROM tableName
WHERE condition
GROUP BY colName;

SELECT COUNT(colName)
FROM tableName
WHERE condition;

SELECT SUM(colName)
FROM tableName
WHERE condition
GROUP BY colName
HAVING (function condition);

-- создание таблицы
CREATE TABLE tableName (
  col1 datatype,
  col2 datatype,
  ...
  colN datatype,
  PRIMARY KEY (одна или более колонка)
);

-- удаление таблицы
DROP TABLE tableName;

-- создание индекса
CREATE UNIQUE INDEX indexName
ON tableName (col1, col2, ...colN);

-- удаление индекса
ALTER TABLE tableName
DROP INDEX indexName;

-- получение описания структуры таблицы
DESC tableName;

-- очистка таблицы
TRUNCATE TABLE tableName;

-- добавление/удаление/модификация колонок
ALTER TABLE tableName ADD|DROP|MODIFY colName [datatype];

-- переименование таблицы
ALTER TABLE tableName RENAME TO newTableName;

-- вставка значений
INSERT INTO tableName (col1, col2, ...colN)
VALUES (val1, val2, ...valN)

-- обновление записей
UPDATE tableName
SET col1 = val1, col2 = val2, ...colN = valN
[WHERE condition];

-- удаление записей
DELETE FROM tableName
WHERE condition;

-- создание БД
CREATE DATABASE [IF NOT EXISTS] dbName;

-- удаление БД
DROP DATABASE [IF EXISTS] dbName;

-- выбор БД
USE dbName;

-- завершения транзакции
COMMIT;

-- отмена изменений
ROLLBACK;
```

## Типы данных

* Точные числовые

|Тип данных|От|До|
|--|--|--|
|bigint|-9,223,372,036,854,775,808|9,223,372,036,854,775,807|
|int|-2,147,483,648|2,147,483,647|
|smallint|-32,768|32,767|
|tinyint|0|255|
|bit|0|1|
|decimal|-10^38 +1|10^38 -1|
|numeric|-10^38 +1|10^38 -1|
|money|-922,337,203,685,477.5808|+922,337,203,685,477.5807|
|smallmoney|-214,748.3648|+214,748.3647|

<br>

* Приблизительные числовые

|Тип данных|От|До|
|--|--|--|
|float|-1.79E + 308|1.79E + 308|
|real|-3.40E + 38|3.40E + 38|

<br>

* Дата и время

|Тип данных|От|До|
|--|--|--|
|datetime|Jan 1, 1753|Dec 31, 9999|
|smalldatetime|Jan 1, 1900|Jun 6, 2079|
|date|Дата сохраняется в виде June 30, 1991||
|time|Время сохраняется в виде 12:30 P.M.||

<br>

* Строковые символьные

|Тип данных|Описание|
|--|--|
|char|Строка длиной до 8,000 символов (не-юникод символы, фиксированной длины)|
|varchar|Строка длиной до 8,000 символов (не-юникод символы, переменной длины)|
|text|Не-юникод данные переменной длины, длиной до 2,147,483,647 символов|

<br>

* Строковые символьные (юникод)

|Тип данных|Описание|
|--|--|
|nchar|Строка длиной до 4,000 символов (юникод символы, фиксированной длины)|
|nvarchar|Строка длиной до 4,000 символов (юникод символы, переменной длины)|
|ntext|Юникод данные переменной длины, длиной до 1,073,741,823 символов|

<br>

* Бинарные

|Тип данных|Описание|
|--|--|
|binary|Данные размером до 8,000 байт (фиксированной длины)|
|varbinary|	Данные размером до 8,000 байт (переменной длины)|
|image|Данные размером до 2,147,483,647 байт (переменной длины)|

<br>

* Смешанные

|Тип данных|Описание|
|--|--|
|timestamp|Уникальные числа, обновляющиеся при каждом изменении строки|
|uniqueidentifier|Глобально-уникальный идентификатор (GUID)|
|cursor|Объект курсора|
|table|Промежуточный результат, предназначенный для дальнейшей обработки|

## Операторы

**Оператор** (operator) — это ключевое слово или символ, которые, в основном, используются в инструкциях WHERE для выполнения каких-либо операций. Они используются как для определения условий, так и для объединения нескольких условий в инструкции.

В дальнейших примерах мы будем исходить из предположения, что переменная a имеет значение 10, а b — 20.

<br>

* Арифметические


|Оператор|Описание|Пример|
|--|--|--|
|+ (сложение)|Сложение значений|a + b = 30|
|- (вычитание)|Вычитание правого операнда из левого|b - a = 10|
|*(умножение)|Умножение значений|a * b = 200|
|/ (деление)|	Деление левого операнда на правый|	b / a = 2|
|% (деление с остатком/по модулю)|	Деление левого операнда на правый с остатком (возвращается остаток)|	b % a = 0|

<br>

* Операторы сравнения


|Оператор|Описание|Пример|
|--|--|--|
|=|	Определяет равенство значений|	a = b -> false|
|!=|	Определяет НЕравенство значений|	a != b -> true|
|<>|	Определяет НЕравенство значений|	a <> b -> true|
|>|	Значение левого операнда больше значения правого операнда?|	a > b -> false|
|<|	Значение левого операнда меньше значения правого операнда?|	a < b -> true|
|>=|	Значение левого операнда больше или равно значению правого операнда?|	a >= b -> false|
|<=|	Значение левого операнда меньше или равно значению правого операнда?|	a <= b -> true|
|!<|	Значение левого операнда НЕ меньше значения правого операнда?|	a !< b -> false|
|!>|	Значение левого операнда НЕ больше значения правого операнда?|	a !> b -> true|

<br>

* Логические операторы

|Оператор|Описание|
|--|--|
|ALL|	Сравнивает все значения|
|AND|	Объединяет условия (все условия должны совпадать)|
|ANY|	Сравнивает одно значение с другим, если последнее совпадает с условием|
|BETWEEN|	Проверяет вхождение значения в диапазон от минимального до максимального|
|EXISTS|	Определяет наличие строки, соответствующей определенному критерию|
|IN|	Выполняет поиск значения в списке значений|
|LIKE|	Сравнивает значение с похожими с помощью операторов подстановки|
|NOT|	Инвертирует (меняет на противоположное) смысл других логических операторов, например, NOT EXISTS, NOT IN и т.д.|
|OR|	Комбинирует условия (одно из условий должно совпадать)|
|IS NULL|	Определяет, является ли значение нулевым|
|UNIQUE|	Определяет уникальность строки|


## Выражения

**Выражение** (expression) — это комбинация значений, операторов и функций для оценки (вычисления) значения.

Базовый синтаксис выражения выглядит так:

```sql
SELECT col1, col2, ...colN
FROM tableName
WHERE [condition|expression];
```

### Логические

Логические выражения извлекают данные на основе совпадения с единичным значением.

`SELECT * FROM users WHERE status = active;`

### Числовые


Используются для выполнения арифметических операций в запросе.

```sql
SELECT numericalExpression as operationName
[FROM tableName
WHERE condition];
```

Простой пример использования числового выражения:

`SELECT (10 + 5) AS addition;`

Результат:

|addition|
|--|
|15|

### Агрегирующие вычисления

Существует несколько встроенных функций, таких как count(), sum(), avg(), min(), max() и др. для выполнения так называемых агрегирующих вычислений данных таблицы или колонки.


`SELECT COUNT(*) AS records FROM users;`

Результат:

|records|
|--|
|4|

`AVG` — вычисляет среднее значение  
`SUM` — вычисляет сумму значений  
`MIN` — вычисляет наименьшее значение  
`MAX` — вычисляет наибольшее значение  
`COUNT` — вычисляет количество записей в таблице  

### Работа со строками

`CONCAT` — объединение строк
`LENGTH` — возвращает количество символов в строке  
`TRIM` — удаляет пробелы в начале и конце строки  
`SUBSTRING` — извлекает подстроку из строки  
`REPLACE` — заменяет подстроку в строке  
`LOWER` — переводит символы строки в нижний регистр  
`UPPER` — переводит символы строки в верхний регистр

### Работа с числами

`ROUND` — округляет число  
`TRUNCATE` — обрезает дробное число до указанного количества знаков после запятой  
`CEILING` — возвращает наименьшее целое число, которое больше или равно текущему значению  
`FLOOR` — возвращает наибольшее целое число, которое меньше или равно текущему значению  
`POWER` — возводит число в указанную степень  
`SQRT` — возвращает квадратный корень числа  
`RAND` — генерирует случайное число с плавающей точкой в диапазоне от 0 до 1  

### Работа с датами

`CURRENT_TIMESTAMP / CURRENT_TIMESTAMP() / NOW()` — это выражение или функция () для получения текущей даты и времени. Возвращает дату и время в формате: `2021-06-20 12:45:00`

`CURDATE/CURRENT_DATE` — возвращает текущую дату  
`CURTIME/CURRENT_TIME` — возвращает текущее время

Функции для разбора даты и времени:

`DAYOFMONTH(date)` — возвращает день месяца в виде числа  
`DAYOFWEEK(date)` — возвращает день недели в виде числа  
`DAYOFYEAR(date)` — возвращает номер дня в году  
`MONTH(date)` — возвращает месяц  
`YEAR(date`) — возвращает год  
`LAST_DAY(date)` — возвращает последний день месяца в виде даты  
`HOUR(time)` — возвращает час  
`MINUTE(time)` — возвращает минуты  
`SECOND(time)` — возвращает секунды

Функции для манипулирования датами:

`DATE_ADD(date, interval)` — выполняет сложение даты и определенного временного интервала  
`DATE_SUB(date, interval)` — выполняет вычитание из даты определенного временного интервала  
`DATEDIFF(date1, date2)` — возвращает разницу в днях между двумя датами  
`TO_DAYS(date)` — возвращает количество дней с 0-го дня года  
`TIME_TO_SEC(time)` — возвращает количество секунд с полуночи  

Функции для форматирования:

`DATE_FORMAT(date, format)`  
`TIME_FORMAT(date, format)`

## Создание БД

Для создания БД используется инструкция `CREATE DATABASE`.

```sql
CREATE DATABASE dbName;
-- или
CREATE DATABASE IF NOT EXISTS dbName;
```

Условие `IF NOT EXISTS` позволяет избежать получения ошибки при попытке создания БД, которая уже существует.


Название БД должно быть уникальным в пределах СУБД.

Получаем список БД:  
`SHOW DATABASES;`

## Удаление БД

Для удаления БД используется инструкция `DROP DATABASE`.

```sql
DROP DATABASE dbName;
-- или
DROP DATABASE IF EXISTS dbName;
```

Условие `IF EXISTS` позволяет избежать получения ошибки при попытке удаления несуществующей БД.

## Выбор БД

При наличии нескольких БД, перед выполнением каких-либо операций, необходимо выбрать БД. Для этого используется инструкция `USE`.

```sql
USE dbName;
```

## Создание таблицы

Создание таблицы предполагает указание названия таблицы и определение колонок таблицы и их типов данных. Для создания таблицы используется инструкция `CREATE TABLE`.

```sql
CREATE TABLE tableName (
  col1 datatype,
  col2 datatype,
  ...
  colN datatype,
  PRIMARY KEY (хотя бы одна колонка)
);
```

Для создания таблицы путем копирования другой таблицы используется сочетание `CREATE TABLE` и `SELECT`.

Пример создания таблицы users, где первичным ключом являются идентификаторы пользователей, а поля для имени и возраста пользователя не могут быть нулевыми:

```sql
CREATE TABLE users (
  userId INT,
  userName VARCHAR(20)  NOT NULL,
  age INT NOT NULL,
  city VARCHAR(20),
  status VARCHAR(8),
  PRIMARY KEY (userId)
);
```

`DESC <table>` - выводит данные о таблице

## Удаление таблицы

Для удаления таблицы используется инструкция `DROP TABLE`.

Удаляем таблицу users:
`DROP TABLE users;`

## Добавление записей (строк)

Для добавления в таблицу записей используется инструкция `INSERT INTO`.

```sql
INSERT INTO tableName (col1, col2, ...colN)
VALUES (val1, val2, ...valN);
```

Названия колонок можно не указывать, однако, в этом случае значения должны перечисляться в правильном порядке.

`INSERT INTO tableName VALUES (val1, val2, ...valN);`

В таблицу можно добавлять несколько строк за один раз.

```sql
INSERT INTO users (userId, userName, age, city, status)
VALUES
(1, 'Igor', 25, 'Moscow', 'active'),
(2, 'Vika', 26, 'Ekaterinburg', 'inactive'),
(3, 'Elena', 27, 'Ekaterinburg', 'active');
```

Заполнение таблицы с помощью другой таблицы:

```sql
INSERT INTO tableName [(col1, col2, ...colN)]
  SELECT col1, col2, ...colN
  FROM anotherTable
  [WHERE condition];
```

## Выборка полей

Для выборки полей из таблицы используется инструкция `SELECT`. Она возвращает данные в виде результирующей таблицы (результирующего набора, result-set).


```sql
SELECT col1, col2, ...colN
FROM tableName;
```

Для выборки всех полей используется такой синтаксис:  
`SELECT * FROM tableName;`

## Предложение WHERE

Предложение `WHERE` используется для фильтрации возвращаемых данных. Оно используется совместно с `SELECT, UPDATE, DELETE` и другими инструкциями.

```sql
SELECT col1, col2, ...col2
FROM tableName
WHERE condition;
```

Условие (condition), которому должны удовлетворять возвращаемые записи, определяется с помощью операторов сравнения или логических операторов типа >, <, =, NOT, LIKE и т.д.

Обратите внимание: строки в предложении `WHERE` должны быть обернуты в одинарные кавычки (`''`), а числа, напротив, указываются как есть.

## Обновление полей

Для обновления полей используется инструкция `UPDATE ... SET`. Эта инструкция, обычно, используется в сочетании с предложением `WHERE`.

```sql
UPDATE tableName
SET col1 = val1, col2 = val2, ...colN = valN
[WHERE condition];
```

Обновим возраст пользователя с именем Igor:

```sql
UPDATE users
SET age = 30
WHERE username = 'Igor';
```

Если в данном случае опустить `WHERE`, то будет обновлен возраст всех пользователей.

## Удаление записей

Для удаления записей используется инструкция `DELETE FROM`. Эта инструкция также, как правило, используется в сочетании с предложением `WHERE`.

```sql
DELETE FROM tableName
[WHERE condition];
```

Удалим неактивных пользователей:

```sql
DELETE FROM users
WHERE status = 'inactive';
```

Если в данном случае опустить `WHERE`, то из таблицы users будут удалены все записи.

## Предложения LIKE и REGEXP

### LIKE

Предложение `LIKE` используется для сравнения значений с помощью операторов с подстановочными знаками. Существует два вида таких операторов:

* проценты (`%`)
* нижнее подчеркивание (`_`)

`%` означает 0, 1 или более символов.  
`_` означает точно 1 символ.

Примеры:

|Инструкция|Результат|
|--|--|
|WHERE col LIKE 'foo%'|	Любые значения, начинающиеся с foo|
|WHERE col LIKE '%foo%'|	Любые значения, содержащие foo|
|WHERE col LIKE '_oo%'|	Любые значения, содержащие oo на второй и третьей позициях|
|WHERE col LIKE 'f%%'|	Любые значения, начинающиеся с f и состоящие как минимум из 1 символа|
|WHERE col LIKE '%oo'|	Любые значения, оканчивающиеся на oo|
|WHERE col LIKE '_o%o|'	Любые значения, содержащие o на второй позиции и оканчивающиеся на o|
|WHERE col LIKE 'f_o'|	Любые значения, содержащие f и o на первой и третьей позициях, соответственно, и состоящие из трех символов|

### REGEXP

Предложение `REGEXP` позволяет определять регулярное выражение, которому должна соответствовать запись.

```sql
SELECT col1, col2, ...colN FROM tableName
WHERE colName REGEXP регулярное выражение;
```

В регулярное выражении могут использоваться следующие специальные символы:

`^` — начало строки  
`$` — конец строки  
`.` — любой символ  
`[символы]` — любой из указанных в скобках символов  
`[начало-конец]` — любой символ из диапазона  
`|` — разделяет шаблоны  

Сделаем выборку пользователей с именами Igor и Vika:
```sql
SELECT * FROM users
WHERE userName REGEXP 'Igor|Vika';
```

## Предложение TOP / LIMIT / ROWNUM

Данные предложения позволяют извлекать указанное количество или процент записей с начала таблицы. Разные СУБД поддерживают разные предложения.

### TOP

Используется в Microsoft SQL Server

```sql
SELECT TOP number|percent col1, col2, ...colN
FROM tableName
[WHERE condition];
```

Сделаем выборку первых трех пользователей:  
`SELECT TOP 3 * FROM users;`

### LIMIT

Используется во многих СУБД.  
Предложение `LIMIT` позволяет ограничить количество строк, возвращаемых в результате выполнения запроса.

```sql
SELECT * FROM table_name
ORDER BY some_column ASC
LIMIT 10;
```
Этот запрос выбирает первые 10 строк из таблицы table_name, сортируя их по столбцу some_column в порядке возрастания.

### ROWNUM

Используется в Oracle Database.   
Она применяется для получения порядкового номера строки при выборке данных. 

```sql
SELECT * FROM (
  SELECT t.*, ROWNUM AS rnum
  FROM your_table t
  ORDER BY some_column)
WHERE rnum <= 10;
```
Этот запрос выбирает первые 10 строк из таблицы your_table, сортируя их по столбцу some_column.

## Предложения ORDER BY и GROUP BY

### ORDER BY

Предложение `ORDER BY` используется для сортировки данных по возрастанию (`ASC`) или убыванию (`DESC`). Многие СУБД по умолчанию выполняют сортировку по возрастанию.

```sql
SELECT col1, col2, ...colN
FROM tableName
[WHERE condition]
[ORDER BY col1, col2, ...colN] [ASC | DESC];
```

Обратите внимание: колонки для сортировки должны быть указаны в списке колонок для выборки.

### GROUP BY

Предложение `GROUP BY` используется совместно с инструкцией `SELECT` для группировки записей. Оно указывается после `WHERE` и перед `ORDER BY`.

```sql
SELECT col1, col2, ...colN
FROM tableName
WHERE condition
GROUP BY col1, col2, ...colN
ORDER BY col1, col2, ...colN;
```

Сгруппируем активных пользователей по городам:

```sql
SELECT city, COUNT(city) AS amount 
FROM users
WHERE status = active
GROUP BY city
ORDER BY city;
```

## Ключевое слово DISTINCT

Ключевое слово `DISTINCT` используется совместно с инструкцией `SELECT` для возврата только уникальных записей (без дубликатов).

```sql
SELECT DISTINCT col1, col2, ...colN
FROM tableName
[WHERE condition];
```

## Соединения

Соединения (joins) используются для комбинации записей двух и более таблиц.

Существуют разные типы объединений:

`INNER JOIN` — возвращает записи, имеющиеся в обеих таблицах  
`LEFT JOIN` — возвращает записи из левой таблицы, даже если такие записи отсутствуют в правой таблице  
`RIGHT JOIN` — возвращает записи из правой таблицы, даже если такие записи отсутствуют в левой таблице  
`FULL JOIN` — возвращает все записи объединяемых таблиц  
`CROSS JOIN` — возвращает все возможные комбинации строк обеих таблиц  
`SELF JOIN` — используется для объединения таблицы с самой собой

## Предложение UNION

Предложение/оператор `UNION` используется для комбинации результатов двух и более инструкций `SELECT`. При этом, возвращаются только **уникальные** записи.

В случае с `UNION`, каждая инструкция `SELECT` должна иметь:

* одинаковый набор колонок для выборки
* одинаковое количество выражений
* одинаковые типы данных колонок
* одинаковый порядок колонок

```sql
SELECT col1, col2, ...colN
FROM table1
[WHERE condition]

UNION

SELECT col1, col2, ...colN
FROM table2
[WHERE condition];
```

## Предложение UNION ALL

Предложение `UNION ALL` также используется для объединения результатов двух и более инструкций `SELECT`. При этом, возвращаются все записи, включая **дубликаты**.

```sql
SELECT col1, col2, ...colN
FROM table1
[WHERE condition]

UNION ALL

SELECT col1, col2, ...colN
FROM table2
[WHERE condition];
```

## Синонимы (алиасы)

**Синонимы** (aliases) позволяют временно изменять названия таблиц и колонок. "Временно" означает, что новое название используется только в текущем запросе, в БД название остается прежним.

Синтаксис синонима таблицы:

```sql
SELECT col1, col2, ...colN
FROM tableName AS aliasName
[WHERE condition];
```

Синтаксис синонима колонки:

```sql
SELECT colName AS aliasName
FROM tableName
[WHERE condition];
```

## Индексы

**Индексы** — это специальные поисковые таблицы (lookup tables), которые используются движком БД в целях более быстрого извлечения данных. Проще говоря, индекс — это указатель или ссылка на данные в таблице.

Индексы ***ускоряют*** работу инструкции `SELECT` и предложения `WHERE`,  
но ***замедляют*** работу инструкций `UPDATE` и `INSERT`.  

Индексы могут создаваться и удаляться, не оказывая никакого влияния на данные.

Несмотря на то, что индексы предназначены для повышения производительности БД, существуют ситуации, в которых их использования лучше избегать.  
К таким ситуациям относится следующее:
* индексы не должны использоваться в маленьких таблицах
* в таблицах, которые часто и в большом объеме обновляются или перезаписываются
* в колонках, которые содержат большое количество нулевых значений
* в колонках, над которыми часто выполняются операции

### Создание индексов

Для создания индекса используется инструкция `CREATE INDEX`, позволяющая определять название индекса, индексируемые колонки и порядок индексации (по возрастанию или по убыванию).

К индексам можно применять ограничение `UNIQUE` для того, чтобы обеспечить их уникальность.

Синтаксис создания индекса:

```sql
CREATE INDEX indexName ON tableName;
```

Синтаксис создания индекса для одной колонки:

```sql
CREATE INDEX indexName
ON tableName (colName);
```

Синтакис создания уникальных индексов (такие индексы используются не только для повышения производительности, но и для обеспечения согласованности данных):

```sql
CREATE UNIQUE INDEX indexName
ON tableName (colName);
```

Синтаксис создания индексов для нескольких колонок (композиционный индекс):

```sql
CREATE INDEX indexName
ON tableName (col1, col2, ...colN);
```

Решение о создании индексов для одной или нескольких колонок следует принимать на основе того, какие колонки будут часто использоваться в запросе WHERE в качестве условия для отбора строк.

Для ограничений `PRIMARY KEY` и `UNIQUE` автоматически создаются неявные индексы.

### Удаление индексов

Для удаления индексов используется инструкция `DROP INDEX`:

`DROP INDEX indexName;`

## Обновление таблицы

Команда `ALTER TABLE` используется для добавления, удаления и модификации колонок существующей таблицы. Также эта команда используется для добавления и удаления ограничений.

Синтаксис:

```sql
-- добавление новой колонки
ALTER TABLE tableName ADD colName datatype;

-- удаление колонки
ALTER TABLE tableName DROP COLUMN colName;

-- изменение типа данных колонки
ALTER TABLE tableName MODIFY COLUMN colName newDatatype;

-- добавление ограничения `NOT NULL`
ALTER TABLE tableName MODIFY colName datatype NOT NULL;

-- добавление ограничения `UNIQUE`
ALTER TABLE tableName
ADD CONSTRAINT myUniqueConstraint UNIQUE (col1, col2, ...colN);

-- добавление ограничения `CHECK`
ALTER TABLE tableName
ADD CONSTRAINT myUniqueConstraint CHECK (condition);

-- добавление первичного ключа
ALTER TABLE tableName
ADD CONSTRAINT myPrimaryKey PRIMARY KEY (col1, col2, ...colN);

-- удаление ограничения
ALTER TABLE tableName
DROP CONSTRAINT myUniqueContsraint;

-- mysql
ALTER TABLE tableName
DROP INDEX myUniqueContsraint;

-- удаление первичного ключа
ALTER TABLE tableName
DROP CONSTRAINT myPrimaryKey;

-- mysql
ALTER TABLE tableName
DROP PRIMARY KEY;
```

Добавляем в таблицу users новую колонку — пол пользователя:  
`ALTER TABLE users ADD sex char(1);`

Удаляем эту колонку:  
`ALTER TABLE users DROP sex;`

## Очистка таблицы

Команда `TRUNCATE TABLE` используется для очистки таблицы. Ее отличие от `DROP TABLE` состоит в том, что сохраняется структура таблицы (`DROP TABLE` полностью удаляет таблицу и все ее данные).

`TRUNCATE TABLE tableName;`

## Представления

**Представление** (view) — это не что иное, как инструкция, записанная в БД под определенным названием. Другими словами, представление — это композиция таблицы в форме предварительно определенного запроса.

Представления могут содержать все или только некоторые строки таблицы. Представление может быть создано на основе одной или нескольких таблиц (это зависит от запроса для создания представления).

Представления — это виртутальные таблицы, позволяющие делать следующее:
* структурировать данные способом, который пользователи находят наиболее естественным или интуитивно понятным
* ограничивать доступ к данным таким образом, что пользователь может просматривать и (иногда) модифицировать только то, что ему нужно и ничего более
* объединять данные из нескольких таблиц для формирования отчетов

### Создание представления

Для создания представления используется инструкция `CREATE VIEW`. Как было отмечено, представления могут создаваться на основе одной или нескольких таблиц, и даже на основе другого представления.

```sql
CREATE VIEW viewName AS
SELECT col1, col2, ...colN
FROM tableName
[WHERE condition];
```

Создаем представление для имен и возраста пользователей:

```sql
CREATE VIEW usersView AS
SELECT userName, age
FROM users;
```

Получаем данные с помощью представления:

`SELECT * FROM usersView;`

### WITH CHECK OPTION

`WITH CHECK OPTION` — это настройка инструкции `CREATE VIEW`. Она позволяет обеспечить соответствие всех `UPDATE` и `INSERT` условию, определенном в представлении.

Если условие не удовлетворяется, выбрасывается исключение.

```sql
CREATE VIEW usersView AS
SELECT userName, age
FROM users
WHERE age IS NOT NULL
WITH CHECK OPTION;
```

### Обновление представления

Представление может быть обновлено при соблюдении следующих условий:

* `SELECT` не содержит ключевого слова `DISTINCT`
* `SELECT` не содержит агрегирующих функций
* `SELECT` не содержит функций установки значений
* `SELECT` не содержит операций установки значений
* `SELECT` не содержит предложения `ORDER BY`
* `FROM` не содержит больше одной таблицы
* `WHERE` не содержит подзапросы
* запрос не содержит `GROUP BY` или `HAVING`
* вычисляемые колонки не обновляются
* все ненулевые колонки из базовой таблицы включены в представление в том же порядке, в каком они указаны в запросе `INSERT`

Пример обновления возраста пользователя с именем Igor в представлении:

```sql
UPDATE usersView
SET age = 31
WHERE userName = 'Igor';
```

Обратите внимание: обновление строки в представлении приводит к ее обновлению в базовой таблице.

В представление могут добавляться новые строки с помощью команды `INSERT`. При выполнении этой команды должны соблюдаться те же правила, что и при выполнении команды `UPDATE`.

С помощью команды `DELETE` можно удалять строки из представления.

Удаляем из представления пользователя, возраст которого составляет 26 лет:

```sql
DELETE FROM usersView
WHERE age = 26;
```

Обратите внимание: удаление строки в представлении приводит к ее удалению в базовой таблице.

### Удаление представления

Для удаления представления используется инструкция DROP VIEW:  
`DROP VIEW viewName;`

## Транзакции

**Транзакция** — это единица работы или операции, выполняемой над БД. Это последовательность операций, выполняемых в логическом порядке. Эти операции могут запускаться как пользователем, так и какой-либо программой, функционирующей в БД.

**Транзакция** — это применение одного или более изменения к БД. Например, при создании/обновлении/удалении записи мы выполняем транзакцию. Важно контролировать выполнение таких операций в целях обеспечения согласованности данных и обработки возможных ошибок.

На практике, запросы, как правило, не отправляются в БД по одному, они группируются и выполняются как часть транзакции.

### Свойства транзакции

Транзакции имеют 4 стандартных свойства (ACID):
* **атомарность** (atomicity) — все операции транзакции должны быть успешно завершены. В противном случае, транзакция прерывается, а все изменения отменяются (происходит откат к предыдущему состоянию)
* **согласованность** (consistency) — состояние должно измениться в полном соответствии с операциями транзакции
* **изоляция или автономность** (isolation) — транзакции не зависят друг от друга и не оказывают друг на друга никакого влияния
* **долговечность** (durability) — результат звершенной транзакции должен сохраняться при поломке системы

### Управление транзакцией

Для управления транзакцией используются следующие команды:

`BEGIN|START TRANSACTION` — запуск транзакции  
`COMMIT` — сохранение изменений  
`ROLLBACK` — отмена изменений  
`SAVEPOINT` — контрольная точка для отмены изменений  
`SET TRANSACTION` — установка характеристик текущей транзакции  

Команды для управления транзакцией могут использоваться только совместно с такими запросами как `INSERT`, `UPDATE` и `DELETE`. Они не могут использоваться во время создания и удаления таблиц, поскольку эти операции автоматически отправляются в БД.

Удаляем пользователя, возраст которого составляет 26 лет, и отправляем изменения в БД:

```sql
BEGIN TRANSACTION
DELETE FROM users
WHERE age = 26;
COMMIT;
```

Удаляем пользователя с именем Oleg и отменяем эту операцию:

```sql
BEGIN
  DELETE FROM users
  WHERE username = 'Oleg';
ROLLBACK;
```

Контрольные точки создаются с помощью такого синтаксиса:  
`SAVEPOINT savepointName;`

Возврат к контрольной точке выполняется так:  
`ROLLBACK TO savepointName;`

Выполняем три запроса на удаление данных из users, создавая контрольные точки перед каждый удалением:

```sql
START TRANSACTION
SAVEPOINT sp1;
DELETE FROM users
WHERE age = 26;

SAVEPOINT sp2;
DELETE FROM users
WHERE userName = 'Oleg';

SAVEPOINT sp3;
DELETE FROM users
WHERE status = 'inactive';
```

Отменяем два последних удаления, возвращаясь к контрльной точке sp2, созданной после первого удаления:  
`ROLLBACK TO sp2;`  
из таблицы был удален только пользователь с возрастом 26 лет.

Для удаление контрольной точки используется команда `RELEASE SAVEPOINT`. Естественно, после удаления контрольной точки, к ней нельзя будет вернуться с помощью `ROLLBACK TO`.

<br>
Команда `SET TRANSACTION` используется для инициализации транзакции, т.е. начала ее выполнения. При этом, можно определять некоторые характеристики транзакции. Например, так можно определить уровень доступа транзакции (доступна только для чтения или для записи тоже):

`SET TRANSACTION [READ WRITE | READ ONLY];`

## Подзапросы

**Подзапрос** — это внутренний (вложенный) запрос другого запроса, встроенный (вставленный) с помощью WHERE или других инструкций.

Подзапрос используется для получения данных, которые будут использованы основным запросом в качестве условия для фильтрации возвращаемых записей.

Подзапросы могут использоваться в инструкциях `SELECT`, `INSERT`, `UPDATE` и `DELETE`, а также с операторами =, <, >, >=, <=, `IN`, `BETWEEN` и т.д.

Правила использования подзапросов:

* они должны быть обернуты в круглые скобки
* подзапрос должен содержать только одну колонку для выборки, если основной запрос не содержит несколько таких колонок, которые сравниваются в подзапросе
* в подзапросе нельзя использовать команду `ORDER BY`, это можно сделать в основном запросе. В подзапросе для замены ORDER BY можно использовать GROUP BY
* подзапросы, возвращающие несколько значений, могут использоваться только с операторами, которые работают с наборами значений, такими как `IN`
* список `SELECT` не может содержать ссылки на значения, которые оцениваются (вычисляются) как BLOB, ARRAY, CLOB или NCLOB
* подзапрос не может быть сразу передан в функцию для установки значений
* команду `BETWEEN` нельзя использовать совместно с подзапросом. Тем не менее, в самом подзапросе указанную команду использовать можно

Подзапросы, обычно, используются в инструкции `SELECT`.

```sql
SELECT col1, col2, ...colN
FROM table1, table2, ...tableN
WHERE colName operator
  (SELECT col1, col2, ...colN
  FROM table1, table2, tableN
  [WHERE condition]);
```

Пример:

```sql
SELECT * FROM users
WHERE userId IN (
  SELECT userId FROM users
  WHERE status = 'active'
);
```
<br>
Подзапросы могут использоваться в инструкции `INSERT`. Эта инструкция добавляет в таблицу данные, возвращаемые подзапросом. При этом, данные, возвращаемые подзапросом, могут быть модифицированы любыми способами.

```sql
INSERT INTO tableName col1, col2, ...colN
SELECT col1, col2, ...colN
FROM table1, table2, ...tableN
[WHERE operator [value]];
```
<br>
Данные, возвращаемые подзапросом, могут использоваться и для удаления записей.

```sql
DELETE FROM tableName
[WHERE operator [value]
  (
    SELECT colName
    FROM tableName
    [WHERE condition]
  )
];
```

## Последовательности

**Последовательность** — это набор целых чисел (1, 2, 3 и т.д.), генерируемых автоматически. Последовательности часто используются в БД, поскольку многие приложения нуждаются в уникальных значениях, используемых для идентификации строк.

Приведенные ниже примеры рассчитаны на ***mysql***.

Простейшим способом определения последовательности является использование `AUTO_INCREMENT` при создании таблицы:

```sql
CREATE TABLE tableName (
  id INT UNSIGNED NOT NULL AUTO_INCREMENT,
  PRIMARY KEY (id),
  -- другие строки
);
```

Для того, чтобы заново пронумеровать строки с помощью автоматически генерируемых значений (например, при удалении большого количества строк), можно удалить колонку, содержащую такие значения и создать ее заново. Обратите внимание: такая таблица не должна быть частью объединения.

```sql
ALTER TABLE tableName DROP id;
ALTER TABLE tableName
ADD id INT UNSIGNED NOT NULL AUTO_INCREMENT FIRST,
ADD PRIMARY KEY (id);
```

По умолчанию значения, генерируемые с помощью `AUTO_INCREMENT`, начинаются с 1. Для того, чтобы установить другое начальное значение достаточно указать, например, `AUTO_INCREMENT = 100` — в этом случае нумерация строк начнется со 100.

## Команды PostgreSQL

### В интерактивном режиме

* `\connect db_name` – подключиться к базе с именем db_name
* `\du` – список пользователей
* `\dp` (или `\z`) – список таблиц, представлений, последовательностей, прав доступа к ним
* `\di` – индексы
* `\ds` – последовательности
* `\dt` – список таблиц
* `\dt+` — список всех таблиц с описанием
* `\dt *s*` — список всех таблиц, содержащих s в имени
* `\dv` – представления
* `\dS` – системные таблицы
* `\d+` – описание таблицы
* `\o` – пересылка результатов запроса в файл
* `\l` – список баз данных
* `\i` – читать входящие данные из файла, например `\i /my/directory/my.sql`
* `\e` – открывает текущее содержимое буфера запроса в редакторе (если иное не указано в окружении переменной EDITOR, то будет использоваться по умолчанию vi)
* `\d “table_name”` – описание таблицы
* `\pset` – команда настройки параметров форматирования
* `\echo` – выводит сообщение
* `\set` – устанавливает значение переменной среды. Без параметров выводит список текущих переменных (\unset – удаляет).
* `\?` – справочник psql
* `\help` – справочник SQL
* `\q` (или Ctrl+D) – выход с программы

### В командной строке

`psql`

* `-c` (или `–command`) – запуск команды SQL без выхода в интерактивный режим
* `-f file.sql` — выполнение команд из файла file.sql
* `-l` (или `–list`) – выводит список доступных баз данных
* `-U` (или `–username`) – указываем имя пользователя (например postgres)
* `-W` (или `–password`) – приглашение на ввод пароля
* `-d dbname` — подключение к БД dbname
* `-h` – имя хоста (сервера)
* `-s` – пошаговый режим, то есть, нужно будет подтверждать все команды
* `–S` – однострочный режим, то есть, переход на новую строку будет выполнять запрос(избавляет от ; в конце конструкции SQL)
* `-V` – версия PostgreSQL без входа в интерактивный режим

Примеры:
`psql -U postgres -d dbname -c «CREATE TABLE my(some_id serial PRIMARY KEY, some_text text);»` — выполнение команды в базе dbname.

### Утилиты (программы) PostgreSQL

* createdb и dropdb – создание и удаление базы данных (соответственно)
* createuser и dropuser – создание и удаление пользователя (соответственно)
* pg_ctl – программа предназначенная для решения общих задач управления (запуск, останов, настройка параметров и т.д.)
* postmaster – многопользовательский серверный модуль PostgreSQL (настройка уровней отладки, портов, каталогов данных)
* initdb – создание новых кластеров PostgreSQL
* initlocation – программа для создания каталогов для вторичного хранения баз данных
* vacuumdb – физическое и аналитическое сопровождение БД
* pg_dump – архивация и восстановление данных
* pg_dumpall – резервное копирование всего кластера PostgreSQL
* pg_restore – восстановление БД из архивов (.tar, .tar.gz)

Создание бекапа базы mydb, в сжатом виде:  
`pg_dump -h localhost -p 5440 -U someuser -F c -b -v -f mydb.backup mydb`
