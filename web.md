# Веб-интерфейс пользователя

## Содержание

* [Что такое веб-интерфейс?](#что-такое-веб-интерфейс)
* [Из чего состоит веб-интерфейс](#из-чего-состоит-веб-интерфейс)
  * [HTML](#html)
  * [JavaScript (JS)](#javascript-js)
  * [CSS](#css)
* [Тестирование веб-интерфейса](#тестирование-веб-интерфейса)
  * [Набор инструментов DevTools](#набор-инструментов-devtools)
    * [Elements (элементы)](#elements-элементы)
    * [Console (консоль)](#console-консоль)
    * [Sources (исходные файлы)](#sources-исходные-файлы)
    * [Network (сеть)](#network-сеть)
    * [Application](#application)
  * [Прокси-серверы](#прокси-серверы)

## Что такое веб-интерфейс?

**Интерфейс пользователя (User Interface, UI)** — это часть программного обеспечения, которая служит для обмена информацией между пользователем-человеком и вычислительной системой (её аппаратными и программными компонентами).

Проектирование интерфейса пользователя — это процесс, в ходе которого разработчик обеспечивает необходимую функциональность интерфейса, а также создаёт элементы, помогающие пользователю работать с интерфейсом интуитивно. Главная задача проектировщика — сделать взаимодействие простым и эффективным. Хорошо спроектированный интерфейс улучшает впечатление от работы с системой и привлекает пользователей на сайт. Неудачный интерфейс может усложнить работу с системой и разочаровать пользователей, уменьшая число посетителей сайта. При проектировании веб-страниц важную роль играет создание интерфейса пользователя.

При разработке веб-страниц используется много общих элементов:

* элементы управления вводом
  * кнопки
  * выпадающие меню
  * поля данных
* навигационные компоненты
  * поля поиска
  * слайдер
  * кнопки
  * теги
* информационные компоненты
  * индикаторы выполнения
  * уведомления
  * окна сообщений

Типы пользовательского интерфейса:

* GUI (Graphical User Interface — графический интерфейс пользователя).
* CLI (Command Line Interface — интерфейс командной строки): текстовый интерфейс.
* Menu Driven (Интерфейс на основе меню) — этот тип предоставляет списки вариантов на выбор. Такой интерфейс используется, например, в банкоматах.
* Form based (Интерфейс на основе форм) — с его помощью пользователь может ввести данные, используя ограниченный набор вариантов. С помощью такого интерфейса, например, выполняется настройка профиля.
* Touch (Сенсорный интерфейс) — во множестве смартфонов и планшетов для работы пользователя с устройством используются прикосновения к экрану.
* Voice (Голосовой) — смартфоны, дистанционное управление телевизорами и прочее можно усовершенствовать с помощью голосовых технологий.

**Веб-интерфейс (Web UI)** основан на графическом интерфейсе, интерфейсе на основе меню и на основе форм.

То, что видит пользователь, называется **фронтендом**. То, что пользователь не видит, называется **бэкендом**.  
Бэкенд включает бизнес логику, базы данных и другие технические части системы, обеспечивающие работу фронтенда.

Исходный код веб-страниц состоит из HTML, CSS и JavaScript (JS).

Браузер читает исходный код и создает веб-страницу для отображения. Это включает создание модели объектов документа (Document Object Model, DOM) и применение стилей к элементам.

## Из чего состоит веб-интерфейс

### HTML

HTML расшифровывается как HyperText Markup Language.  
Это одна из основных технологий для создания веб-страниц. HTML используется для определения структуры веб-страниц.

Древовидная схема страницы **DOM (Document Object Model — объектная модель документа)**. Каждая ветвь дерева заканчивается узлом, содержащим объект. Формат DOM позволяет работать с веб-страницами с помощью языков программирования и сценариев. DOM используется для представления структуры документа (веб-страницы) в памяти. С представлением в формате DOM можно работать с помощью кода на языке JavaScript и XML.

### JavaScript (JS)

 JavaScript — это высокоуровневый язык программирования, который широко используется для создания интерактивных элементов на веб-страницах. Существует огромное множество инструментов и средств для применения этого языка. JavaScript является скриптовым (сценарным) языком. Для выполнения кода, написанного на скриптовых (сценарных) языках, не требуется предварительная компиляция. Такой код выполняется браузером при получении веб-страницы или при возникновении события, например, при наступлении определённого времени или при нажатии пользователем кнопки.

JavaScript позволяет программистам сделать веб-страницу более надежной и динамичной. Он позволяет связать браузер и технологическую платформу, на которой он запущен. Благодаря JavaScript веб-страницы обретают функциональность, свойственную традиционному программному обеспечению.

### CSS

CSS — Cascading Style Sheets — каскадные таблицы стилей используются, чтобы задать внешний вид веб-страниц, включая цвет, компоновку и шрифты.

С его помощью программисты могут адаптировать отображение страниц к различным типам устройств, например к экранам разных размеров. Стили CSS применяются согласно принципу каскадирования. Каждый уровень кода CSS надстраивается на предыдущий, переопределяя существующие настройки стиля и добавляя новые. Если у вас есть два правила для одного элемента страницы (одно на вышестоящем уровне и одно на уровне элемента), то применяется правило вышестоящего уровня. Разделение фрагментов кода HTML и кода CSS облегчает сопровождение веб-сайтов, применение одной таблицы для различных элементов и настраивание страниц для различных устройств и окружения.

## Тестирование веб-интерфейса

При тестировании веб-интерфейсов мы заостряем внимание на двух основных вещах: *визуальное* и *функциональное* тестирование.

При *визуальном* тестировании нужно учитывать следующее:

* Высокоуровневое функциональное тестирование может выявить визуальные дефекты. Например, сохраняют ли поля свои значения или корректно ли отображается страница после появления сообщения об ошибке.
* Совместимость с различными платформами. Обязательно проведите тестирование в различных веб-браузерах и в различных версиях браузеров. Используйте различные разрешения экрана.
* Совместимость с различными размерами экрана. Протестируйте интерфейс на множестве устройств с различными размерами экрана: ноутбуки, персональные компьютеры с мониторами, смартфоны и планшеты. Тестируйте как в книжном режиме, так и в альбомном режиме. Обратите внимание на скорость работы веб-страницы на различных устройствах.
* Доступность на мобильных устройствах для людей с особыми потребностями. Выясните, как интерфейс выглядит с различными размерами шрифта на мобильных устройствах. Достаточен ли цветовой контраст, работает ли управление голосовыми командами, корректно ли формируется изображение при изменении масштаба?
* Типографические ошибки. Оцените выравнивание текста. Проверьте орфографию и грамматику.
* Расположение изображений. Проверьте, не перекрываются ли текст и изображения и выровнены ли они надлежащим образом.

При *функциональном* тестировании необходимо учитывать не только внешние проявления фронтенда, но соответствие логики работы бэкенда поведению, задуманному при проектировании. Обновляется ли информация в базе данных? Создаются ли файлы? Отправляются ли данные от одного приложения другому?

Тестировщик должен знать ВСЕ процессы, происходящие внутри бэкенда, и проверять корректность их работы.

Тестировщик должен знать, что определенные данные могут изменять поведение приложения, в веб-кэше могут находиться устаревшие данные, а файлы cookie и локальное хранилище могут оказать влияние на поведение приложения. Также, стоит проверить, что в веб-браузере не установлен плагин, способный помешать корректной работе приложения.

### Набор инструментов DevTools

#### Elements (элементы)

На этой вкладке отображается исходный код HTML страницы. Страница на ней показана именно в формате DOM. Также на вкладке присутствует указатель для быстрой навигации по дереву.

Есть возможность редактировать представление DOM: изменять атрибуты элементов, добавлять или удалять элементы и т. д. Также есть вложенная вкладка Styles (стили), на которой можно посмотреть весь применяемый код CSS. Отдельные настройки стиля можно включать, выключать и редактировать.

Стоит упомянуть ещё одну полезную функцию: изменение разрешения экрана — это намного упрощает такие задачи, как когда нужно выяснить, что произойдёт, если открыть приложение на мобильном устройстве.

#### Console (консоль)

На вкладке Console показаны записи журнала JavaScript (предупреждения, сообщения об ошибках и другие). Также здесь есть возможность выполнять код JavaScript.

#### Sources (исходные файлы)

Вкладка Sources похожа на оглавление. В ней показываются исходные файлы, составляющие веб-страницу. Файлы могут быть следующие: HTML, JavaScript, CSS, изображения и т.д. Есть возможность просматривать исходные файлы и сохранять их для дальнейшего изучения.

#### Network (сеть)

На этой вкладке регистрируется сетевая активность (запросы и ответы), поэтому мы можем увидеть, что было отправлено и что получено. Более того, можно скопировать запрос и самостоятельно повторно отправить его. На вкладке также показано время выполнения запроса, таким образом, можно обнаружить медленную работу сетевого соединения.

Ещё одна функция: изменение скорости связи по сети (дросселирование), чтобы тестировщик мог исследовать работу приложения в условиях «плохого Интернета».

#### Application

На этой вкладке пользователь может очистить данные сайта, например, cookies. Для этого нужно выбрать Application -> Storage-> кнопка "Clear site data" (Приложение -> Хранилище -> кнопка «Очистить данные сайта»). Тестовому инженеру может потребоваться выполнить это для удаления "устаревших данных" (stall data), которые могут вызывать сбои в приложении.

Еще одна полезная область на вкладке - это пункт меню "Storage" (Хранилище). Там пользователь может просматривать и редактировать данные, хранящиеся локально, а также cookies. Это может быть полезным в некоторых случаях, Например можно изменить региональные настройки на лету или для изменения времени истечения срока файлов cookie, чтобы не пришлось ждать много дней Приложение может хранить локальные настройки в файлах cookie, поэтому, меняя cookie, тестировщик быстро меняет и настройки.

### Прокси-серверы

**Прокси-сервер (Proxy server)** — это инструмент, исполняющий роль шлюза между сервером и клиентом. Все запросы и ответы проходят через прокси-сервер, поэтому можно отслеживать и изменять на лету всё, что отправляется и принимается.

Тестировщику такой «посредник» даёт возможность изучать обмен данными и, например, имитировать недопустимый ответ сервера.

* Charles
* Fiddler

## XPath и CSS-селекторы

### XPath

**XPath** - означает «XML Path Language», что отражает первичное предназначение: навигацию по структуре и атрибутам XML-документа. Один из способов поиска элементов веб-страницы при тестировании.

В практическом рассмотрении XPath представляет собой последовательность шагов, которая описывает, как перейти к какому-то нужному узлу (или группе узлов) в XML-документе. Узлом может считаться элемент страницы, атрибут, текст, комментарий, или любая другая часть страницы, что очень полезно в автоматизации веба, а также и при тестировании мобильных приложений.

#### Абсолютный и относительный путь

**Абсолютный xpath** начинается с одного слэша ( / ) и указывает на полный путь из корневого узла (root) к целевому (target). Например, следующее выражение в XPath:

```xpath
/html/body/div[1]/h1 
```

— означает: «выбрать первый **div**-элемент под **body**-элементом под **html**-элементом, и далее выбрать его вложенный (или дочерний, child) **h1**-элемент».

**Относительный путь** начинается с дабл-слэша (двух //) и указывает на путь из любого узла (= нода) который отвечает критериям, к целевому узлу. Например,

```xpath
//div[@id='main']
```

— означает «выбрать любой **div**-элемент, имеющий **id**-атрибут со значением **‘main’**»

#### Синтаксис XPath



### Поиск конкретного элемента

|CSS|XPath|Комментарий|
|--|--|--|
|*|//*|Найти любой элемент (используется обычно как часть более сложного запроса)|
|div|//div|Найти элемент div|
|div:nth-of-type(2)|//div[2]|Найти 2-ой элемент div под общим родителем (вместо 2 может быть любая цифра). *В CSS используется псевдокласс, в firefox он не срабатывает, в хроме тоже может глючить. В этом сценарии xpath лучше*|

### Поиск по атрибутам

#### Любой элемент

|CSS|XPath|Комментарий|
|--|--|--|
|.form-control|//*[@class="form-control"]|Элемент с **классом** form-control|
|#sample_1|//*[@id="sample_1"]|Элемент с атрибутом **id** = sample_1|
|[data]|//*[@data]|Элемент с атрибутом data, значение у атрибута любое|

#### Конкретный элемент

|CSS|XPath|Комментарий|
|--|--|--|
|div.form-control|//div[@class="form-control"]|Именно div элемент с атрибутом class=form-control|
|div#sample_1|//div[@id="sample_1"]|Именно div элемент с атрибутом id = sample_1|
|div[id]|//div[@id]|Именно div элемент с атрибутом id|
|div[attr]:nth-child(2)|//div\[2\]\[@attr\]|2-ой элемент div с атрибутом attr под общим родителем. *XPath найдет такой div, даже если между 2-мя div-ами будет что-то ещё. А вот CSS нет, только если подряд идут. Поэтому с потомками лучше через XPath*|
|h1:not([id])|//h1[not(@id)]|Элемент h1, у которого нет атрибута id|
|a:is([name],[href])|//a[@name or @href]|Элемент а, у которого есть или атрибут name, или href, или оба|

#### Сравнения по тексту атрибута

Есть атрибут class, проверяем текст в нем. Допустим, у нас есть такие элементы:

1. class = “test-1 test-3 test-2”
2. class = “test-1”

|CSS|XPath|Комментарий|
|--|--|--|
|[class="test-1"]|//*[@class="test-1"]|Текст четко равен "test-1" (тип кавычек не важен). ***Найдет элемент 2, но не найдет элемент 1***|
|[class~="test-3"]|//*[contains(@class, 'test-3')]|Текст атрибута состоит из нескольких слов, разделенных пробелами, одно из них — искомое. *В XPath такого нет, поэтому там просто contains — в тексте есть искомое значение.* ***Найдет элемент 1***|
|[class\|="test"]|//*[contains(@class, 'test')]|Полное соответствие или атрибут начинается как указано и потом идет "-" (U+002D). ***Найдет и элемент 1, и элемент 2***|
|[class^="te"]|//\*[starts-with(@class, 'te')]  //*[substring-after(@class, 'te')]|Начинается на … ***Найдет и элемент 1, и элемент 2***. *В Xpath 2 варианта записи, substring-after ищет текст, который идет после указанного, то есть указанный должен быть. В CSS запись как в регулярных выражениях*|
|[class$="2"]|//*[substring-before(@class, '2')]|Заканчивается на … ***Найдет только элемент 1*** *В Xpath ещё должно быть выражение «ends-with», но оно не работает 🙁*|
|[class*="st"]|//*[contains(@class, 'st')]|Содержит искомый текст (хотя бы 1 вхождение, неважно где, начало, конец или середина строки). ***Найдет и элемент 1, и элемент 2***|

### Поиск по тексту элемента

|CSS|XPath|Комментарий|
|--|--|--|
|-|//a/text()[. ="Ссылка"]|Текст внутри тегов \<a\> равен «Ссылка»|
|-|//a[contains(text(),'Ссылка')]|Текст содержит «Ссылка» (может быть частью слова)|
|-|//\*[starts-with(text(), 'Ссы')]  //*[substring-after(text(), 'Ссы')]|Начинается на …|
|-|//*[substring-before(text(), 'ка')]|Заканчивается на … (одно из слов, «Ссылка 1» тоже найдет)|
|-|//a[string-length(text()) > 6]|Длина текста тега \<a\> больше 6 символов (оператор может быть любым)|

### Поиск по позиции элемента

|CSS|XPath|Комментарий|
|--|--|--|
|div:first-child|//*\[1\]\[name()="div"\]|Первый div|
|div:last-child|//*\[last()\]\[name()="div"\]|Последний div|
|body div:last-child|//body/div[last()]|Последний div внутри body|
|div:nth-last-of-type(2)|//body/div[last()-1]|Предпоследний div|
|div:nth-of-type(-3+2)|//body/div[position()<3]|Все div от 1 до 3 (не включительно, оператор может быть любым)|
|div:nth-of-type(2)|//body/div[position()=2]|Конкретная позиция (2-ая, но цифра может быть любой). *CSS работает с оговорками*|
|div:first-of-type|//div[1]|Первый элемент div|
|div#id:first-of-type|//div\[1\]\[@id\]|Первый элемент div с атрибутом id|
|div[attr]:first-of-type|//div\[1\]\[@attr\]|Первый элемент div с атрибутом attr|
|div:last-of-type|//div[last()]|Последний элемент div|

### Поиск потомков (обход дерева вниз)

|CSS|XPath|Комментарий|
|--|--|--|
|div h2|//div//h2|h2, дочерний к div (на любом уровне вложенности, div - test - h2 найдет)|
|div > h2|//div/h2|Прямой потомок (1 уровень вложенности, div - test - h2 уже не найдет)|
|div > div > h2|//div/div/h2|Спускаемся по дереву, ищем div, внутри ещё div, внутри h2 (прямые потомки везде)|
|body > *|//body/child::*|Дети (1 уровень вложенности) любые|
|body > div|//body/child::div|Дети с типом div|
|body *|//body/descendant::*|Все потомки (любой уровень вложенности: дети, внуки…)|
|body div|//body/descendant::div|Только потомки div|
|-|//body/descendant-or-self::*|Сам body и все потомки|
|-|//head/following::*|Все, что идет после закрывающего тега head (все, что ниже по дереву, исключая потомков)|
|-|//head/following::a|Все элементы a, которые идут после head|

### Поиск предков (обход дерева вверх)

|CSS|XPath|Комментарий|
|--|--|--|
|-|//a/ancestor::*|Все предки ссылки - родитель, дед, прадед, на все уровни вверх смотрим (\<a\> — это ссылка в HTML)|
|-|//a/ancestor::div|Только предок div|
|-|//a/ancestor-or-self::*|Сама ссылка + предки|
|-|//a/ancestor-or-self::div|Сама ссылка + предки div|
|-|//a/ancestor-or-self::a|Сама ссылка + предки такого же типа (a)|
|*:has(> a)|//a/parent::*|Родитель ссылки (строго 1 уровень наверх)|
|-|//p/preceding::*|Все узлы до текущего, кроме непосредственного родителя (выше по дереву, кроме родителя)|
|-|//p/preceding-sibling::*|Все узлы-соседи до текущего узла (под одним родителем). Братья выше по дереву.|

### Поиск соседей

|CSS|XPath|Комментарий|
|--|--|--|
|h1 ~ h2|//h1/following-sibling::h2|Все элементы h2, которые находятся после элемента h1 внутри одного родителя, на том же уровне, что и h1 (h2-братья h1 ниже по дереву)|
|h1 + h2|//h1/following-sibling::h2[1]|Только первый элемент h2, соседний к h1 справа (находится после). *В XPath можно выбрать не только первый, но и второй, третий, даже last()*|
|h1 ~ h2:last-of-type|//h1/following-sibling::h2[last()]|Последний элемент h2, который находится после элемента h1 внутри одного родителя|

### Поиск по комментариям

|CSS|XPath|Комментарий|
|--|--|--|
|-|//comment()|Все комментарии|
|-|//comment()[. = 'comment']|Комментарий с конкретным текстом|
|-|//comment()[. = ' comment ']/parent::*|Родительский элемент комментария|
