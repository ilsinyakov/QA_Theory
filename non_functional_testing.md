# Нефункциональное тестирование

## Содержание

* [Разница между функциональным и нефункциональным тестированием](#разница-между-функциональным-и-нефункциональным-тестированием)
* [Виды нефункционального тестирования](#виды-нефункционального-тестирования)
* [Тестирование пользовательского интерфейса (UI)](#тестирование-пользовательского-интерфейса-ui)
* [Тестирование удобства использования (UX)](#тестирование-удобства-использования-ux)
  * [Тестирование обучаемости (Learnability testing)](#тестирование-обучаемости-learnability-testing)
  * [Тестирование доступности (Accessibility testing)](#тестирование-доступности-accessibility-testing)
  * [Тестирование отслеживания движения глаз (Eye tracking testing)](#тестирование-отслеживания-движения-глаз-eye-tracking-testing)
* [Тестирование безопасности](#тестирование-безопасности)
  * [Уязвимости программного обеспечения](#уязвимости-программного-обеспечения)
    * [SQL-инъекции (SQLi)](#sql-инъекции-sqli)
    * [Подключение внешних файлов (Remote File Inclusion, RFI)](#подключение-внешних-файлов-remote-file-inclusion-rfi)
    * [Подключение локальных файлов (Local File Inclusion, LFI)](#подключение-локальных-файлов-local-file-inclusion-lfi)
    * [Неправильная конфигурация программного обеспечения](#неправильная-конфигурация-программного-обеспечения)
* [Тестирование производительности](#тестирование-производительности)

## Разница между функциональным и нефункциональным тестированием

Проверка функций приложения очень важна. Без правильно работающих функций не имеет смысла говорить о юзабилити или безопасности. Этот вид тестирования называется функциональным тестированием (FT). Все остальные проверки относятся к нефункциональному тестированию (NFT).  
Соответственно, говорят о функциональных и нефункциональных требованиях к приложению (FR и NFR).  
Понять разницу легко на простом примере.

|Функциональные требования|Нефункциональные требования|
|-|-|
|Когда посетитель сайта создает учетную запись, ему должно быть отправлено приветственное электронное письмо|Сервер должен отправить приветственное письмо в течение 10 минут после регистрации|
|Когда статус заказа меняется на выполнение, локальный принтер должен распечатать упаковочный лист|При печати упаковочных листов они должны быть на обеих сторонах листов белой бумаги размером 5" x 8".|
|Система должна позволять пользователю заполнять и отправлять форму|Когда форма запрашивается сервером, она должна загрузиться в течение 1 секунды. При нажатии кнопки Submit форма должна загрузиться в течение 2 секунд.|

Универсальным правилом здесь является "если вы видите цифры, то это, скорее всего, NFR (нефункциональное требование)"

Большая часть нефункционального тестирования выполняется специальными командами. Это особенно верно для сложных видов тестирования, требующих специальных знаний, таких как тестирование безопасности или производительности.

## Виды нефункционального тестирования

* **Тестирование пользовательского интерфейса**. Соответствует ли внешний вид приложения макетам (специальным требованиям пользовательского интерфейса)?
* **Удобство использования**. Удобно ли приложение для целевой аудитории?
* **Производительность**. Это семейство типов тестирования (устойчивость, масштабируемость, нагрузка, стресс и т.д.), которые проверяют время выполнения операций в различных условиях.
* **Интероперабельность**. Тестирование взаимодействия между двумя или более системами. Проверяются протоколы, типы и форматы данных, совместимость физических устройств и алгоритмы.
* **Переносимость**. Проверка возможности и простоты переноса приложения из одной среды в другую, например, на новую версию ОС, с iOS на Android, с одного браузера на другой, с другим ядром.
* **Эффективность**. Проверка количества внутренних ресурсов, необходимых для выполнения определенных операций.
* **Безопасность**. Тестирование внутренних механизмов безопасности, защиты данных пользователей, ролей и прав.
* **Надежность**. Может ли система выдерживать нагруженный трафик, огромный объем данных и т.д. в течение длительного периода времени без сбоев?
* **Целостность данных**. Проверка того, что данные в базе не будут неожиданно изменены или повреждены после миграции данных.
* **Локализация**. Правильно ли система адаптирована к новому рынку?

## Тестирование пользовательского интерфейса (UI)

Тестирование пользовательского интерфейса — это проверка того, насколько внешний вид приложения соответствует требованиям.
Наиболее популярным инструментом для создания дизайна пользовательского интерфейса является **Figma**.

**Макет** — техническое требование к пользовательскому интерфейсу приложения. Он включает в себя описание элементов управления, цветов, изображений, размеров и расстояний между элементами и не подразумевает никаких деталей функциональности.

Вы должны понимать основные принципы дизайна и уметь сравнивать макет с реальным приложением. В инструментах разработки *Элементы* могут помочь вам определить стили, цвета и расстояния и сравнить с макетом.

## Тестирование удобства использования (UX)

Юзабилити — это семейство видов нефункционального тестирования. Некоторые примеры юзабилити приведены ниже.

* Обучаемость
* Доступность
* Отслеживание взгляда

 В большинстве случаев для правильного тестирования юзабилити необходима фокус-группа.

### Тестирование обучаемости (Learnability testing)

Как быстро можно освоить продукт?

Очевидно, что для массового простого продукта, такого как мессенджер или расслабляющая игра, и сложного профессионального продукта, такого как фоторедактор для дизайнеров, ожидается разная скорость обучения. Но всегда есть некая ожидаемая скорость освоения функций.

Как протестировать обучаемость
Для тестирования обучаемости приглашается фокус-группа.
Последовательность тестируемых шагов повторяется несколько раз. Каждый раз измеряется скорость прохождения, которая сравнивается со скоростью на предыдущем шаге.
Таким образом, можно проверить и измерить различные варианты интерфейса.

### Тестирование доступности (Accessibility testing)

Обычно под этим понимается доступность приложения для людей с ограниченными возможностями. Это может быть функция преобразования текста в речь (полезная не только для слепых, но и для тех, кто страдает дислексией), особый внешний вид (крупные иконки или схема для дальтоников), совместимость с устройствами для людей с нарушениями двигательных функций и т.д.

### Тестирование отслеживания движения глаз (Eye tracking testing)

Требует не только специальных знаний, но и специальных устройств. Единственный вид тестирования, который нельзя провести удаленно из дома.

Цель такого тестирования — отследить перемещения глаз по приложениям. Некоторые элементы управления должны быть замечены раньше, некоторые из них более важны, и внимание пользователя должно быть обращено на них. Но отследить движения глаз невозможно без специального оборудования — очков или экранных устройств.

## Тестирование безопасности

* **Тестирование на проникновение, также известное как "пентест"**, ориентировано на имитацию действий хакеров (заранее одобренных и разрешенных заказчиком) по взлому защищенных инфраструктур конкретного клиента, заказавшего услугу пентеста. Область его применения может быть очень широкой и включать различные цели, такие как интернет-серверы компании, интранет-ресурсы, почтовые ящики, сотрудники, на которых проводятся атаки с применением социальной инженерии, и практически все (легальное и не запрещенное напрямую), что могут сделать хакеры для достижения своих целей. В эту область входит очень многое, не только приложения и их недостатки (также ОС, сетевые устройства и даже психология), поэтому она выходит за рамки учебника.
* **Тестирование безопасности приложений** гораздо ближе к "типичной" деятельности QA, чем полнофункциональное тестирование на проникновение. Его основная цель — определить наличие (или отсутствие) уязвимостей и недостатков программного обеспечения в интересующем приложении.

Последнее осуществляется различными способами, в том числе:

* **Обратное проектирование (reverse engineering)**, особенно для бинарных исполняемых файлов (например, *.exe в Windows) и микропрограмм. В основном выполняется вручную реверс-инженерами, работа которых похожа на работу антивирусных аналитиков.
* **Проверка исходного кода**, когда соответствующие исходные тексты доступны полностью. Может быть выполнена с помощью специальных автоматизированных инструментов.
* **Тестирование "черного ящика"**, когда приложение проверяется извне против соответствующих атак, которые в основном связаны со специально разработанными входными данными и определенными условиями (например, враждебное окружение и так далее). Обычно это смесь ручных тестов и автоматизированных проверок.

### Уязвимости программного обеспечения

**Уязвимость программного обеспечения** — это дефект, позволяющий злоумышленникам нарушить хотя бы одно из следующих условий:

* *Конфиденциальность*: получить конфиденциальные данные из уязвимого приложения или связанных с ним компонентов (ОС, файлы, другие приложения), например, украсть БД с информацией о клиентах.
* *Целостность*: изменить данные, включая конфиденциальную информацию (например, баланс банковского счета) и настройки приложения или связанных с ним компонентов.
* *Доступность*: сделать приложение (или связанные с ним компоненты) недоступным или неправильно функционирующим, например, заставить его остановиться.

#### SQL-инъекции (SQLi)

Когда приложение принимает пользовательский ввод и взаимодействует с базовой БД, разработчики хотят, чтобы это приложение показывало пользователям только ограниченную информацию (которая не является конфиденциальной и в основном относится к каждому пользователю) и ничего больше, но хакеры хотят получить все из подключенной БД, поскольку она может содержать много конфиденциальной информации, такой как учетные данные пользователей, информация о кредитных картах и многое другое.

Если приложение не проверяет пользовательский ввод должным образом, злоумышленники могут послать специально созданный ввод, заставляя приложение отправлять "расширенные" (и неожиданные для разработчиков) запросы к БД.

Если злоумышленникам повезет, то они даже изменят соответствующие записи в БД, а не только прочитают их.
Уязвимости SQL-инъекций могут существовать как в обработчиках методов GET, так и POST, если они плохо реализованы в конкретном веб-приложении.
Этот тип уязвимостей хорошо известен, и существует множество инструментов для автоматизации таких проверок, например, известные open-source SQLmap и SQLNinja.

#### Подключение внешних файлов (Remote File Inclusion, RFI)

Если веб-приложение принимает URL в качестве параметра, можно предоставить URL, указывающий на внешний сервер, который может контролироваться злоумышленниками. Плохо разработанные приложения могут выполнять такой скрипт, полученный с вредоносного внешнего ресурса, без какой-либо фильтрации.

#### Подключение локальных файлов (Local File Inclusion, LFI)

Оно похоже на RFI, но работает с локальными файлами.

В соответствии с принципами разрешения доступа к файлам в ОС, каждый файл, читаемый учетной записью веб-сервера, может быть включен в случае LFI-уязвимости. Если уязвимое приложение разработано очень плохо, эти подключенные файлы могут быть даже выполнены на стороне сервера.

#### Неправильная конфигурация программного обеспечения

Иногда трудно отличить уязвимость программного обеспечения от неправильной конфигурации. Даже хорошо спроектированное и правильно реализованное программное обеспечение может быть плохо развернуто, и/или соответствующая среда может быть небезопасной, что приводит к рискам безопасности.
Пример: слабые пароли. Кстати, слабые пароли — очень распространенный способ взлома защищенных систем.

* Слабый пароль устанавливается намеренно для администратора магазина при первоначальной настройке. Это не связано напрямую с самим приложением интернет-магазина, которое может быть разработано хорошо.
* Приложение интернет-магазина содержит жестко закодированный пароль для встроенной административной учетной записи. Это определенно уязвимость программного обеспечения, поскольку приложение было плохо разработано (и протестировано) без учета лучших практик безопасности.
* Приложение интернет-магазина не препятствует пользователям устанавливать слабые пароли. Это можно считать программной уязвимостью, но с гораздо меньшей серьезностью по сравнению с предыдущей.

### Тестирование производительности

Цель тестирования производительности — проверить поведение приложения под нагрузкой, огромным объемом данных или интенсивным трафиком. В зависимости от конкретного измерения, тестирование производительности может принимать различные формы.
Рассмотрим случай, когда тестируемый сайт должен работать с 1000 пользователей одновременно.

1. **Тестирование на выносливость (Endurance testing)**. 1000 пользователей выполняют сценарии на сайте в течение длительного периода времени.
2. **Спайк-тестирование (Spike testing)**. 10 пользователей находятся на сайте в течение определенного периода времени, затем случайно количество пользователей становится 1000.
3. **Тестирование масштабируемости (Scalability testing)**. Нагрузка начинается с 10 пользователей, затем 20 пользователей, 30 пользователей и так далее, пока число пользователей не достигнет 1000.
4. **Нагрузочное тестирование (Load testing)**. В типичных сценариях в течение короткого периода времени участвуют 1000 пользователей.
5. **Стресс-тестирование (Stress testing)**. На сайт заходят 10 000 пользователей, моделируется пиковая нагрузка.
6. **Тестирование объема (Volume testing)**. Моделируется объем данных, а не количество пользователей. Это может быть огромный размер базы данных, объемные файлы, массивные отчеты и т.д.
